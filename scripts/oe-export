#!/usr/local/sbin/suid-python --virtualenv
from __future__ import print_function

import os
from antipathy import Path
from openerplib import get_connection, get_records, AttrDict, Query, Many2One
from scription import *
import re

virtual_env = os.environ['VIRTUAL_ENV']
config = '%s/config/fnx.ini' % virtual_env

TEST = [
        'xml_id',
        'hr_insurance_choice_ids/year_month',
        'hr_insurance_choice_ids/medical',
        'hr_insurance_choice_ids/dental',
        'hr_insurance_choice_ids/vision',
        'hr_insurance_choice_ids/life',
        'name_related',
        'home_country_id/name',
        'home_country_id/code',
        ]

TEST_DOMAIN = [('name_related','in',['Abraham S. Cohen','Aurelia Garcia'])]

ALL_ACTIVE = [(1,'=',1)]

@Script(
        hostname=('host to connect to'),
        database=('database to query'),
        )
def main(hostname, database):
    global oe
    cfg = OrmFile(config, types={'_path':Path})
    oe = get_connection(
            hostname=hostname or cfg.openerp.host,
            database=database or cfg.openerp.db,
            login=cfg.openerp.user,
            password=cfg.openerp.pw,
            )

@Command(
    name=('name of export', REQUIRED),
    to_file=Spec('file to store results in', REQUIRED, type=Path),
    domain=Spec('domain to restrict record selection', OPTION, force_default=ALL_ACTIVE, type=eval),
    table=('name of OpenERP table (only needed if multiple saved exports with same name', OPTION),
    )
def oe_export(name, to_file, domain, table):
    found = []
    for export in get_records(oe, 'ir.exports', domain=[('name','=',name)]):
        found.append(export.resource)
        if table and export.resource == table:
            break
    else:
        # no exact match, check only one match found
        if not found:
            abort('no export found with name of %r' % (name, ))
        elif len(found) > 1:
            abort('multiple matches for %r:\npossible tables: %s'
                    % (name, ', '.join(found)))
    # at this point, export is the one we want
    table = export.resource
    fields_ids = export.export_fields
    fields = [
            f['name']
            for f in get_records(
                oe,
                'ir.exports.line',
                domain=[('id','in',fields_ids)],
                fields=['name'],
                )]
    q = Query(oe.get_model(table), domain=domain, fields=fields[:])
    #
    write_xls(export.name, q, fields, to_file)


@Command(
    table=('name of table', REQUIRED),
    fields=('fields to extract', MULTIREQ),
    to_file=Spec('file to store results in', REQUIRED, type=Path, force_default='-'),
    domain=Spec('domain to restrict record selection', OPTION, force_default=ALL_ACTIVE, type=eval),
    order=Spec('desired order of output', MULTI),
    separator=Spec('print separator between lines', FLAG),
    )
def adhoc(table, fields, to_file, domain, order, separator):
    fields = list(fields)
    q = Query(oe.get_model(table), domain=domain, fields=fields[:], order=order)
    #
    if to_file.endswith('.xls'):
        write_xls(table, q, fields, to_file, separator)
    elif to_file.endswith('.csv'):
        write_csv(table, q, fields, to_file, separator)
    elif to_file.endswith('.txt') or to_file == '-':
        write_txt(table, q, fields, to_file, separator)
    else:
        abort('unknown file type: %r' % to_file)


@Command(
        command=('sql command', REQUIRED),
        separator=('insert blank line between records', FLAG),
        )
def sql(command, separator):
    """\
    SELECT field_name [, field_name [, ...]]
        FROM table
        [WHERE ...]
        [ORDER BY field1 [ASC|DESC] [, field2 [ASC|DESC] [, ...]]]
        [TO file]

    DESCRIBE table
        [ORDER BY field1]
    """
    command = command.strip(' ;')
    check_command = command.lower()
    if ';' in check_command:
        abort('more than one command specified')
    if check_command.startswith('select '):
        sql_select(command, separator)
    elif check_command.startswith('describe '):
        sql_describe(command, separator)
    else:
        abort('one of SELECT | DESCRIBE not specified')

def sql_describe(command, separator):
    """
    DESCRIBE table
        [ORDER BY field1]
    """
    command = command.lower()
    desde = command.split()[1]
    if ' order by ' in command:
        orden = command.split(' order by ')[1].strip()
        if orden not in ('field','display','type','help'):
            abort('ORDER BY must be one of field, display, type, or help [ %r ]')
        sort = {
            'field': lambda t: t[0],
            'display': lambda t: t[1]['string'],
            'type': lambda t: t[1]['type'],
            'help': lambda t: t[1]['help'],
            }[orden]
    else:
        sort = lambda t: t[0]
    seleccion = sorted(oe.get_model(desde).fields_get().items(), key=sort)
    table = [('Field','Display','Type','Help'), None]
    for field, desc in seleccion:
        table.append((field, desc['string'], desc['type'], desc.get('help','').replace('\n','  ')))
    echo(table, border='table')

def sql_select(command, separator):
    """\
    SELECT field_name [, field_name [, ...]]
        FROM table
        [WHERE ...]
        [ORDER BY field1 [ASC|DESC] [, field2 [ASC|DESC] [, ...]]]
        [TO file]
    """
    imprimido = '-'
    donde = []
    check_command = command.lower()
    if ' from ' not in check_command:
        abort('FROM not specified')
    if check_command.split()[-2] == 'to':
        imprimido = command.split()[-1]
        check_command = ' '.join(check_command.split()[:-2])
    command = check_command
    #
    # get SELECT fields
    #
    seleccion, resto = command.split(' from ')
    seleccion = [s.strip(',') for s in seleccion.split()[1:]]
    if not seleccion:
        abort('missing fields')
    print('SELECT:', seleccion)
    #
    # get FROM table
    #
    resto = resto.split()
    desde, resto = resto[0], resto[1:]
    if desde in ('', 'where', 'order'):
        abort('missing table')
    elif resto:
        if resto[0] == 'where':
            resto = resto[1:]
            if not resto or resto[:2] == ['order','by']:
                abort('missing WHERE clause')
            resto = ' '.join(resto)
            donde, orden = resto.split(' order by ')
            donde = donde.strip()
            orden = orden.strip()
            resto = []
        if resto[:2] == ['order','by']:
            orden = ' '.join(resto[2:])
            resto = []
        if resto:
            abort('malformed query')
    print('FROM', desde)
    # get field names if * specified
    if seleccion == ['*']:
        seleccion = oe.get_model(desde).fields_get().keys()[:275]
    #
    # and get WHERE clause
    #
    while donde:
        # e.g. WHERE login = 'ethan'
        #      WHERE id=201
        #      WHERE blah is not null AND this = 'that'
        try:
            field, op, condition, donde = re.match(
                    "^(\w+)\s*(is not|is|like|not like|ilike|not ilike|=|<|>|<=|>=|!=)\s*('?.*(?<!\\')?|.*?)\s*(.*?)\s*$",
                    donde,
                    ).groups()
        except ValueError:
            abort('malformed WHERE clause')
        else:
            if (
                    condition[0] == condition[-1] == '"'
                 or condition[0] == condition[-1] == "'"
                 ):
                condition = condition[1:-1]
            elif condition == 'True':
                condition = True
            elif condition == 'False':
                condition = False
            elif condition == 'None':
                condition = None
            elif condition == 'null':
                pass
            else:
                try:
                    condition = int(condition)
                except ValueError:
                    try:
                        condition = float(condition)
                    except ValueError:
                        abort('unknown data type: %r %r' % (type(condition), condition))
            if (op, condition) == ('is', 'null'):
                op, condition = '=', False
            elif (op, condition) == ('is not', 'null'):
                op, condition = '!=', False
            donde.append((field,op,condition))
            if donde.startswith('or '):
                donde.insert(0, '|')
                donde = donde[3:]
            elif donde.startswith('and '):
                donde.insert(0, '&')
                donde = donde[4:]
    print('WHERE', donde)
    print('ORDER BY', orden)
    print('TO', imprimido)
    #
    # at this point we have the fields, the table, and possibly
    # the output file -- hand off to adhoc()
    #
    adhoc(desde, seleccion, imprimido, donde or ALL_ACTIVE, orden, separator)


@Command(
        table=("show exports for TABLE", )
        )
@Alias('list')
def list_exports(table=None):
    for export in get_records(oe, 'ir.exports'):
        if table and export.resource != table:
            continue
        echo('%-60s [%s]' % (export.name, export.resource))

# helpers

def write_xls(sheet_name, query, fields, file, separator):
    import xlwt
    workbook = xlwt.Workbook()
    worksheet = workbook.add_sheet(sheet_name)
    #
    for i, field_name in enumerate(fields):
        worksheet.write(0, i, query.names[field_name])
        worksheet.col(i).width = 8000 # around 220 pixels
        # TODO: calculate width base on column contents
    #
    i = 0
    for r in query.records:
        print(r, verbose=2)
        if separator:
            i += 1
        er = ExpandedRow(fields, r)
        for row in er:
            i += 1
            for cell_index, cell_value in enumerate(row):
                if isinstance(cell_value, basestring):
                    cell_value = re.sub("\r", " ", cell_value)
                if cell_value is False:
                    cell_value = None
                worksheet.write(i, cell_index, cell_value)
    workbook.save(file)

def write_csv(table, query, fields, file, separator):
    lines = []
    line = []
    print('fields:', fields, verbose=2)
    for field_name in fields:
        line.append(query.names[field_name])
    lines.append(','.join(line))
    #
    for r in query.records:
        if separator:
            lines.append('')
        er = ExpandedRow(fields, r)
        for row in er:
            line = []
            for cell_value in row:
                if isinstance(cell_value, (list, tuple)):
                    [cell_value] = cell_value
                if isinstance(cell_value, basestring):
                    cell_value = re.sub("\r", " ", cell_value)
                    cell_value = re.sub('"', '\"', cell_value)
                    cell_value = '"%s"' % cell_value
                elif cell_value in (False, None):
                    cell_value = ''
                line.append(str(cell_value))
            lines.append(','.join(line))
    with open(file, 'w') as output:
        output.write('\n'.join(lines))

def write_txt(table, query, fields, file, separator):
    lines = []
    line = []
    print(len(fields), fields, verbose=2)
    for field_name in fields:
        field_name = query.names[field_name] or field_name
        line.append(field_name)
    lines.append(line)
    for r in query.records:
        if separator:
            lines.append(None)
        er = ExpandedRow(fields, r)
        for row in er:
            line = []
            for cell_index, cell_value in enumerate(row):
                if isinstance(cell_value, Many2One):
                    # cell_value = cell_value[1]
                    pass
                elif isinstance(cell_value, (list, tuple)):
                    [cell_value] = cell_value
                if isinstance(cell_value, basestring):
                    cell_value = re.sub("\r", " ", cell_value)
                    cell_value = re.sub('"', '\"', cell_value)
                    cell_value = '"%s"' % cell_value
                elif cell_value in (False, None):
                    cell_value = ''
                line.append(str(cell_value))
            lines.append(line)
    if not separator:
        lines.insert(1, None)
    if file == '-':
        echo(lines, border='table')
    else:
        with open(file, 'w') as out:
            echo(lines, border='table', file=out)

class counter(object):

    def __init__(self, start=0):
        self.value = start

    def __iter__(self):
        return self

    def __next__(self):
        current = self.value
        self.value += 1
        return current

    next = __next__

class ExpandedRow(object):
    "converts an ordered dict into an ordered list of lists"

    def __init__(self, fields, record):
        # fields = [
        #   'xml_id',
        #   'hr_insurance_choice_ids/year_month',
        #   'hr_insurance_choice_ids/medical',
        #   'hr_insurance_choice_ids/dental',
        #   'hr_insurance_choice_ids/vision',
        #   'hr_insurance_choice_ids/life',
        #   'name_related',
        #   'home_country_id/name',
        #   'home_country_id/code',
        #   ]
        #
        # record = {
        #   'id': 8274
        #   'xml_id': 1374,
        # 	'hr_insurance_choice_ids': [
        #           {
        #            'id': 810,
        #            'year_month': '2018-07',
        #            'medical':'children',
        #            'dental':'children',
        #            'vision':'children',
        #            'life':'self',
        #           },
        #           {
        #            'id': 81820,
        #            'year_month': '2018-06',
        #            'medical':'children',
        #            'dental':'children',
        #            'vision':'children',
        #            'life':'self',
        #           }],
        #   'name_related': 'Vishan Vishal Dimri',
        #   'home_country_id': {'id':235, 'name':'United States', 'code':'US'},
        rows = []
        row = []
        for k, v in record.items():
            if k in fields:
                row.append(v)
            elif any([f.startswith(k+'/') for f in fields]):
                sub_fields = [f.split('/',1)[1] for f in fields if f.startswith(k+'/')]
                if v:
                    # many2one = dict
                    # x2many = list
                    if isinstance(v, list):
                        sub_row = []
                        for er in [ExpandedRow(sub_fields, w) for w in v]:
                            for sr in er:
                                sub_row.append(sr)
                    elif isinstance(v, AttrDict):
                        if v:
                            sub_row = [[v[f] for f in sub_fields]]
                        else:
                            sub_row = [[None] * len(sub_fields)]
                    else:
                        raise TypeError('invalid type: %r [%r]' % (type(v), v))
                else:
                    sub_row = [[None] * len(sub_fields)]
                row.append(sub_row)
        for i in counter():
            line = []
            remaining = False
            for item in row:
                if not isinstance(item, list):
                    if i:
                        # not first line
                        line.append(None)
                    else:
                        # first line
                        line.append(item)
                else:
                    if len(item) > i:
                        line.extend([item[i]])
                        remaining = True
                    else:
                        if item:
                            line.extend([None] * len(item))
                        else:
                            line.extend([None])
            rows.append(line)
            if not remaining:
                break
        if rows:
            last_row = rows[-1]
            if all([c is None for c in last_row]):
                rows.pop()
        self.rows = rows

    def __iter__(self):
        return iter(self.rows)

    def __len__(self):
        return len(self.rows)

    def __repr__(self):
        return repr(self.rows)


# run it
Main()
