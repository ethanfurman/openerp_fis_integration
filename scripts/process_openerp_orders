#!/usr/local/bin/python3
"""
transform the order output from OpenERP's Customer Portal Online Ordering
to a transfer file that FIS can import
"""
from __future__ import print_function

from scription import *
from antipathy import Path
from traceback import format_exception_only
from datetime import timedelta
from dbf import Date, DateTime, Period
import sys

# all order numbers must be in the 10000-19999 range or we have collisions
# with other FIS-feeding processes

BASE_SEQ = 10000
CUT_OFF = timedelta(seconds=600)

EOE_PATH = Path("/mnt/11-111/home/eoe/")
BASE_PATH = Path("/home/openerp/sandbox/openerp/var/fis_integration/orders")
ORDERS = BASE_PATH
ARCHIVE = BASE_PATH / "archive"
RECIPIENT_FILE = BASE_PATH / 'notify'
ERROR_FILE = BASE_PATH / 'notified'

NOW = DateTime.now()
TOMORROW = NOW.replace(delta_day=+1).strftime("%m%d%y")

# API

@Command(
        )
def process_openerp_orders():
    """
    transform OpenERP Customer Portal orders into FIS input
    """
    # default ship date
    # order files to process
    new_order_list = get_files_to_process(ORDERS)
    errors = []
    for order_file in new_order_list:
        print('processing %s' % (order_file, ))
        try:
            order_no = int(order_file.stem)
            seq = BASE_SEQ + order_no % 10000
            with open(order_file) as in_file:
                order_lines = in_file.read().strip().split('\n')
            # order_lines looks like 
            #   ['LUCKY-407B-900002',
            #    'RSD-041920',
            #    'PON-8172943',
            #    '002080 - 1 - 25 lb',
            #    '001045 - 1 - 25 lb', '']
            # customer login may have dashes, but transmitter numbers never will
            # so split on the right-most dash
            cust, trans = order_lines[0].strip().rsplit("-", 1)
            [rsd] = [xx for xx in order_lines if xx.startswith('RSD')] or ['dflt-%s' % TOMORROW]
            [pon] = [xx for xx in order_lines if xx.startswith('PON')] or ['dflt-0000000037']
            PON = pon.split('-')[-1]
            RSD = rsd.split('-')[-1]
            hdr = "C%s+P%s+D%s+" % (trans, PON, RSD)
            rec = hdr
            for line in order_lines[1:]:
                if line.startswith(('RSD','PON')):
                    continue
                item, qty = [val.strip() for val in line.strip().split('-')][:2]
                if qty != "0":
                    rec += "I%s+Q%s+" % (item, qty)
            extfile = EOE_PATH / "%s.ext" % seq
            with open(extfile, 'w') as out_file:
                out_file.write(rec)
            order_file.move(ARCHIVE)
        except Exception:
            exc_type, exc, _ = sys.exc_info()
            error_lines = format_exception_only(exc_type, exc)
            error_lines[0] = ("[%s]  " % order_file.filename) + error_lines[0]
            error(''.join(error_lines))
            errors.extend(format_exception_only(exc_type, exc))
            continue
    return notify(errors)


@Command(
        date=Spec('date to examine', OPTION, type=Date),
        )
def daily_digest(date):
    """
    print list of orders sent to FIS, and their detail
    """
    target = date or Date.today()
    print('target date: %r' % (target, ))
    target_period = Period(target.year, target.month, target.day)
    print('       period: %r' % (target_period, ))
    archive_order_list = get_files_to_process(ARCHIVE)
    process_order_list = get_files_to_process(ORDERS)
    if process_order_list:
        echo('FILES NOT PROCESSED')
        echo('\n'.join([o.filename for o in process_order_list]))
        echo('===================')
    print('checking %d order files' % len(archive_order_list, ))
    orders = {}
    # TODO: keep orders sorted when printing
    for order in archive_order_list:
        order_date = Date.fromtimestamp(order.stat().st_mtime)
        if order_date in target_period:
            with open(order) as in_file:
                orders[order.filename] = in_file.readlines()
    echo('found %d records for %s' % (len(orders), target))
    if orders:
        echo()
        echo('\n'.join(a.filename for a in archive_order_list))
        echo()
        for order in archive_order_list:
            lines = orders[order.filename]
            echo('=== %s ===' % (order.filename, ))
            echo('   ', '    '.join(lines))
            echo()

@Command(
        recipients=Spec('addresses to send mail to', MULTIREQ),
        subject=Spec('subject line', OPTION, force_default='process_openerp_orders mail test'),
        message=Spec('message body', OPTION, force_default='hope you got this!'),
        )
def test_mail(recipients, subject, message):
    sent, failed = send_mail(recipients, subject, message)
    if failed:
        error('failed to send to: %s' % ', '.join(failed))
        return Exit.UnknownError
    else:
        return Exit.Success

# helpers

def get_files_to_process(path):
    """
    returns files that match \d*.txt
    """
    # path must be a Path
    order_list = [
            fn
            for fn in path.glob('*')
            if fn.stem.isdigit()
            ]
    order_list.sort(key=lambda fn: int(fn.stem)) 
    return order_list

def filter_recipients(addresses):
    """
    return recipients that have not been contacted for current situation
    """
    with open(ERROR_FILE) as fh:
        lines = [line for line in fh.read().strip().split('\n') if line]
    if lines and lines[0].startswith('time'):
        lines.pop(0)
    contacted = []
    for line in lines:
        date, time, address = line.split()
        contacted.append(address)
    return [a for a in addresses if a not in contacted]


def get_recipients(source):
    """
    read address file and return eligible recipients based on allowed times
    """
    if source == ERROR_FILE:
        with open(ERROR_FILE) as fh:
            addresses = [line.split()[2] for line in fh.read().strip().split('\n')]
    elif source == RECIPIENT_FILE:
        with open(RECIPIENT_FILE) as fh:
            lines = [line for line in fh.read().strip().split('\n') if line]
        if lines and lines[0].startswith('email'):
            lines.pop(0)
        addresses = []
        for line in lines:
            pieces = line.split()
            if len(pieces) == 1:
                # email only
                email, = pieces
                phone = None
                availability = WeeklyAvailability.none()
            elif len(pieces) == 2:
                # email and phone (means always available)
                email, phone = pieces
                availability = WeeklyAvailability.always()
            else:
                email, phone = pieces[:2]
                availability = WeeklyAvailability(*pieces[2:])
            #
            addresses.append(email)
            if phone and NOW in availability:
                addresses.append(phone)
    else:
        raise ValueError('unknown file: %r' % (source, ))
    return addresses


def notify(errors):
    """
    send errors to valid recipients or cancellation to all notified thus far
    """
    if not errors:
        if not ERROR_FILE.exists():
            return Exit.Success
        last_accessed = ERROR_FILE.stat().st_atime
        if NOW - DateTime.fromtimestamp(last_accessed) < CUT_OFF:
            # too soon to notify, maybe next time
            return Exit.Success
        # get names from file and notify each one that problem is resolved
        addresses = get_recipients(ERROR_FILE)
        subject = "%s: all good" % script_fullname
        message = "problem has been resolved"
    else:
        # errors happened; check if ERROR_FILE needs (re)creating
        create_error_file = False
        if not ERROR_FILE.exists():
            create_error_file = True
        else:
            last_accessed = ERROR_FILE.stat().st_atime
            if NOW - DateTime.fromtimestamp(last_accessed) > CUT_OFF:
                # file should have been deleted; create fresh now
                create_error_file = True
        if create_error_file:
            with open(ERROR_FILE, 'w') as fh:
                fh.write("time contacted      address\n")
        ERROR_FILE.touch((NOW.timestamp(), None))
        addresses = filter_recipients(get_recipients(RECIPIENT_FILE))
        subject = "%s: errors encountered" % script_fullname
        message = ''.join(errors)
    sent_addresses, failed_to_send = send_mail(addresses, subject, message)
    if failed_to_send:
        error('\n\nUnable to contact:\n  %s' % ('\n  '.join(failed_to_send)))
    if errors:
        update_recipients(sent_addresses)
    else:
        ERROR_FILE.unlink()
    if errors or failed_to_send:
        return Exit.UnknownError
    else:
        return Exit.Success

def send_mail(recipients, subject, message):
    """
    use system mail command to send MESSAGE to RECIPIENTS
    """
    sent_addresses = []
    failed_to_send = []
    for address in recipients:
        # may be skipped if all eligible addresses have already been notified
        try:
            job = Job(
                    '/usr/bin/mail -s "%s" %s' % (subject, address),
                    pty=True,
                    )
            job.communicate(input=message, timeout=30)
            sent_addresses.append(address)
        except Exception as exc:
            error(exc)
            failed_to_send.append(address)
            continue
    return sent_addresses, failed_to_send

def update_recipients(addresses):
    """
    update notification file with who was contacted at what time
    """
    with open(ERROR_FILE, 'a') as fh:
        for address in addresses:
            fh.write('%-20s %s\n' % (NOW.strftime('%Y-%m-%d %H:%M'), address))


class WeeklyAvailability(object):
    """
    maintain periods of availability on a weekly basis
    """
    def __init__(self, *times):
        # times -> ['Mo:800-1700', 'Tu,Th:1100-1330,1730-2000', 'We:-', 'Fr', 'Sa-Su:1400-2100']
        self.text = str(times)
        matrix = {
                'mo': [0] * 1440,
                'tu': [0] * 1440,
                'we': [0] * 1440,
                'th': [0] * 1440,
                'fr': [0] * 1440,
                'sa': [0] * 1440,
                'su': [0] * 1440,
                }
        for period in times:
            period = period.lower()
            if ':' not in period:
                period += ':'
            days, minutes = period.split(':')
            if minutes == '-':
                minutes = None
            elif minutes == '':
                minutes = ['0-2359']
            else:
                minutes = minutes.split(',')
            for day in which_days(days):
                day = matrix[day]
                if minutes is None:
                    continue
                for sub_period in minutes:
                    start, end = sub_period.split('-')
                    start = int(start[:-2] or 0) * 60 + int(start[-2:])
                    end = int(end[:-2] or 0) * 60 + int(end[-2:])
                    for minute in range(start, end+1):
                        day[minute] = 1
        self.days = [matrix['su'], matrix['mo'], matrix['tu'], matrix['we'], matrix['th'], matrix['fr'], matrix['sa'], matrix['su']]

    def __repr__(self):
        return "WeeklyAvailability(%r)" % self.text

    def __contains__(self, dt):
        """
        checks if dt.day, hour, minute is 1
        """
        day = dt.isoweekday()
        moment = dt.hour * 60 + dt.minute
        return self.days[day][moment] == 1

    @classmethod
    def always(cls):
        """
        create a WeeklyAvailability with all availability
        """
        return cls('su-sa')

    @classmethod
    def none(cls):
        """
        create a WeeklyAvailability with no availability
        """
        return cls('su-sa:-')


def which_days(text):
    week = ['su','mo','tu','we','th','fr','sa']
    text = text.lower()
    groups = text.split(',')
    days = []
    for group in groups:
        if '-' not in group:
            days.append(group)
        else:
            start, stop = group.split('-')
            if start not in week:
                raise ValueError('invalid start day: %r' % (start, ))
            if stop not in week:
                raise ValueError('invalid stop day: %r' % (stop, ))
            start = week.index(start)
            while True:
                days.append(week[start])
                if week[start] == stop:
                    break
                start = (start + 1) % 7
    return days



Main()

# file formats

# recipient file format, space-delimited
# email, phone, text-message okay times ("-" means no time)
"""
email                 phone@carrier             availability
ethan@stoneleaf.us    9715061961@vtext.com      Mo-Tu:800-1700   We,Fr:1300-1700   Th:1700-2100   Sa:0000-0300,1200-1500 Su:-
emile@gmail.com       6503433458@txt.att.net
tony@togo.net
"""

# notification file format
"""
time contacted      address
2020-05-20 03:47    ethan@stoneleaf.us
"""

# text message carrier email addresses
"""
Alltel:          [10-digit number] at message.alltel.com
AT&T:            [10-digit number] at txt.att.net
Boost Mobile:    [10-digit number] at myboostmobile.com
Cricket Wireless [10-digit number] at mms.cricketwireless.net
Sprint:          [10-digit number] at messaging.sprintpcs.com
T-Mobile:        [10-digit number] at tmomail.net
U.S. Cellular:   [10-digit number] at email.uscc.net
Verizon:         [10-digit number] at vtext.com
Virgin Mobile:   [10-digit number] at vmobl.com

Could be handy if we need to have a script text-message us.

> Thanks! Any follow up on determining which service to email by
> telephone number? Particularly now that numbers are carrier
> independent?

There are a few services, none free:

data24-7.com: $12/mo + $0.006 per lookup -- API for immediate look-ups

realphonevalidation.com: request a quote -- batch processing of files

textmagic.com: $4/mo + $0.04 per lookup -- API for immediate look-ups
the $4 gives us a virtual phone number to send/receive messages with

Looks like textmagic is the best option so far.  If we go with them the fellow that helped answer my questions is
Peter (in case they care).
"""
