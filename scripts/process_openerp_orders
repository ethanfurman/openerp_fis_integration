#!/usr/local/bin/python2
"""
transform the order output from OpenERP's Customer Portal Online Ordering
to a transfer file that FIS can import
"""
from __future__ import print_function

from scription import *
from antipathy import Path
from traceback import format_exc
from datetime import timedelta
from dbf import Date, DateTime, Period

# all order numbers must be in the 10000-19999 range or we have collisions
# with other FIS-feeding processes

BASE_SEQ = 10000
CUT_OFF = timedelta(seconds=300)

BASE_PATH = Path("/home/openerp/sandbox/openerp/var/fis_integration/orders")
ORDERS = BASE_PATH
ARCHIVE = BASE_PATH / "archive"
RECIPIENT_FILE = BASE_PATH / 'notify'
ERROR_FILE = BASE_PATH / 'notified'

dt_NOW = DateTime.now()
i_NOW = dt_NOW.hour * 100 + dt_NOW.minute

# API

@Command(
        )
def process_openerp_orders():
    """
    transform OpenERP Customer Portal orders into FIS input
    """
    # default ship date
    tomorrow = Date.today().replace(delta_day=+1).strftime("%m%d%y")
    # order files to process
    new_order_list = get_files_to_process(ORDERS)
    errors = []
    for order_file in new_order_list:
        print('processing %s' % (order_file, ))
        try:
            order_no = int(order_file.stem)
            seq = BASE_SEQ + order_no % 10000
            with open(order_file) as in_file:
                order_lines = in_file.readlines()
            # customer login may have dashes, but transmitter numbers never will
            # so split on the right-most dash
            cust, trans = order_lines[0].strip().rsplit("-", 1)
            #order_lines looks like ['LUCKY-407B-900002', 'RSD-041920', 'PON-8172943', '002080 - 1 - 25 lb', '001045 - 1 - 25 lb', '']
            rsd = [xx for xx in order_lines if xx.startswith('RSD')]
            #rsd will be ['RSD-041920'] if specified
            pon = [xx for xx in order_lines if xx.startswith('PON')]
            #pon will be ['PON-8172943'] if specified
            if pon:
                PON = "-".split(pon[0])[-1]
            else:
                PON = "0000000037"
            if rsd:
                RSD = "-".split(rsd[0])[-1]
            else:
                RSD = tomorrow
            hdr = "C%s+P%s+D%s+" % (trans, PON, RSD)
            rec = hdr
            for line in order_lines[1:]:
                item, qty = [val.strip() for val in line.strip().split('-')][:2]
                if qty != "0":
                    rec += "I%s+Q%s+" % (item, qty)
            extfile = "/mnt/11-111/home/eoe/%s.ext" % seq
            with open(extfile, 'w') as out_file:
                out_file.write(rec)
            order_file.move("/home/openerp/sandbox/openerp/var/fis_integration/orders/archive/")
        except Exception:
            exc_type, exc, _ = sys.exc_info()
            error_lines = format_exception_only(exc_type, exc)
            error(''.join(error_lines))
            errors.extend(format_exception_only(exc_type, exc))
            continue
    if errors:
        notify(errors)
        return Exit.Unknown


@Command(
        date=Spec('date to examine', OPTION, type=Date),
        )
def daily_digest(date):
    """
    print list of orders sent to FIS, and their detail
    """
    target = date or Date.today()
    print('target date: %r' % (target, ))
    target_period = Period(target.year, target.month, target.day)
    print('       period: %r' % (target_period, ))
    archive_order_list = get_files_to_process(ARCHIVE)
    process_order_list = get_files_to_process(ORDERS)
    if process_order_list:
        echo('FILES NOT PROCESSED')
        echo('\n'.join([o.filename for o in process_order_list]))
        echo('===================')
    print('checking %d order files' % len(archive_order_list, ))
    orders = {}
    # TODO: keep orders sorted when printing
    for order in archive_order_list:
        order_date = Date.fromtimestamp(order.stat().st_mtime)
        if order_date in target_period:
            with open(order) as in_file:
                orders[order.filename] = in_file.readlines()
    echo('found %d records for %s' % (len(orders), target))
    if orders:
        echo()
        echo('\n'.join(orders.keys()))
        echo()
        for order, lines in orders.items():
            echo('=== %s ===' % (order, ))
            echo('   ', '    '.join(lines))
            echo()


# helprs

def get_files_to_process(path):
    """
    returns files that match \d*.txt
    """
    # path must be a Path
    order_list = [
            fn
            for fn in path.glob('*')
            if fn.stem.isdigit()
            ]
    order_list.sort(key=lambda fn: int(fn.stem)) 
    return order_list

def filter_recipients(addresses):
    """
    return recipients that have not been contacted for current situation
    """
    with open(ERROR_FILE) as fh:
        lines = fh.readlines()
    if lines[0].startswith('time'):
        lines.pop(0)
    contacted = []
    for line in lines:
        date, time, address = line
        contacted.append(address)
    return [a for a in addresses if a not in contacted]


def get_recipients():
    """
    read address file and return eligible recipients based on allowed times
    """
    with open(RECIPIENT_FILE) as fh:
        lines = fh.readlines()
    if lines[0].startswith('email'):
        lines.pop(0)
    addresses = []
    for line in lines:
        pieces = line.split()
        if len(pieces) == 3:
            email, start, stop = pieces
            phone = None
        elif len(pieces) == 4:
            email, phone, start, stop = pieces
        else:
            abort("bad line in %s: %r" % (RECIPIENT_FILE.filename, line))
        start, stop = int(start), int(stop)
        addresses.append(email, 0, 2359)
        if phone and start <= i_NOW <= stop:
            addresses.append(phone, start, stop)
    addresses = filter_recipients(addresses)
    return addresses


def notify(errors):
    """
    send errors to email recipients, notifications to text message recipients
    """
    last_accessed = ERROR_FILE.stat().st_atime
    if dt_NOW - DateTime.fromtimestamp() > CUTOFF:
        with open(ERROR_FILE, 'w') as fh:
            fh.write("time contacted      address\n")
    addresses = filter_recipients(get_recipients())
    sent_addresses = []
    message = ''.join(errors)
    failed_to_send = []
    for address in addresses:
        try:
            job = Job(
                    '/usr/bin/mail -s "errors encountered in process_openerp_orders" %s'
                    % address,
                    pty=True,
                    )
            job.communicate(input=message, timeout=60)
            sent_addresses.append(address)
        except Exception as exc:
            error(exc)
            failed_to_send.append(address)
            continue
    if failed_to_send:
        error('\n\nUnable to contact:\n  %s' % ('\n  '.join(failed_to_send)))
    update_recipients(sent_addresses)

def send_mail(recipients, subject, message):
    """
    use system mail command to send MESSAGE to RECIPIENTS
    """
    command = '/usr/bin/mail -s "%s" %s' % (subject, ','.join(recipients))
    job = Job(command, pty=True)
    try:
        job.communicate(input=message)
    except Exception:
        echo(job.stdout)
        error(job.stderr)
        raise

def update_recipients(addresses):
    """
    update notification file with who was contacted at what time
    """
    with open(ERROR_FILE, 'a') as fh:
        for address in addresses:
            fh.write('%-20s %s\n' % (dt_NOW.strftime('%Y-%M-%D %h:%m'), address))


Main()


# recipient file format, space-delimited
# email, start time, and end time fields are required
# example only
"""
email                 phone             start time      end time
ethan@stoneleaf.us    971.506.1961      0800            1700
emile@gmail.com       650.343.3458      0500            2000
"""

# notification file format
"""
time contacted      address
2020-05-20 03:47    ethan@stoneleaf.us
"""
