#!/usr/local/bin/python2
from __future__ import print_function

from scription import *
from antipathy import Path
from traceback import format_exc
from dbf import Date, Period

# all order numbers must be in the 10000-19999 range or we have collisions
# with other FIS-feeding processes

BASE_SEQ = 10000
ORDERS = Path("/home/openerp/sandbox/openerp/var/fis_integration/orders/")
ARCHIVE = Path("/home/openerp/sandbox/openerp/var/fis_integration/orders/archive/")

@Command()
def process_openerp_orders():
    """
    transform OpenERP Customer Portal orders into FIS input
    """
    # default ship date
    tomorrow = Date.today().replace(delta_day=+1).strftime("%m%d%y")
    # order files to process
    new_order_list = get_files_to_process(ORDERS)
    errors_encountered = False
    for order_file in new_order_list:
        print('processing %s' % (order_file, ))
        try:
            order_no = int(order_file.stem)
            seq = BASE_SEQ + order_no % 10000
            with open(order_file) as in_file:
                order_lines = in_file.readlines()
            # customer login may have dashes, but transmitter numbers never will
            # so split on the right-most dash
            cust, trans = order_lines[0].strip().rsplit("-", 1)
            #order_lines looks like ['LUCKY-407B-900002', 'RSD-041920', 'PON-8172943', '002080 - 1 - 25 lb', '001045 - 1 - 25 lb', '']
            rsd = [xx for xx in order_lines if xx.startswith('RSD')]
            #rsd will be ['RSD-041920'] if specified
            pon = [xx for xx in order_lines if xx.startswith('PON')]
            #pon will be ['PON-8172943'] if specified
            if pon:
                PON = "-".split(pon[0])[-1]
            else:
                PON = "0000000037"
            if rsd:
                RSD = "-".split(rsd[0])[-1]
            else:
                RSD = tomorrow
            hdr = "C%s+P%s+D%s+" % (trans, PON, RSD)
            rec = hdr
            for line in order_lines[1:]:
                item, qty = [val.strip() for val in line.strip().split('-')][:2]
                if qty != "0":
                    rec += "I%s+Q%s+" % (item, qty)
            extfile = "/mnt/11-111/home/eoe/%s.ext" % seq
            with open(extfile, 'w') as out_file:
                out_file.write(rec)
            order_file.move("/home/openerp/sandbox/openerp/var/fis_integration/orders/archive/")
        except Exception:
            errors_encountered = True
            error('%s: error occured:\n%s' % (order_no, format_exc()))
            continue
    if errors_encountered:
        return Exit.Unknown


@Command(
        date=Spec('date to examine', OPTION, type=Date),
        )
def daily_digest(date):
    """
    print list of orders sent to FIS, and their detail
    """
    target = date or Date.today()
    print('target date: %r' % (target, ))
    target_period = Period(target.year, target.month, target.day)
    print('       period: %r' % (target_period, ))
    archive_order_list = get_files_to_process(ARCHIVE)
    process_order_list = get_files_to_process(ORDERS)
    if process_order_list:
        echo('FILES NOT PROCESSED')
        echo('\n'.join([o.filename for o in process_order_list]))
        echo('===================')
    print('checking %d order files' % len(archive_order_list, ))
    orders = {}
    for order in archive_order_list:
        order_date = Date.fromtimestamp(order.stat().st_mtime)
        if order_date in target_period:
            with open(order) as in_file:
                orders[order.filename] = in_file.readlines()
    echo('found %d records for %s' % (len(orders), target))
    if orders:
        echo()
        echo('\n'.join(orders.keys()))
        echo()
        for order, lines in orders.items():
            echo('=== %s ===' % (order, ))
            echo('   ', '    '.join(lines))
            echo()


def get_files_to_process(path):
    """
    returns files match \d*.txt
    """
    # path must be a Path
    order_list = [
            fn
            for fn in path.glob('*')
            if fn.stem.isdigit()
            ]
    order_list.sort(key=lambda fn: int(fn.stem)) 
    return order_list


Run()

