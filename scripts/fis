#!/usr/local/sbin/suid-python --virtualenv
from __future__ import print_function, unicode_literals

from scription import *
from collections import defaultdict
from itertools import cycle
from openerplib import get_connection, get_records
from updates.tools import FISenum, ProductLabelDescription
from VSS.BBxXlate import fisData as fd
from VSS.BBxXlate.bbxfile import TableError
from VSS.address import cszk, normalize_address, Rise, Sift, AddrCase, NameCase, BsnsCase, name_chars
from VSS.utils import fix_phone
# from VSS.utils import fix_phone, fix_date, var
# from dbf import Date
from antipathy import Path
import dbf
import os
import random
import re
import sys
import textwrap
import time

virtual_env = os.environ['VIRTUAL_ENV']
config = OrmFile(Path('%s/config/fnx.ini' % virtual_env), types={'_path':Path})
env = config.env
PRODUCT_FORECAST = '/FIS/data/product_forecast.txt'

# SOURCE = Path('%s/var/fis/production/' % virtual_env)
# ARCHIVE = Path('%s/var/openerp/archive/production/' % virtual_env)
# ERRORS = Path('%s/var/openerp/archive/production/error' % virtual_env)

# API
@Command(
        filenum=Spec('file abbreviation or number to operate on', ),
        keymatch=Spec('key template to select individual records', default=None),
        key=Spec('key of desired record', MULTIREQ, default=()),
        full=Spec('show all fields', FLAG),
        color=Spec('use color output', FLAG),
        summary=Spec('show summary only', FLAG,),
        )
def diff(filenum, keymatch, key, full, color, summary):
    "show specified, or all, records diffed with their older version"
    # easier color names
    white, red, green, cyan = Color.FG_White, Color.FG_Red, Color.FG_Green, Color.FG_Cyan
    bold, all_reset = Color.Bright, Color.AllReset
    #
    if filenum.isdigit():
        filenum = int(filenum)
    fis_table = fd.fisData(filenum, keymatch=keymatch)
    fis_table_old = fd.fisData(filenum, keymatch=keymatch, data_path=config.network.fis_data_local_old_path)
    print('using files: %s (%d) and %s (%d)' %(fis_table.filename, len(fis_table), fis_table_old.filename, len(fis_table_old)), verbose=2)
    new_records = []
    old_records = []
    if keymatch and key:
        # user specified record to diff
        print('keymatch and key specified', verbose=2)
        for k in key:
            new_records.append(fis_table.get(k))
            old_records.append(fis_table_old.get(k))
        data_width = 0
    elif keymatch or key:
        abort('must specify both KEYMATCH and KEY if either is given')
    else:
        print('looking for all changed records', verbose=2)
        # lock in data widths
        data_width = max(fis_table.field_widths)
        # find all changed records
        new_records = []
        old_records = []
        old_records_map = {}
        new_records_map = {}
        for rec in fis_table_old.values():
            old_records_map[rec.rec[0]] = rec
        for rec in fis_table.values():
            new_records_map[rec.rec[0]] = rec
        all_recs = set(new_records_map.keys() + old_records_map.keys())
        for key in all_recs:
            new_rec = new_records_map.get(key)
            old_rec = old_records_map.get(key)
            if new_rec != old_rec:
                new_records.append(new_records_map.get(key))
                old_records.append(old_records_map.get(key))
    added = deleted = changed = 0
    for old_rec, new_rec in zip(old_records, new_records):
        if new_rec is None and old_rec is None:
            echo('record %r does not exist' % (key, ))
        elif new_rec is None:
            deleted += 1
            if not summary:
                echo(old_rec)
                echo('record has been DELETED')
        elif old_rec is None:
            added += 1
            if not summary:
                echo(new_rec)
                echo('record has been ADDED')
        else:
            # only show key fields and changed fields, unless user specified --full
            key_field_pre = fis_table.datamap[0]
            changed_fields = []
            field_changed = False
            for field_meta in fis_table.fieldlist:
                index, desc, _, spec, _ = field_meta
                old_data = old_rec[spec]
                new_data = new_rec[spec]
                if spec.startswith(key_field_pre):
                    changed_fields.append((index.split('_')[1], spec, old_data, new_data, desc))
                    data_width = max(data_width, len(old_data), len(new_data))
                elif old_data != new_data or full:
                    field_changed = True
                    changed_fields.append((index.split('_')[1], spec, old_data, new_data, desc))
                    data_width = max(data_width, len(str(old_data)), len(str(new_data)))
            if field_changed:
                changed += 1
            if summary:
                continue
            data_width = 30
            lines = []
            def select_color(row):
                old, new = row[2:4]
                if old == new:
                    return white, white, white|bold, white|bold, white
                else:
                    return white, white, red, green, white
            string_template = ColorTemplate(
                    '%%3s | %%-12s | %%-%ds | %%-%ds | %%s' % (data_width, data_width),
                    default_color=all_reset+cyan,
                    select_colors=select_color,
                    )
            numeric_template = ColorTemplate(
                    '%%3s | %%-12s | %%%ds | %%%ds | %%s' % (data_width, data_width),
                    default_color=all_reset+cyan,
                    select_colors=select_color,
                    )
            for line in changed_fields:
                index, spec, old, new, desc = line
                if '$' in spec:
                    lines.append(string_template(index, spec, old, new, desc))
                else:
                    lines.append(numeric_template(index, spec, old, new, desc))
            echo('\n'.join(lines))
            if os.isatty(sys.stdout.fileno()):
                try:
                    raw_input('press <enter> to continue')
                except KeyboardInterrupt:
                    abort('\n<Ctrl-C>, aborting')
    echo('\nAdded:   %4d' % added)
    echo('Deleted: %4d' % deleted)
    echo('Changed: %4d' % changed)


@Command(
        database=('which database to check', ),
        fis_id=('FIS ID of customer to check', ),
        )
def is_active_customer(database, fis_id):
    oe = connect_oe(database)
    customers = get_records(
            oe, 'res.partner',
            domain=[('xml_id','=',fis_id),('module','=','CSMS'),'|',('active','=',True),('active','=',False)],
            fields=['id', 'name'],
            )
    if not customers:
        error('%r not in OpenERP as a customer' % (fis_id, ))
        return None
    elif len(customers) > 1:
        error('data integrity error: multiple matches for CSMS:%s' % (fis_id, ))
        for cust in customers:
            error('  ', cust.name)
        return None
    [customer] = customers
    active = ('is not', 'is')[fis_id in get_active_customers()]
    echo('[CSMS:%s] %s %s active' % (fis_id, customer.name, active))


@Command(
        start=Spec('where to start checking', OPTION),
        )
def integrity_check(start=1):
    "check tables for key/record mismatches"
    i = start - 1
    while 'checking more tables':
        if i > 400:
            break
        i += 1
        try:
            table = fd.fisData(i)
        except TableError:
            cls, exc, tb = sys.exc_info()
            error('%10s  [%3d]:  %s' % (exc.filename, i, exc.__class__.__name__))
        except KeyError:
            pass
        else:
            if table.corrupted:
                error('%10s  [%3d]: %7d records,  %4d corrupted' % (table.filename, i, len(table), table.corrupted))
            else:
                print('%10s  [%3d]: %7d records' % (table.filename, i, len(table)))


@Command(
        filenum=Spec('file abbreviation or number to operate on', default='all', type=unicode.upper),
        which=Spec('which field to display', default='all', type=unicode.upper),
        )
def field_check(filenum, which):
    """
    Checks numeric fields for bad values.
    """
    if filenum != 'all':
        if filenum.isdigit():
            filenum = int(filenum)
        files = [filenum]
    else:
        files = [k for k in fd.tables if isinstance(k, (int, long))]
    for filenum in files:
        print('file: %s' % (filenum,), end=' ', verbose=0)
        try:
            table = fd.fisData(filenum)
        except TableError, exc:
            print('<%s>' % exc.__doc__, verbose=0)
            continue
        print(table.datamap)
        if which != 'all':
            fields = [which]
        else:
            fields = [f for f in table.datamap if '$' not in f]
        print('(%d records, %d numeric fields)' % (len(table), len(fields)), end='  ', verbose=0)
        ints = floats = 0
        bad_values = defaultdict(lambda: defaultdict(int))
        for record in table.values():
            for field in fields:
                val = record[field]
                try:
                    int(val)
                    ints += 1
                except ValueError:
                    try:
                        float(val)
                        floats += 1
                    except ValueError:
                        bad_values[field][val] += 1
        print('-- int: %s  --  float: %s' % (ints, floats), verbose=0)
        if bad_values:
            for field, values in bad_values.items():
                print('     %s: %s' % (field, ', '.join(repr(v) for v in values.items())), verbose=0)
        table.release()


@Command(
    quick=('use local copy of product descriptions', FLAG),
    items=Spec('item number to look up', usage='ITEM'),
    )
def product_description(quick, *items):
    "retrieve and save the latest product descriptions"
    if not quick:
        # get the data
        print('getting data')
        with user_ids(0, 0):
            job = Execute(
                    'ssh %(host)s cat %(file)s' % {
                        'host': config.openerp.full_description_host,
                        'file': config.openerp.full_description_path,
                        },
                    pty=True,
                    )
        if job.returncode or job.stderr:
            abort(job.stderr, returncode=job.returncode)
        else:
            with open(config.network.fis_data_local_path/'product_descriptions.txt', 'w') as f:
                f.write(job.stdout)
            print('data saved')
    if items:
        # display the requested items
        print('reading data')
        with open(config.network.fis_data_local_path/'product_descriptions.txt') as f:
            lines = f.read().strip().split('\n')
        print('looking for item(s)')
        for line in lines:
            match = re.match('(.{40})  \((\d{6})\)  (.*)$', line)
            if match:
                fis_desc, item_code, full_desc = match.groups()
                if fis_desc in items:
                    echo('%s:  %s' % (item_code, full_desc))


@Command(
    items=Spec('item number to look up', usage='ITEM'),
    )
def product_forecast(*items):
    "retrieve and save the latest forecast data for ITEMS (default is all)"
    if not items:
        items = []
        nvty = fd.fisData('NVTY1', keymatch="%s101000    101**")   # 135
        for item_rec in ProgressView(
                iterable=nvty,
                view_type='bar',
                message='getting %d item numbers' % len(nvty)
            ):
            items.append(item_rec[F135.item_id])
        print('%d items retrieved' % len(items), verbose=2)
    else:
        items = list(items)
    items = ProgressView(
            iterable=(i+'\n' for i in items + ['exit']),
            view_type='bar',
            total=len(items),
            message='communicating with 11.11')
    start = time.time()
    with user_ids(0, 0):
        result = Execute(
                'ssh 192.168.11.111 /usr/local/bin/fis-query forecast',
                pty=True,
                input=items,
                password_timeout=0,
                )
    stop = time.time()
    minutes, seconds = divmod(stop-start, 60)
    hours, minutes = divmod(minutes, 60)
    output = [l for l in result.stdout.strip().split('\n') if len(l.split(':')) == 3]
    with open(PRODUCT_FORECAST, 'w') as f:
        f.write('\n'.join(output))
    print('\n'.join(output), verbose=2)
    print('elapsed time: %d:%d:%d' % (hours, minutes, seconds))


@Command(
        table=Spec('FIS table to query', type=int),
        code=Spec('code to search for', ),
        fields=Spec('specific fields to display [default: all]', MULTI, type=int),
        )
def query(table, code, fields):
    key = table_keys.get(table)
    fis_table = fd.fisData(table, keymatch=key)
    for line in format_record(fis_table[code], fields):
        echo(line)


@Command(
        filenum=Spec('file abbreviation or number to operate on', ),
        which=Spec('which record to display', choices=['random', 'last', 'key', 'offset'], default='random'),
        id=Spec('key or offset if WHICH is key or offset', default=None),
        )
def record(filenum, which, id):
    if filenum.isdigit():
        filenum = int(filenum)
    if id and which not in ('key', 'offset'):
        abort('ID not allowed for %r' % (which, ))
    table = fd.fisData(filenum)
    print('using file', table.filename)
    if which == 'last':
        record = table.values()[-1]
    elif which == 'random':
        record = random.choice(table.values())
    elif which == 'offset':
        record = table.values()[int(id)]
    elif which == 'key':
        record = table[which]
    else:
        abort('unknown selection for WHICH: %r' % (which, ))
    print(record.rec)
    for line in format_record(record):
        echo(line)


@Command(
        filenum=Spec('file abbreviation or number to operate on', ),
        subset=Spec('subset template to match many records to', ),
        code=Spec('code to match with template', force_default='', type=lambda s: s and tuple(s.split(',') or s)),
        fields=Spec('specific fields to display [default: all]', MULTI, type=int),
        dbf_name=Spec('dbf to create with data', OPTION),
        tabular=Spec('show output in tabular mode', FLAG,),
        )
def records(filenum, subset, code, fields, dbf_name, tabular):
    print('fields requested: %s' % (fields, ))
    if filenum.isdigit():
        filenum = int(filenum)
    fis_table = fd.fisData(filenum, subset=subset)
    print('using file', fis_table.filename)
    records = [v for k, v in fis_table.get_subset(code)]
    print('  found %d records' % (len(records), ))
    used_fields = []
    if records:
        # get field defs now, may be needed for dbf creation
        record = records[0]
        print('widths:', record._widths, verbose=2)
        # max_data_width = record._width
        max_spec_width = 0
        field_widths = []
        dbf_types = []
        dbf_names = []
        fis_fields = record.fieldlist
        for i, row in enumerate(fis_fields):
            j = i + 1
            print('checking for %d' % (j, ), end='... ', verbose=2)
            if not fields or j in fields:
                print('keeping', end='', verbose=2)
                name, spec = row[1:4:2]
                if not name.strip() or name.strip().lower() == '(open)':
                    continue
                max_spec_width = max(max_spec_width, len(spec.strip()))
                width = fis_table.field_widths[i]
                field_widths.append(width)
                field_name = convert_name(name, 10, dbf_names)
                dbf_names.append(field_name)
                name = convert_name(name, 50)
                if '$' in spec:
                    dbf_types.append('%s C(%d)' % (field_name, width))
                    used_fields.append((i, str))
                else:
                    dbf_types.append('%s N(17,5)' % field_name)
                    used_fields.append((i, float))
            print(verbose=2)
        if dbf_name:
            print('dbf fields:\n  ', '\n   '.join(dbf_types))
            table = dbf.Table(dbf_name, dbf_types).open(dbf.READ_WRITE)
    try:
        fields = [t[0] for t in used_fields]
        print('fields: %r' % (fields, ), border='flag', verbose=2)
        output = []
        for record in records:
            field_data = tuple(record[i] for i in fields)
            output.append(field_data)
            # for i, row in enumerate(fis_fields):
            lines = format_record(record, fields)
            if not dbf_name and not tabular and lines:
                echo('\n'.join(lines))
                try:
                    raw_input('...')
                except KeyboardInterrupt:
                    raise SystemExit(1)
            if dbf_name:
                data = []
                for i, item in enumerate(used_fields):
                    print(i, item, verbose=3)
                    cnv = item[1]
                    data.append(cnv(field_data[i]))
                print('field data:', data, verbose=3)
                table.append(tuple(data))
            if not dbf_name:
                echo()
        if tabular:
            echo(output, border='table')
    except Exception:
        import traceback
        traceback.print_exc()
    finally:
        if dbf_name:
            table.close()


@Command(
        filenum=Spec('file abbreviation or number to display', ),
        output=Spec('output type', choices=['dump','enum'], default='dump'),
        number=Spec('number to use for enum output (when using an abbr for FILENUM)', OPTION, type=int),
        )
def schema(filenum, output, number):
    if filenum.isdigit():
        filenum = int(filenum)
    table = fd.tables[filenum]
    if output == 'dump':
        max_width = 0
        for field in table['fields']:
            max_width = max(max_width, len(field[1]))
        max_width += 10
        echo(table['name'], table['desc'], table['filenum'])
        dotted = True
        field_num = 0
        last_field = None
        for i, field in enumerate(table['fields']):
            if not i % 3:
                dotted = not dotted
            name = '  ' + field[1]
            spec = field[3]
            current_field = spec.split('(')[0]
            if current_field != last_field or current_field.lower() == 'i':
                field_num += 1
                last_field = current_field
                display_field_num = '%2d' % field_num
            if dotted:
                name += '.' * (max_width - len(name))
            else:
                name += ' ' * (max_width - len(name))
            echo('%3d  %s' % (i+1, display_field_num), name, spec)
            display_field_num = '  '
    elif output == 'enum':
        echo('class F%d(FISenum):' % (number or table['filenum']))
        echo('    """')
        echo('    %s - %s' % (table['name'], table['desc'].strip('-')))
        echo('    """')
        echo('    #')
        echo('    _init_ = "value sequence"')
        echo('    _order_ = lambda m: m.sequence')
        echo('    #')
        lines = []
        for i, field in enumerate(table['fields']):
            name, spec = field[1:4:2]
            comment = name
            name = convert_name(name, 50)
            lines.append((name, spec, i, comment))
        #calculate widths
        max_name = max([len(n) for n, s, i, c in lines])
        max_spec = max([len(s) for n, s, i, c in lines]) + 2
        for name, spec, fld, comment in lines:
            if name:
                echo('    %-*s = %r, %*d     # %s' % (max_name, name, spec, max_spec-len(spec)+1, fld, comment))
            else:
                echo(' ' * (max_name + max_spec + 16), '# %s %s' % (comment, spec))
    else:
        abort('unknown output type: %s' % output)


@Command(
        )
def tables():
    "list FIS tables"
    keys = [k for k in fd.tables.keys() if isinstance(k, (int,long))]
    # template = '%4d: %s%s'
    numerical = True
    if not keys:
        # only alpha table names
        keys = [k for k in fd.tables.keys()]
        # template = '%s: %s'
        numerical = False
    keys.sort()
    for k in keys:
        t = fd.tables[k]
        if numerical:
            echo('%4d: %s%s' % (k, t['name'], t['desc']))
        else:
            echo('%-7s: %s%s' % (k, t['name'], t['desc']))


@Command(
        database=('which database to update', ),
        customers=('', FLAG, None),
        suppliers=('', FLAG, None),
        vendors=('', FLAG, None),
        carriers=('', FLAG, None),
        employees=('', FLAG, None),
        contacts=('include contacts', FLAG, None),
        products=('', FLAG, None),
        )
def update_openerp(database, customers, suppliers, vendors, carriers, employees, contacts, products):
    "update OpenERP from FIS data"
    if env.abbr != 'whc':
        abort('only available for %s' % env.name)
    oe = connect_oe(database)
    partner_key = '10%s'
    # if partner:
    #     partner_key %= partner
    state_recs = get_records(oe, 'res.country.state')
    state_recs = dict([(r.name, (r.id, r.code, r.country_id[0])) for r in state_recs])
    country_recs = get_records(oe, 'res.country')
    country_recs_name = dict([(r.name, r.id) for r in country_recs])
    if customers:
        update_customers(oe, contacts, state_recs, country_recs_name)
    if suppliers:
        supplier_codes = get_xml_id_map(oe, model='res.partner', module='posm')
        posm = fd.fisData('POSM', keymatch=partner_key)
        update_suppliers(posm, supplier_codes, contacts, state_recs, country_recs_name)
    if vendors:
        vendor_codes = get_xml_id_map(oe, model='res.partner', module='vnms')
        vnms = fd.fisData('VNMS', keymatch=partner_key)
        update_vendors(vnms, vendor_codes, contacts, state_recs, country_recs_name)
    if carriers:
        carrier_codes = get_xml_id_map(oe, model='res.partner', module='F27')
        carrier = fd.fisData(27, keymatch='SV10%s')
        update_carriers(carrier, carrier_codes, state_recs, country_recs_name)
    if employees:
        employee_codes = get_xml_id_map(oe, model='res.partner', module='F74')
        emp1 = fd.fisData('EMP1', keymatch='10%s')
        update_employees(emp1, employee_codes, state_recs, country_recs_name)
    if products:
        product_codes = get_xml_id_map(oe, model='product.product', module='nvty')
        default_product_codes = get_records(oe, model='product.product', domain=[('xml_id','=',False),('default_code','!=',False)])
        nvty = fd.fisData('NVTY', keymatch='10%s')
        update_products(nvty, product_codes, default_product_codes)

@Command(
        filenum=Spec('file abbreviation or number to operate on', ),
        subset=Spec('subset template to match many records to', ),
        code=Spec('code to match with template', force_default='', type=lambda s: s and tuple(s.split(',') or s)),
        fields=Spec('specific fields to display', MULTI, type=int),
        counts=Spec('only show counts', FLAG, None),
        )
def values(filenum, subset, code, fields, counts):
    if not fields:
        abort('no FIELDS specified')
    # adjust for zero-based numbering
    fields = [i-1 for i in fields]
    if filenum.isdigit():
        filenum = int(filenum)
    fis_table = fd.fisData(filenum, subset=subset)
    table_spec = fd.tables[filenum]
    table_fields = []
    for i, row in enumerate(table_spec['fields']):
        if i not in fields:
            continue
        name, spec = row[1:4:2]
        table_fields.append((name, spec, set()))
    for rec in [v for k, v in fis_table.get_subset(code)]:
        for name, spec, values in table_fields:
            values.add(rec[spec])
    for name, spec, values in table_fields:
        if counts:
            print('%-23s:  %7d' % (name, len(values)), verbose=0)
        else:
            print('%s:  ' % name, ', '.join([repr(v) for v in sorted(values)]), verbose=0)
    if counts:
        print('%-23s:  %7d' % ('Total Records', len(fis_table)), verbose=0)

@Command(
    items=Spec('item number to look up', usage='ITEM'),
    )
def web_data(*items):
    "retrieve and save the latest forecast data for ITEMS (default is all)"
    if not items:
        abort('ITEM not specified')
    nvty = fd.fisData('NVTY1', keymatch="%s101000    101**")   # 135
    for item in items:
        try:
            product_name = nvty[item][F135.desc]
        except KeyError:
            product_name = ''
        product = ProductLabelDescription(item)
        echo(
            '%s - %s' % (product.item_code, product_name),
            '---',
            '\n'.join([textwrap.fill(line,80) for line in product.ingredients_text.split('\n')]),
            '---',
            '\n'.join([textwrap.fill(line,80) for line in product.recipe_text.split('\n')]),
            sep='\n',
            border='box',
            )
        echo('\n')


# helpers

table_keys = {
    328: '10%s000010000',
    }


def update_customers(oe, contacts, state_recs, country_recs_name ):
    context = {'mail_create_nosubscribe': True}
    active_customers = get_active_customers()
    customer_codes = get_xml_id_map(oe, model='res.partner', module='csms')
    customer_ship_tos = get_xml_id_map(oe, model='res.partner', module='csmsbs')
    customers = fd.fisData('CSMS', keymatch='10%s ')
    ship_tos = fd.fisData('CSMSB', subset='10%s1')
    # alternate ship-tos exist in both CSMSB and CSMSS, but because
    # the final portion of the key is not specified in the schema, we can get them
    # all at once
    # process customers
    for cus_rec in customers:
        # rep = cus_rec[F33.salesrep]
        # rep = sales_people.get(rep, False)
        result = {'active': False}
        # result['user_id'] = rep
        result['is_company'] = True
        result['customer'] = True
        result['use_parent_address'] = False
        result['xml_id'] = key = cus_rec[F33.code]
        result['module'] = 'CSMS'
        # valid customer code? active account?
        result['fis_valid'] = fis_valid = True
        if key in active_customers or not active_customers:
            # if active customers is empty, mark them all as active
            result['active'] = True
        # notify_by = Specials.get_member(cus_rec[F33.catalog_category].upper(), None)
        # result['special_notifications'] = notify_by and notify_by.db or False
        result['name'] = customer_name = re.sub(
                config.fis_imports.name_from,
                config.fis_imports.name_to,
                BsnsCase(cus_rec[F33.name]),
                flags=re.I,
                )
        print('name:', result['name'])
        addr1, addr2, addr3 = Sift(cus_rec[F33.addr1], cus_rec[F33.addr2], cus_rec[F33.addr3])
        addr2, city, state, postal, country = cszk(addr2, addr3)
        addr3 = ''
        print('  ' + '\n  '.join([addr1, addr2, addr3, str([city, state, repr(postal)]), country]), verbose=2)
        if city and not (addr2 or state or postal or country):
            addr2, city = city, addr2
        addr1 = normalize_address(addr1)
        addr2 = normalize_address(addr2)
        addr1, addr2 = AddrCase(Rise(addr1, addr2))
        city = NameCase(city)
        state, country = NameCase(state), NameCase(country)
        result['street'] = addr1
        result['street2'] = addr2
        result['city'] = city
        result['zip'] = postal.code
        result['country_id'] = False
        result['state_id'] = False
        if state:
            result['state_id'] = state_recs[state][0]
            result['country_id'] = state_recs[state][2]
        elif country:
            country_id = country_recs_name.get(country, None)
            if country_id is None:
                # _logger.critical("Customer %s has invalid country <%r>" % (key, country))
                continue
            else:
                result['country_id'] = country_id
        result['phone'] = fix_phone(cus_rec[F33.tele])
        if not result['name']:
            # _logger.critical("Missing name for customer %s -- skipping" % (key, ))
            continue
        if key in customer_codes:
            id = customer_codes[key]
            # leave fis_valid alone
            del result['fis_valid']
            print('updating with:', result, verbose=2)
            res_partner.write(id, result, context=context)
        else:
            id = res_partner.create(result, context=context)
            print('creating with:', result, verbose=2)
            customer_codes[key] = id
        cus_id = id
        default_ship_to = result.copy()
        # process contacts
        if contacts and cus_rec[F33.contact]:
            contact = cus_rec[F33.contact]
            result = {
                    'active': result['active'],
                    'fis_valid': fis_valid,
                    # 'special_notifications': result['special_notifications'],
                    }
            result['name'] = re.sub(
                    config.fis_imports.name_from,
                    config.fis_imports.name_to,
                    NameCase(contact),
                    flags=re.I,
                    )
            result['is_company'] = False
            result['customer'] = True
            result['parent_id'] = cus_id
            result['use_parent_address'] = True
            result['xml_id'] = contact_key = 'cntct_' + key
            result['module'] = 'CSMS'
            if contact_key in customer_codes:
                print('updating contact with:', result, verbose=2)
                id = customer_codes[contact_key]
                res_partner.write(id, result, context=context)
            else:
                print('creating contact with:', result, verbose=2)
                id = res_partner.create(result, context=context)
                customer_codes[contact_key] = id
        # process alternate ship-tos
        alternates = ship_tos.get_subset(key) # or ((None, None), )
        for _, ship_to in sorted(alternates):
            result = {
                    'active': result['active'],
                    'fis_valid': fis_valid,
                    }
            result['parent_id'] = False
            result['ship_to_parent_id'] = cus_id
            result['is_company'] = False
            result['customer'] = False
            result['use_parent_address'] = False
            result['module'] = 'CSMSBS'
            if ship_to is None:
                result.update(default_ship_to)
                result['xml_id'] = ship_to_key = 'ship_' + key + '100'
                result['notes'] = 'main address from customer record'
                print('  ship-to:', ship_to_key)
            else:
                result['xml_id'] = ship_to_key = 'ship_' + ship_to[F140.code] + (ship_to[F140.ship_to_sequence].strip() or '00')
                print('  ship-to:', ship_to_key)
                result['notes'] = ship_to[F140.comments]
                result['name'] = re.sub(
                        config.fis_imports.name_from,
                        config.fis_imports.name_to,
                        BsnsCase(ship_to[F140.name]),
                        flags=re.I,
                        ) or customer_name
                addr1, addr2, addr3 = Sift(ship_to[F140.addr1], ship_to[F140.addr2], ship_to[F140.addr3])
                addr2, city, state, postal, country = cszk(addr2, addr3)
                addr3 = ''
                print('    ' + '\n    '.join([addr1, addr2, addr3, str([city, state, repr(postal)]), country]), verbose=2)
                if city and not (addr2 or state or postal or country):
                    addr2, city = city, addr2
                addr1 = normalize_address(addr1)
                addr2 = normalize_address(addr2)
                addr1, addr2 = AddrCase(Rise(addr1, addr2))
                city = NameCase(city)
                state, country = NameCase(state), NameCase(country)
                result['street'] = addr1
                result['street2'] = addr2
                result['city'] = city
                result['zip'] = postal.code
                result['country_id'] = False
                result['state_id'] = False
                if state:
                    result['state_id'] = state_recs[state][0]
                    result['country_id'] = state_recs[state][2]
                elif country:
                    country_id = country_recs_name.get(country, None)
                    if country_id is None:
                        # _logger.critical("Customer %s has invalid country <%r>" % (key, country))
                        continue
                    else:
                        result['country_id'] = country_id
                result['phone'] = fix_phone(ship_to[F140.tele])
            if ship_to_key in customer_ship_tos:
                # do not overwrite a possibly user-updated name
                del result['name']
                print('updating ship-to with:', result, verbose=2)
                id = customer_ship_tos[ship_to_key]
                res_partner.write(id, result, context=context)
            else:
                print('creating ship-to with:', result, verbose=2)
                id = res_partner.create(result, context=context)
                customer_ship_tos[ship_to_key] = id


def update_suppliers(table, customer_codes, contacts, state_recs, country_recs_name ):
    context = {'mail_create_nosubscribe': True}
    print('processing %d POSM records' % len(table))
    for sup_rec in table:
        result = {'active': False}
        result['is_company'] = True
        result['supplier'] = True
        result['customer'] = False
        result['use_parent_address'] = False
        result['xml_id'] = key = sup_rec[F163.code]
        result['module'] = 'POSM'
        # valid customer code? active account?
        result['fis_valid'] = True
        result['active'] = True
        # notify_by = Specials.get_member(cus_rec[F33.catalog_category].upper(), None)
        # result['special_notifications'] = notify_by and notify_by.db or False
        result['name'] = re.sub(
                config.fis_imports.name_from,
                config.fis_imports.name_to,
                BsnsCase(sup_rec[F163.name]),
                flags=re.I,
                )
        print('name:', result['name'])
        addr1, addr2, addr3 = Sift(sup_rec[F163.addr1], sup_rec[F163.addr2], sup_rec[F163.addr3])
        addr2, city, state, postal, country = cszk(addr2, addr3)
        addr3 = ''
        print('  ' + '\n  '.join([addr1, addr2, addr3, str([city, state, postal]), country]), verbose=2)
        if city and not (addr2 or state or postal or country):
            addr2, city = city, addr2
        addr1 = normalize_address(addr1)
        addr2 = normalize_address(addr2)
        addr1, addr2 = AddrCase(Rise(addr1, addr2))
        city = NameCase(city)
        state, country = NameCase(state), NameCase(country)
        result['street'] = addr1
        result['street2'] = addr2
        result['city'] = city
        result['zip'] = postal.code
        result['country_id'] = False
        result['state_id'] = False
        if state:
            result['state_id'] = state_recs[state][0]
            result['country_id'] = state_recs[state][2]
        elif country:
            country_id = country_recs_name.get(country, None)
            if country_id is None:
                # _logger.critical("Customer %s has invalid country <%r>" % (key, country))
                continue
            else:
                result['country_id'] = country_id
        result['phone'] = fix_phone(sup_rec[F163.tele])
        if not result['name']:
            # _logger.critical("Missing name for customer %s -- skipping" % (key, ))
            continue
        if key in customer_codes:
            id = customer_codes[key]
            # leave fis_valid alone
            del result['fis_valid']
            res_partner.write(id, result, context=context)
        else:
            id = res_partner.create(result, context=context)
            customer_codes[key] = id
        # if contacts and cus_rec[F33.contact]:
        #     cus_id = id
        #     contact = cus_rec[F33.contact]
        #     result = {
        #             'fis_valid': fis_valid,
        #             # 'special_notifications': result['special_notifications'],
        #             }
        #     result['name'] = re.sub('sunridge', 'SunRidge', NameCase(contact), flags=re.I)
        #     result['is_company'] = False
        #     result['customer'] = True
        #     result['parent_id'] = cus_id
        #     result['use_parent_address'] = True
        #     result['xml_id'] = key = 'cntct_' + key
        #     result['module'] = 'F33'
        #     if key in customer_codes:
        #         id = customer_codes[key]
        #         # leave fis_valid alone
        #         del result['fis_valid']
        #         res_partner.write(id, result)
        #     else:
        #         id = res_partner.create(result, context=context)
        #         customer_codes[key] = id

def update_vendors(table, vendor_codes, contacts, state_recs, country_recs_name ):
    context = {'mail_create_nosubscribe': True}
    for ven_rec in table:
        result = {'active': False}
        result['is_company'] = True
        result['supplier'] = True
        result['customer'] = False
        result['use_parent_address'] = False
        result['xml_id'] = key = ven_rec[F65.code]
        result['module'] = 'VNMS'
        # valid customer code? active account?
        result['fis_valid'] = True
        result['active'] = True
        # notify_by = Specials.get_member(cus_rec[F33.catalog_category].upper(), None)
        # result['special_notifications'] = notify_by and notify_by.db or False
        result['name'] = re.sub(
                config.fis_imports.name_from,
                config.fis_imports.name_to,
                BsnsCase(ven_rec[F65.name]),
                flags=re.I,
                )
        print('name:', result['name'])
        addr1, addr2, addr3 = Sift(ven_rec[F65.addr1], ven_rec[F65.addr2], ven_rec[F65.addr3])
        addr2, city, state, postal, country = cszk(addr2, addr3)
        addr3 = ''
        print('  ' + '\n  '.join([addr1, addr2, addr3, str([city, state, postal]), country]), verbose=2)
        if city and not (addr2 or state or postal or country):
            addr2, city = city, addr2
        addr1 = normalize_address(addr1)
        addr2 = normalize_address(addr2)
        addr1, addr2 = AddrCase(Rise(addr1, addr2))
        city = NameCase(city)
        state, country = NameCase(state), NameCase(country)
        result['street'] = addr1
        result['street2'] = addr2
        result['city'] = city
        result['zip'] = postal.code
        result['country_id'] = False
        result['state_id'] = False
        if state:
            result['state_id'] = state_recs[state][0]
            result['country_id'] = state_recs[state][2]
        elif country:
            country_id = country_recs_name.get(country, None)
            if country_id is None:
                # _logger.critical("Customer %s has invalid country <%r>" % (key, country))
                continue
            else:
                result['country_id'] = country_id
        result['phone'] = fix_phone(ven_rec[F65.tele])
        if not result['name']:
            # _logger.critical("Missing name for customer %s -- skipping" % (key, ))
            continue
        if key in vendor_codes:
            id = vendor_codes[key]
            # leave fis_valid alone
            del result['fis_valid']
            res_partner.write(id, result, context=context)
        else:
            id = res_partner.create(result, context=context)
            vendor_codes[key] = id
        # if contacts and cus_rec[F33.contact]:
        #     cus_id = id
        #     contact = cus_rec[F33.contact]
        #     result = {
        #             'fis_valid': fis_valid,
        #             # 'special_notifications': result['special_notifications'],
        #             }
        #     result['name'] = re.sub('sunridge', 'SunRidge', NameCase(contact), flags=re.I)
        #     result['is_company'] = False
        #     result['customer'] = True
        #     result['parent_id'] = cus_id
        #     result['use_parent_address'] = True
        #     result['xml_id'] = key = 'cntct_' + key
        #     result['module'] = 'F33'
        #     if key in vendor_codes:
        #         id = vendor_codes[key]
        #         # leave fis_valid alone
        #         del result['fis_valid']
        #         res_partner.write(id, result)
        #     else:
        #         id = res_partner.create(result, context=context)
        #         vendor_codes[key] = id

def update_carriers(table, carrier_codes, contacts, state_recs, country_recs_name ):
    context = {'mail_create_nosubscribe': True}
    for ven_rec in table:
        result = {'active': False}
        result['is_company'] = True
        result['supplier'] = True
        result['customer'] = False
        result['use_parent_address'] = False
        result['xml_id'] = key = ven_rec[F65.code]
        result['module'] = 'VNMS'
        # valid customer code? active account?
        result['fis_valid'] = True
        result['active'] = True
        # notify_by = Specials.get_member(cus_rec[F33.catalog_category].upper(), None)
        # result['special_notifications'] = notify_by and notify_by.db or False
        result['name'] = re.sub(
                config.fis_imports.from_name,
                config.fis_imports.to_name,
                BsnsCase(ven_rec[F65.name]),
                flags=re.I,
                )
        print('name:', result['name'])
        addr1, addr2, addr3 = Sift(ven_rec[F65.addr1], ven_rec[F65.addr2], ven_rec[F65.addr3])
        addr2, city, state, postal, country = cszk(addr2, addr3)
        addr3 = ''
        print('  ' + '\n  '.join([addr1, addr2, addr3, str([city, state, postal]), country]), verbose=2)
        if city and not (addr2 or state or postal or country):
            addr2, city = city, addr2
        addr1 = normalize_address(addr1)
        addr2 = normalize_address(addr2)
        addr1, addr2 = AddrCase(Rise(addr1, addr2))
        city = NameCase(city)
        state, country = NameCase(state), NameCase(country)
        result['street'] = addr1
        result['street2'] = addr2
        result['city'] = city
        result['zip'] = postal.code
        result['country_id'] = False
        result['state_id'] = False
        if state:
            result['state_id'] = state_recs[state][0]
            result['country_id'] = state_recs[state][2]
        elif country:
            country_id = country_recs_name.get(country, None)
            if country_id is None:
                # _logger.critical("Customer %s has invalid country <%r>" % (key, country))
                continue
            else:
                result['country_id'] = country_id
        result['phone'] = fix_phone(ven_rec[F65.tele])
        if not result['name']:
            # _logger.critical("Missing name for customer %s -- skipping" % (key, ))
            continue
        if key in carrier_codes:
            id = carrier_codes[key]
            # leave fis_valid alone
            del result['fis_valid']
            res_partner.write(id, result, context=context)
        else:
            id = res_partner.create(result, context=context)
            carrier_codes[key] = id
        # if contacts and cus_rec[F33.contact]:
        #     cus_id = id
        #     contact = cus_rec[F33.contact]
        #     result = {
        #             'fis_valid': fis_valid,
        #             # 'special_notifications': result['special_notifications'],
        #             }
        #     result['name'] = re.sub('sunridge', 'SunRidge', NameCase(contact), flags=re.I)
        #     result['is_company'] = False
        #     result['customer'] = True
        #     result['parent_id'] = cus_id
        #     result['use_parent_address'] = True
        #     result['xml_id'] = key = 'cntct_' + key
        #     result['module'] = 'F33'
        #     if key in carrier_codes:
        #         id = carrier_codes[key]
        #         # leave fis_valid alone
        #         del result['fis_valid']
        #         res_partner.write(id, result)
        #     else:
        #         id = res_partner.create(result, context=context)
        #         carrier_codes[key] = id

def update_employees(table, employee_codes, contacts, state_recs, country_recs_name ):
    context = {'mail_create_nosubscribe': True}
    for ven_rec in table:
        result = {'active': False}
        result['is_company'] = True
        result['supplier'] = True
        result['customer'] = False
        result['use_parent_address'] = False
        result['xml_id'] = key = ven_rec[F65.code]
        result['module'] = 'VNMS'
        # valid customer code? active account?
        result['fis_valid'] = True
        result['active'] = True
        # notify_by = Specials.get_member(cus_rec[F33.catalog_category].upper(), None)
        # result['special_notifications'] = notify_by and notify_by.db or False
        result['name'] = re.sub(
                config.fis_imports.from_name,
                config.fis_imports.to_name,
                BsnsCase(ven_rec[F65.name]),
                flags=re.I,
                )
        print('name:', result['name'])
        addr1, addr2, addr3 = Sift(ven_rec[F65.addr1], ven_rec[F65.addr2], ven_rec[F65.addr3])
        addr2, city, state, postal, country = cszk(addr2, addr3)
        addr3 = ''
        print('  ' + '\n  '.join([addr1, addr2, addr3, str([city, state, postal]), country]), verbose=2)
        if city and not (addr2 or state or postal or country):
            addr2, city = city, addr2
        addr1 = normalize_address(addr1)
        addr2 = normalize_address(addr2)
        addr1, addr2 = AddrCase(Rise(addr1, addr2))
        city = NameCase(city)
        state, country = NameCase(state), NameCase(country)
        result['street'] = addr1
        result['street2'] = addr2
        result['city'] = city
        result['zip'] = postal.code
        result['country_id'] = False
        result['state_id'] = False
        if state:
            result['state_id'] = state_recs[state][0]
            result['country_id'] = state_recs[state][2]
        elif country:
            country_id = country_recs_name.get(country, None)
            if country_id is None:
                # _logger.critical("Customer %s has invalid country <%r>" % (key, country))
                continue
            else:
                result['country_id'] = country_id
        result['phone'] = fix_phone(ven_rec[F65.tele])
        if not result['name']:
            # _logger.critical("Missing name for customer %s -- skipping" % (key, ))
            continue
        if key in employee_codes:
            id = employee_codes[key]
            # leave fis_valid alone
            del result['fis_valid']
            res_partner.write(id, result, context=context)
        else:
            id = res_partner.create(result, context=context)
            employee_codes[key] = id
        # if contacts and cus_rec[F33.contact]:
        #     cus_id = id
        #     contact = cus_rec[F33.contact]
        #     result = {
        #             'fis_valid': fis_valid,
        #             # 'special_notifications': result['special_notifications'],
        #             }
        #     result['name'] = re.sub('sunridge', 'SunRidge', NameCase(contact), flags=re.I)
        #     result['is_company'] = False
        #     result['customer'] = True
        #     result['parent_id'] = cus_id
        #     result['use_parent_address'] = True
        #     result['xml_id'] = key = 'cntct_' + key
        #     result['module'] = 'F33'
        #     if key in employee_codes:
        #         id = employee_codes[key]
        #         # leave fis_valid alone
        #         del result['fis_valid']
        #         res_partner.write(id, result)
        #     else:
        #         id = res_partner.create(result, context=context)
        #         employee_codes[key] = id

def update_products(table, item_map, default_product_codes):
    context = {'mail_create_nosubscribe': True}
    for item in table:
        values = {}
        values['xml_id'] = values['default_code'] = key = item[F135.item_id]
        values['module'] = 'NVTY'
        values['name'] = NameCase(name_chars(' - '.join(item[F135.name].split('\x10'))))
        print('name:', values['name'])
        values['latin'] = item[F135.latin_name]
        if key in item_map:
            # update existing FIS record
            id = item_map[key]
            print('  updating with:', values, verbose=2)
            product.write(id, values, context=context)
        elif key in default_product_codes:
            # update existing default_code record
            id = default_product_codes[key]
            print('  updating with:', values, verbose=2)
            product.write(id, values, context=context)
        else:
            print('  creating with:', values, verbose=2)
            item_map[key] = product.create(values, context=context)

def format_record(record, fields=None):
    lines = []
    name_width = 11
    value_width = 40
    mask_width = 0
    fieldlist = record.fieldlist
    if not fields:
        fields = range(len(record.fieldlist))
    for i, row in enumerate(record.fieldlist):
        if i in fields:
            name_width = max(len(row[3]), name_width)
            value_width = max(len(str(record[row[3]]).rstrip()), value_width)
            mask_width = max(len(str(fieldlist[i][4])), mask_width)
            print(
                    'field %d -> name width: %d   value width: %d   mask wdith: %d'
                        % (i, name_width, value_width, mask_width),
                    verbose=3,
                    )
    print(verbose=3)
    for i, row in enumerate(record.fieldlist):
        if i in fields:
            value = record[row[3]]
            if isinstance(value, basestring):
                value = value.replace('\0', u'\u2400')
                leading_spaces = 0
                for ch in value:
                    if ch != ' ':
                        break
                    leading_spaces += 1
                value = leading_spaces * u'\u2422' + value.lstrip()
                if u'\u2422' in value or u'\u2400' in value:
                    echo('value is:', value)
            print('field %d -> %r' % (i, value), verbose=3)
            if '$' in row[3] and not fieldlist[i][4]:
                lines.append('%5d | %*s | %*s | %*s | %s' % (i+1, -name_width, row[3], mask_width, fieldlist[i][4], -value_width, value, row[1]))
            else:
                lines.append('%5d | %*s | %*s | %*s | %s' % (i+1, -name_width, row[3], mask_width, fieldlist[i][4], value_width, value, row[1]))
    return lines

def convert_name(name, max_len, existing_names=()):
    original_name = name
    name = name.lower()
    if '(' in name:
        name = name.split('(')[0]
    name = name.replace('.', '')
    for text in (' code', ' codes'):
        if name.endswith(text):
            name = name[:-len(text)+1] + 'id' + ('', 's')[text[-1] == 's']
            break
    pieces = name.split()
    if pieces and pieces[0].isdigit() and pieces[1:2] == ['spaces']:
        pieces = pieces[2:]
    for i, p in enumerate(pieces):
        if len(p) == 3 and '/' in p:
            pieces[i] = p[0] + p[2]
    name = ' '.join(pieces)
    if name.startswith(('key type', 'key group')):
        name = 'key type'
    members = []
    # name substitution
    for i, piece in enumerate(re.sub('\W+', ' ', name).split()):
        if i == 0 and piece[0].isdigit():
            piece = numbers.get(piece, piece)
        else:
            piece = common.get(piece, piece)
        members.append(piece)
    # shrink further as necessary
    def no_under(names):
        return ''.join(names)
    def pop_under(names):
        # if we get down to only one name, just trim it to desired size
        if len(names) == 1:
            return names[0][:max_len]
        names.pop()
        return '_'.join(names)
    name = '_'.join(members)
    shrinker = cycle([no_under, pop_under])
    # shrink name if needed
    if len(name) > max_len:
        # first try uncommon abbr
        for i, m in enumerate(members):
            members[i] = uncommon.get(m, m)
        name = '_'.join(members)
    while len(name) > max_len:
        func = next(shrinker)
        name = func(members)
    # check for name already being used
    for suffix in range(1, 10):
        if name not in existing_names:
            break
        else:
            suffix = str(suffix)
            name = name[:-1] + suffix
    else:
        # name still taken
        raise Exception(
                'unable to convert %r\nexisting names: '
                % (original_name, ', '.join(existing_names)
                ))
    return name

numbers = {
    '0':    'zero',
    '1':    'one',
    '2':    'two',
    '3':    'three',
    '4':    'four',
    '5':    'five',
    '6':    'six',
    '7':    'seven',
    '8':    'eight',
    '9':    'nine',
    '10':   'ten',
    '1st':  'first',
    '2nd':  'second',
    '3rd':  'third',
    '4th':  'fourth',
    '5th':  'fifth',
    '6th':  'sixth',
    '7th':  'seventh',
    '8th':  'eighth',
    '9th':  'ninth',
    '10th': 'tenth',
    }

common = {
    'account':      'acct',
    'adjustment':   'adj',
    'allocated':    'alctd',
    'allowance':    'allwnc',
    'amount':       'amt',
    'authority':    'auth',
    'average':      'avg',
    'beginning':    'bgng',
    'category':     'cat',
    'center':       'ctr',
    'centering':    'ctr',
    'check':        'chk',
    'cost':         'cst',
    'credit':       'cr',
    'credits':      'crs',
    'customer':     'cust',
    'debit':        'dr',
    'debits':       'drs',
    'department':   'dept',
    'description':  'desc',
    'discount':     'disc',
    'each':         'ea',
    'ingredient':   'ingr',
    'kosher':       'kshr',
    'length':       'len',
    'level':        'lvl',
    'invoice':      'inv',
    'maximum':      'max',
    'mesg':         'msg',
    'method':       'mthd',
    'minimum':      'min',
    'number':       'no',
    'numbers':      'nos',
    'payment':      'pymt',
    'package':      'pkg',
    'packaging':    'pkgg',
    'price':        'prc',
    'product':      'prod',
    'production':   'prod',
    'position':     'pos',
    'quantity':     'qty',
    'redemption':   'rdmtn',
    'revision':     'rev',
    'rounding':     'rndg',
    'sequence':     'seq',
    'stock':        'stk',
    'string':       'str',
    'transaction':  'trans',
    'warehouse':    'wrhse',
    'wholesale':    'whlsl',
    }

uncommon = {
    'adjust':       'adj',
    'company':      'comp',
    'formula':      'frml',
    'other':        'oth',
    'total':        'ttl',
    }

def connect_oe(database, connection=[]):
    global res_partner, product, fis_user
    if not connection:
        print('using %r and %r to connect to %r:%r' % ('fis_daemon', config.openerp.pw, config.openerp.host, database))
        connection.append(
                get_connection(
                    database=database,
                    login='fis_daemon',
                    password=config.openerp.pw,
                    hostname=config.openerp.host,
                    ))
        fis_user = connection[0].user_id
    res_partner = connection[0].get_model('res.partner')
    product = connection[0].get_model('product.product')
    return connection[0]

def get_xml_id_map(oe, model, module, ids=None):
    "return {xml_id: id} for all xml_ids in module"
    imd = oe.get_model('ir.model.data')
    result = {}
    for rec in get_records(
            imd,
            domain=[('model','=',model),('module','ilike',module)],
            skip_fields=['is_salesinq_able', 'salesinq_data', 'image', 'image_small', 'image_medium'],
            ):
        if ids is None or rec.res_id in ids:
            result[rec.name] = rec.res_id
    return result

def get_active_customers():
    import requests
    result = set()
    if config.network.active_customer_url:
        try:
            web_data = requests.get(config.network.active_customer_url)
        except requests.exceptions.ConnectionError:
            pass
        else:
            companies = re.findall(r'<th.*?>(.*?)</th>', web_data.text)
            for line in companies:
                fis_id = line.split()[0]
                if fis_id.isdigit():
                    result.add(fis_id)
                    print(line)
    echo('found %d active companies' % len(result))
    return result


if env.abbr == 'whc':

    class F27(FISenum):
        "Carrier (Ship Via) Master File (key starts with SV)"
        company_id = 'An$(3,2)', 0.1
        code = 'An$(5,2)',       0.2
        name = 'Bn$',            0.3
        addr1 = 'Cn$',           0.4
        addr2 = 'Dn$',           0.5
        addr3 = 'En$',           0.6
        tele = 'Fn$',            0.7
        fuel_surcharge = 'Gn$',  0.8

    class F33(FISenum):
        """
        CSMS - CUSTOMER MASTER FILE - BASIC RECORD
        """
        company_id            = 'An$(1,2)',   0.1     # COMPANY CODE
        code                  = 'An$(3,6)',   0.2     # CUSTOMER NO.
        name                  = 'Bn$',        0.3     # NAME
        addr1                 = 'Cn$',        0.4     # ADDR LINE 1
        addr2                 = 'Dn$',        0.5     # ADDR LINE 2
        addr3                 = 'En$',        0.6     # ADDR LINE 3
        postal                = 'Ln$',        0.7     # ZIP CODE
        contract_prices       = 'Fn$(1,1)',   0.8     # Contract Prices?
        price_list_id         = 'Fn$(2,1)',   0.9     # Price List Code
        catalog_category      = 'Fn$(8,1)',   1.1     # Catalog Category
        this_year_sales       = 'Ln',         1.2     # M-T-D SALES
        last_year_sales       = 'Pn',         1.3     # Prev Year Sales
        broker_id             = 'Gn$(1,3)',   1.4     # Broker Code
        salesrep              = 'Gn$(4,3)',   1.5     # Salesrep Code
        tele                  = 'Gn$(20,10)', 1.6     # Telephone Number
        cust_type_id          = 'Hn$(1,2)',   1.7     # Customer Type Code
        sales_class_id        = 'Hn$(3,4)',   1.8     # Sales Class Code
        pricing_method        = 'Hn$(7,2)',   1.9     # Pricing Method
        alpha_sort_key        = 'In$',        2.1     # Alpha Sort Key
        contact               = 'Kn$(31,30)', 2.2     # Accntg Comments

    class F47(FISenum):
        "CNVZZ - CBS SALESMAN MASTER FILE"
        key_type                  = 'An$(1,1)',  0.1    # KEY TYPE = 'Z'
        salesperson_id            = 'An$(2,3)',  0.2    # SALESPERSON CODE
        salesperson_name          = 'Bn$',       0.3    # SALESPERSON NAME
        company_id                = 'Fn$(1,2)',  0.4    # COMPANY CODE
        phone_no                  = 'Fn$(3,10)', 0.5    # PHONE NUMBER
        salesinq_access           = 'Hn$',       0.6    # SalesInq Access

    class F65(FISenum):
        "Vendor Master"
        company_id =    'An$(1,2)',     0.1
        code =          'An$(3,6)',     0.2
        name =          'Bn$',          0.3
        addr1 =         'Cn$',          0.4
        addr2 =         'Dn$',          0.5
        addr3 =         'En$',          0.6
        tele =          'Gn$(1,15)',    0.7
        fax =           'Gn$(16,15)',   0.8
        contact =       'Nn$',          0.9

    class F74(FISenum):
        "EMP1 - P/R EMPLOYEE MASTER BASIC RECORD MAINT/INQUIRY"
        company_id        = 'An$(1,2)',    0.1   # COMPANY CODE
        emp_num           = 'An$(3,5)',    0.2   # EMPLOYEE NO.
        name              = 'Bn$',         0.3   # EMPLOYEE NAME
        addr1             = 'Cn$',         0.4   # ADDRESS 1
        addr2             = 'Dn$',         0.5   # ADDRESS 2
        addr3             = 'En$',         0.6   # ADDRESS 3
        ssn               = 'Fn$',         0.7   # SOC.SEC.NO.
        tele              = 'Gn$',         0.8   # TELEPHONE NO.
        date_hired        = 'In$(1,6)',    0.9   # DATE HIRED
        date_terminated   = 'In$(7,6)',    1.1   # DATE TERMINATED
        birth_date        = 'In$(19,6)',   1.2   # BIRTHDATE
        last_raise        = 'In$(43,6)',   1.3   # Last Raise
        home_dept         = 'Jn$(1,2)',    1.4   # HOME DEPARTMENT
        status_flag       = 'Kn$(1,1)',    1.5   # STATUS FLAG
        pay_type          = 'Kn$(2,1)',    1.6   # PAY TYPE
        marital_status    = 'Kn$(4,1)',    1.7   # MARITAL STATUS
        pension_status    = 'Kn$(8,1)',    1.8   # PENSION STATUS
        gender            = 'Kn$(21,1)',   1.9   # GENDER
        driver_license    = 'Kn$(26,10)',  2.1   # Driver's Lic #
        emergency_contact = 'Kn$(36,18)',  2.2   # Emerg Contact
        emergency_phone   = 'Kn$(54,10)',  2.3   # Emerg Phone
        exempt_fed        = 'X(0)',        2.4   # # EXEMPT-FED
        exempt_state      = 'X(1)',        2.5   # # EXEMPT-STATE
        hourly_rate       = 'R(0)',        2.6   # HOURLY RATE

    class F97(FISenum):
        "Inventory Availablility Code"
        code = 'An$(5,1)',  0.1
        desc = 'Bn$',       0.2

    class F135(FISenum):
        """
        NVTY - INVENTORY MASTER FILE MAINTENANCE & INQU
        """
        company_id              = 'An$(1,2)',    0.1   #   0: Company Code
        item_id                 = 'An$(3,8)',    0.2   #   1: Item Code
        available               = 'Bn$(1,1)',    0.3   #   5: Available (Y/N/D/H)
        product_category        = 'Bn$(4,1)',    0.4   #   8: Product Category
        name                    = 'Cn$',         0.5   #  32: Description
        latin_name              = 'Dn$(33,40)',  0.6   #  38: Latin Name
        on_hand                 = 'I(6)',        0.7   #  55: Quantity on hand
        committed               = 'I(7)',        0.8   #  56: Quantity Committed
        on_order                = 'I(8)',        0.9   #  57: Quantity on order

    class F140(FISenum):
        """
        CSMSB - CUSTOMER MASTER FILE - DEFAULT SHIP-TO
        """
        company_id            = 'An$(1,2)',    0    #   0: COMPANY
        code                  = 'An$(3,6)',    1    #   1: Customer Code
        ship_to               = 'An$(9,1)',    2    #   2: ship-to indicator -> ' ' = False, '1' = True
        ship_to_sequence      = 'An$(10,2)',   3    #   3: default or sequence -> '  ' = default; '01', etc,
        name                  = 'Bn$',         4    #   4: SHIP TO NAME
        addr1                 = 'Cn$',         5    #   5: ADDRESS LINE 1
        addr2                 = 'Dn$',         6    #   6: ADDRESS LINE 2
        addr3                 = 'En$',         7    #   7: ADDRESS LINE 3
        postal                = 'Ln$',         8    #   8: ZIP CODE
        tele                  = 'Qn$(1,15)',  52    #  52: Phone Number
        comments              = 'Gn$',        55    #  55: Comments

    class F163(FISenum):
        """
        POSM - SUPPLIER MASTER FILE
        """
        company_id        = 'An$(1,2)',    0   #   0: COMPANY CODE
        supplier_no       = 'An$(3,6)',    1   #   1: SUPPLIER NUMBER
        supplier_name     = 'Bn$',         2   #   2: SUPPLIER NAME
        addr1             = 'Cn$',         3   #   3: ADDRESS 1
        addr2             = 'Dn$',         4   #   4: ADDRESS 2
        addr3             = 'En$',         5   #   5: ADDRESS 3
        telephone_no      = 'Gn$(1,15)',   7   #   7: Telephone Number
        fax_no            = 'Gn$(16,15)',  8   #   8: FAX Number
        vendor_no         = 'In$(10,6)',  23   #  23: VENDOR NUMBER

    class F250(FISenum):
        """
        NVBA - INVENTORY LOT CONTROL FILE MAINTENANCE &
        """
        #
        _init_ = "value sequence"
        _order_ = lambda m: m.sequence
        #
        company_id               = 'An$(1,2)',     0     # Company Code
        item_id                  = 'An$(3,8)',     1     # Item Code
                                                         # (open) An$(11,4)
        wrhse_id                 = 'An$(15,4)',    3     # Warehouse Code
        lot_no                   = 'An$(19,8)',    4     # Lot Number
        prod_receipt_date        = 'Bn$(1,6)',     5     # Production/Receipt Date
        hold_date                = 'Bn$(7,6)',     6     # Hold Date
                                                         # (open) Bn$(13,6)
        tag_type_id              = 'Cn$(1,2)',     8     # Tag Type Code
        random_weights           = 'Cn$(3,1)',     9     # Random Weights (Y,sp=no)
        pack_type                = 'Cn$(4,2)',    10     # Pack Type
        status_code              = 'Cn$(6,1)',    11     # Status Code (sp/H/C)
        hold_reason_id           = 'Cn$(7,2)',    12     # Hold Reason Code
        location                 = 'Cn$(9,2)',    13     # Location
        comments_part_1          = 'Cn$(11,20)',  14     # Comments Part 1
        reference_no             = 'Cn$(31,8)',   15     # Reference Number
        bin_no                   = 'Cn$(39,6)',   16     # Bin Number
        publ_whse_lot_no         = 'Cn$(44,15)',  17     # Publ Whse Lot No
        comments_part_2          = 'Cn$(59,30)',  18     # Comments Part 2
        qty_on_hand              = 'Q(0)',        19     # Quantity on Hand
        qty_committed            = 'Q(1)',        20     # Quantity Committed
        qty_on_order             = 'Q(2)',        21     # Quantity on Order
        standard_lot_cst         = 'Q(3)',        22     # Standard Lot Cost
        qty_produced             = 'Q(4)',        23     # Quantity Produced
        qty_on_hold              = 'Q(5)',        24     # Quantity on Hold
        standard_pack_in_lbs     = 'Q(6)',        25     # Standard Pack in Lbs
        piece_count              = 'Q(7)',        26     # Piece Count
        total_net_weight_on_hand = 'Q(8)',        27     # Total Net Weight on Hand
        beg_bal                  = 'Q(9)',        28     # Beg Bal (temp)
        net_movement             = 'Q(10)',       29     # Net movement(temp)

    class F341(FISenum):
        "Production Line Master"
        company_id =    'An$(2,2)', 0.1
        code =          'An$(4,2)', 0.2
        desc =          'Bn$',      0.3
        short_desc =    'Cn$',      0.4

else:

    class F11(FISenum):
        "Sales Category codes"
        code = 'An$(5,2)',  0.1
        desc = 'Cn$',       0.2
        shelf_life = 'FN',  0.3

    class F135(FISenum):
        """
        NVTY1 - INVENTORY MASTER (STATUS & DESCRIPTION)
        """
        item_id           = 'An$(1,6)',   0   #   0: Item Code
        company_id        = 'An$(7,2)',   1   #   1: Company Code
        warehouse_no      = 'An$(9,4)',   2   #   2: Warehouse Number
        company           = 'An$(13,6)',  3   #   3: 4 SPACES + COMPANY
        key_type          = 'An$(19,3)',  4   #   4: Key Type = '1**'


Main()
