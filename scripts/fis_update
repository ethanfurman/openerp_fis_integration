#!/usr/local/sbin/suid-python --virtualenv
"""\
Update OpenERP tables from FIS source files.

Downloads selected FIS files, determine which have changed, finds the
appropriate script, and runs it.
"""

from __future__ import print_function
from scription import *
from antipathy import Path
from logging import getLogger, INFO, Formatter, handlers
from pandaemonium import PidLockFile
import os
import time
import updates
updates.script_verbosity = script_verbosity


# two directories are used, one for old data and one for the new incoming
# data;
# which is used is determined by the timestamp on a specifec file
# called age


@Script()
def main():
    print('getting logger', verbose=2)
    global logger, master, path, pre, old, new, active_files, extra_files, config
    logger = getLogger()
    logger.setLevel(INFO)
    _handler = handlers.RotatingFileHandler(
            '%s/var/log/openerp/update_fis.log' % os.environ['VIRTUAL_ENV'],
            maxBytes=1024*1024*1024,
            backupCount=30,
            )
    _formatter = Formatter('%(process)06d %(asctime)s %(name)-25s %(message)s')
    _handler.setFormatter(_formatter)
    logger.addHandler(_handler)
    config = OrmFile('%s/config/fnx.ini' % os.environ['VIRTUAL_ENV'], types={'_path':Path})
    master = config.network.fis_data_host
    path = config.network.fis_data_path
    pre = config.network.fis_data_prefix
    old = config.network.fis_data_local_old_path
    new = config.network.fis_data_local_path
    active_files = config.network.fis_openerp_files.split()
    extra_files = config.network.fis_extra_files.split()
    with PidLockFile('/var/run/fis_update.pid'):
        script_command()

@Command(
        method=Spec(
            'perform quick or full comparison [quick: compare against old FIS files;'
            ' full: compare against OpenERP records',
            choices=['quick', 'full'],
            default='quick',
            type=lambda f: f.lower(),
            ),
        skip_copy=Spec('Skip copying files', FLAG, None),
        skip_update=Spec('Skip updating OpenERP', FLAG, None),
        dryrun=Spec('do not actually make changes', FLAG),
        list_records=Spec('list affected records', FLAG),
        bw_limit=Spec('rate limit rsync command', OPTION, force_default=10),
        abort_on_error=Spec('abort on error', FLAG),
        extra=Spec('extra arguments for subscripts', OPTION),
        )
def fis_update(method, skip_copy, skip_update, dryrun, list_records, bw_limit, abort_on_error, **extra):
    """
    update FIS files from master, then FIS data in OpenERP

    copy from network.fis_data_local_path to network.fis_data_local_old_path
    copy from network.fis_data_host/path to network.fis_data_local_path
    calculate changed files
    find update scripts for those files
    run scripts
    """
    #
    # step 1: move files around
    #
    if not skip_copy:
        print('copying files (at: %s)' % (time.strftime('%H:%M:%S', time.localtime()), ))
        # copy files to old path
        system('rsync -a %s/ %s' % (new, old))
        # calculate which files to grab from master
        if method == 'full':
            files = '{path}/{pre}???? {path}/{pre}????? {path}/{pre}??????'.format(path=path, pre=pre).split()
        else:
            files = ['%s/%s%s' % (path, pre, f) for f in active_files]
        # add extra files iff method is full
        if method == 'full':
            for filename in extra_files:
                files.append('{path}/{name}'.format(path=path, name=filename))
        # and grab the files
        system('rsync --bwlimit=%d %s:%s %s/' % (bw_limit, master, ' :'.join(files), new))
        system('chown -R openerp: /FIS')
        config.network.fis_data_local_path.chmod(0o440, '*')
    #
    # step 2: determine which files changed (only if quick, does not check extra_files)
    #
    if method == 'quick':
        print('checking for changed files (at: %s)' % time.strftime('%H:%M:%S', time.localtime()))
        print('  between %r and %r' % (old, new), verbose=2)
        files = [
            f for f in new.glob('%s????' % pre) if
                f.stat().st_mtime != old.stat(f.filename).st_mtime
            ]
        files.extend([
            f for f in new.glob('%s?????' % pre) if
                f.stat().st_mtime != old.stat(f.filename).st_mtime
            ])
        files.extend([
            f for f in new.glob('%s??????' % pre) if
                f.stat().st_mtime != old.stat(f.filename).st_mtime
            ])
        # strip path and leading {pre} from filenames
        files = [f.filename[1:] for f in files]
        print('changed file candidates: %s [%s]' % (len(files), ', '.join(files)), verbose=1)
    #
    # step 3: get appropriate scripts, and execute them
    #
    if not skip_update:
        print('checking for mappings (at: %s)' % time.strftime('%H:%M:%S', time.localtime()))
        FIS_mapping = updates.get_script_mapping()
        print('FIS_mapping:\n   ', '\n   '.join(['%s: %r' % (k, v) for k, v in FIS_mapping.items()]), sep='', verbose=2)
        for script, tables in sorted(FIS_mapping.items()):
            if method == 'quick':
                tables = set(tables) & set(files)
            else:
                # sync all tables for "full" update
                tables = set(tables)
            cmd = ('/opt/bin/updates/%s --method=%s'
                % (script,
                   method,
                ))
            if dryrun:
                cmd += ' --dryrun'
            if list_records:
                cmd += ' --list-records'
            if script_verbosity:
                cmd += ' -' + 'v' * script_verbosity
            if extra:
                cmd += ' %s' % ' '.join(['%s=%s' % (k, v) for k, v in sorted(extra.items())])
            # process the tables one at a time since we are having memory errors
            # when we try to do them all at once
            # additionally, if the command errored out due to connectivity issues, rerun
            # the command
            for table in tables:
                command = '%s %s' % (cmd, table)
                attempts = 0
                while True:
                    attempts += 1
                    try:
                        system(command, abort_on_error)
                    except ServiceUnavailable:
                        # wait five minutes for system to come back up
                        if attempts > 5:
                            # but only five times
                            break
                        time.sleep(420)
                    else:
                        break

class ServiceUnavailable(Exception):
    "presented when unable to communicate with OpenERP server"


def system(cmd, abort_on_error=False):
    with user_ids(0, 0):
        print(
                '--==[%s] running "%s" [%s] . . .: ' % (time.strftime('%H:%M:%S', time.localtime()), cmd),
                end='',
                verbose=1,
                )
        job = Execute(cmd, pty=True)
        print(job.returncode, ' [%s]==--' % time.strftime('%H:%M:%S', time.localtime()), verbose=1)
        if job.returncode or job.stderr:
            v_level = 0
            if not script_verbosity:
                echo('Error with command (returncode %r):' % (job.returncode, ))
                echo('---- cmd  ----')
                echo(cmd)
        else:
            v_level = 1
        if job.stdout.strip():
            print('---- stdout ----', verbose=v_level)
            print('\n'.join(['   %s' % l for l in job.stdout.strip().split('\n')]), verbose=v_level)
            if v_level:
                print('==========================================', verbose=1)
        if job.returncode or job.stderr:
            error('---- stderr ----')
            if job.stderr.strip():
                error('\n'.join(['   %s' % l for l in job.stderr.strip().split('\n')]))
                error('==========================================')
            if abort_on_error:
                abort()
            if job.returncode == Exit.Unavailable:
                raise ServiceUnavailable

Main()
