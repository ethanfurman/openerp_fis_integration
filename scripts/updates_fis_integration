#!/usr/local/sbin/suid-python --virtualenv

# imports
from __future__ import print_function

from scription import *
from aenum import Enum
from collections import defaultdict
from fis_schema import F27, F33, F65, F74, F163
    # from fis_scheam import F47
from fis_schema import get_changed_records as get_changed_fis_records, combine_by_value
from openerplib import AttrDict, get_connection, get_records, Many2One, DEFAULT_SERVER_DATE_FORMAT
    # from traceback import format_exception
from VSS.address import cszk, normalize_address, Rise, Sift, AddrCase, NameCase, BsnsCase, NameCaseReversed, PostalCode
from VSS.BBxXlate.fisData import fisData
from VSS.utils import fix_phone, fix_date, Date, grouped
import re
import os
import sys

C = Color
grey = C.Dim | C.FG_White
white = C.Normal | C.FG_White
same = C.Normal | C.FG_White
oldv = C.Normal | C.FG_Red
newv = C.Normal | C.FG_Green

# API
@Script(
        dryrun=('do not make changes, only show what changes would be made', FLAG),
        list_records=Spec('list added/changed records', FLAG),
        )
def main(dryrun, list_records):
    global config, oe, errors, DRYRUN, LIST_RECORDS, script_verbosity
    DRYRUN = LIST_RECORDS = False
    config = OrmFile('%s/config/fnx.ini' % os.environ['VIRTUAL_ENV'])
    oe = config.openerp
    oe = get_connection(hostname=oe.host, database=oe.db, login=oe.user, password=oe.pw)
    errors = defaultdict(list)
    if dryrun:
        DRYRUN = True
        if not script_verbosity:
            script_verbosity = 1
    LIST_RECORDS = list_records

@Command(
        files=Spec('changed FIS files', MULTIREQ, type=lambda f: f.lower()),
        method=Spec(
            'perform quick or full comparison [quick: compare against old FIS files;'
            ' full: compare against OpenERP records',
            OPTION,
            choices=['quick', 'full'],
            default='quick',
            type=lambda m: m.lower(),
            ),
        delete=Spec('delete records [default: send email]', FLAG,),
        )
def fis_integration(files, method, delete):
    global state_recs, country_recs, emp1, posm, vnms, csms
    global skipped_suppliers, vendor_suppliers, ven2sup
    global models, DELETE
    DELETE = delete
    ven2sup = {}
    state_recs = dict([
        (r.name, (r.id, r.code, r.country_id))
        for r in get_records(oe, 'res.country.state')
        ])
    country_recs = dict([
        (r.name, r.id)
        for r in get_records(oe, 'res.country')
        ])
    for name, rec_id in country_recs.items():
        country_recs[rec_id] = name
    csms = fisData(33, keymatch='10%s')
    emp1 = fisData(74, keymatch='10%s')
    vnms = fisData(65, keymatch='10%s')
    posm = fisData(163, keymatch='10%s')
    skipped_suppliers = set()
    vendor_suppliers = set()
    if 'emp1' in files:
        handle_emp1(method)
    if 'posm' in files:
        handle_posm(method)
    if 'vnms' in files:
        handle_vnms(method)
    if 'csms' in files:
        handle_csms(method)
    if 'cnvz' in files:
        # handle_sales_reps(method)
        handle_carrier(method)
    if 'nvty' in files:
        handle_nvty(method)
    for m, problems in sorted(Model.errors.items()):
        error(m,'\n============')
        for p in problems:
            error('  ', p)
        error()

# helpers
def handle_nvty(method):
    nvty_old = fisData(135, keymatch='10%s', data_path=config.network.fis_data_local_old_path)
    nvty_old
    # changed_records = 0
    # added_records = 0
    # changes, added, deleted = get_changed_fis_records(
    #         nvty_old.values(),
    #         nvty.values(),
    #         enum_schema=[
    #             F33.name, F33.salesrep, F33.catalog_category, F33.this_year_sales,
    #             F33.last_year_sales, F33.tele, F33.contact,
    #             ],
    #         address_fields=[
    #             F33.addr1, F33.addr2, F33.addr3,
    #             ],
    #         )
    # changed_map = combine_by_value(F33, changes)
    # print('--== PROCESSING CHANGES --==')
    # for changed_fields, records in sorted(changed_map.items()):


def handle_csms(method):
    print('processing CSMS', border=('flag', '#'))
    context = {'fis-updates': True, 'active_test': False}
    res = AttrDict()
    res.partner = Model(oe.get_model('res.partner'), 'csms', 'F33', context)
    # these are for tracking original old/new records
    new_company_records = {}
    new_contact_records = {}
    old_company_records = {}
    old_contact_records = {}
    # these  are for tracking old/new versions of changed records
    old_changed_company_records = {}
    old_changed_contact_records = {}
    new_changed_company_records = {}
    new_changed_contact_records = {}
    # these are for added/deleted records
    added_company_records = {}
    added_contact_records = {}
    deleted_records = {}
    # and the counts
    changed_count = 0
    added_count = 0
    deleted_count = 0
    ids = {}
    #
    # get the "old" data from:
    # - quick -> old fis file
    # - full -> current OpenERP data
    #
    csms = fisData(33, keymatch='10%s ')
    print(csms.filename, verbose=2)
    print('gathering data', border='flag')
    if method == 'quick':
        #
        # for a quick compare we can use the fis records as-is
        #
        csms_old = fisData(33, keymatch='10%s', data_path=config.network.fis_data_local_old_path)
        print(csms_old.filename, verbose=2)
        print('collecting changed records')
        changes, added, deleted = get_changed_fis_records(
                csms_old.values(),
                csms.values(),
                enum_schema=[
                    F33.name, F33.salesrep, F33.catalog_category, F33.this_year_sales,
                    F33.last_year_sales, F33.tele, F33.contact,
                    ],
                address_fields=[
                    F33.addr1, F33.addr2, F33.addr3,
                    ],
                )
        #
        # we now have the subset of records that have changed, just need to separate them
        # into old and new
        #
        print('sorting changed records')
        for old, new, diffs in changes:
            old_company, old_contact = convert_csms_rec(old)
            old_company_records[old_company.xml_id] = old_company
            new_company, new_contact = convert_csms_rec(new)
            new_company_records[new_company.xml_id] = new_company
            # changes at the FIS level don't always translate to changes at the OpenERP level
            if old_company != new_company:
                old_changed_company_records[old_company.xml_id] = old_company
                new_changed_company_records[new_company.xml_id] = new_company
            # determine if contacts are added, deleted, or changed
            if old_contact is not None:
                old_contact_records[old_contact.xml_id] = old_contact
            if new_contact is not None:
                new_contact_records[new_contact.xml_id] = new_contact
            if old_contact == new_contact:
                pass
            elif old_contact is None:
                added_contact_records[new_contact.xml_id] = new_contact
            elif new_contact is None:
                deleted_records[old_contact.xml_id] = old_contact
            else:
                old_changed_contact_records[old_contact.xml_id] = old_contact
                new_changed_contact_records[new_contact.xml_id] = new_contact
            assert set(old_changed_company_records.keys()) == set(new_changed_company_records.keys()),\
                    "old and new company records mismatch"
            assert set(old_changed_contact_records.keys()) == set(new_changed_contact_records.keys()),\
                    "old and new contact records mismatch"
        #
        # and convert the new and deleted records
        #
        print('sorting new and deleted records')
        for fis_rec in added:
            company, contact = convert_csms_rec(fis_rec)
            new_company_records[company.xml_id] = company
            added_company_records[company.xml_id] = company
            if contact is not None:
                new_contact_records[contact.xml_id] = contact
                added_contact_records[contact.xml_id] = contact
        for fis_rec in deleted:
            company, contact = convert_csms_rec(fis_rec)
            old_company_records[company.xml_id] = company
            deleted_records[company.xml_id] = company
            if contact is not None:
                old_contact_records[contact.xml_id] = contact
                deleted_records[contact.xml_id] = contact
    elif method == 'full':
        #
        # when doing a full compare, we have to convert every single fis record before we can
        # check for changes
        #
        all_fis_records = AttrDict()
        for fis_rec in csms.values():
            company, contact = convert_csms_rec(fis_rec)
            all_fis_records[company.xml_id] = company
            # process contact, if any
            if contact is not None:
                all_fis_records[contact.xml_id] = contact
        #
        # retrieve the OpenERP records that match the CSMS module, and divvy them up into company
        # and contact records
        #
        print('retrieving OpenERP records')
        all_oe_records = dict([
                (r.xml_id, r)
                for r in get_records(
                    oe, 'res.partner',
                    domain=[('module','=','F33')],
                    fields=[
                        'id', 'module', 'xml_id',
                        'name', 'street', 'street2', 'city', 'state_id', 'zip', 'country_id',
                        'fis_valid', 'specials_notification', 'phone', 'is_company', 'customer',
                        'fis_updated_by_user', 'active', 'use_parent_address',
                        ],
                    context=context,
                    )
                ])
        print('sorting company and contact records')
        for xml_id, datom in all_oe_records.items():
            ids[xml_id] = datom.id
            if xml_id.startswith('cntct_'):
                # do not update address from here -- it's either the default of "use parent's"
                # or it's been changed by the user (same with specials_notification)
                del datom.use_parent_address
                del datom.phone, datom.street, datom.street2
                del datom.city, datom.state_id, datom.zip, datom.country_id
                del datom.specials_notification
                old_contact_records[xml_id] = datom
            else:
                old_company_records[xml_id] = datom
        #
        # now we can separate into new, changed, and deleted buckets
        #
        print('sorting changed, new, and deleted company/contact records')
        all_keys = set(all_fis_records.keys() + old_company_records.keys() + old_contact_records.keys())
        for key in all_keys:
            old_rec = all_oe_records.get(key)
            new_rec = all_fis_records.get(key)
            if old_rec is new_rec is None:
                continue
            if old_rec is None:
                if is_contact(new_rec):
                    added_contact_records[key] = new
                else:
                    added_company_records[key] = new_rec
                continue
            if new_rec is None:
                deleted_records[key] = old_rec
                continue
            # copy missing fields for proper equality testing
            new_rec.id = old_rec.id
            new_rec.fis_updated_by_user = old_rec.fis_updated_by_user
            if new_rec == old_rec:
                continue
            #
            # we have changes, save the records for later comparison
            #
            if key.startswith('cntct_'):
                # we don't use the "use_parent_address" nor "specials_notification" for changes
                del new_rec.use_parent_address, new_rec.specials_notification
                old_changed_contact_records[key] = old_rec
                new_changed_contact_records[key] = new_rec
            else:
                old_changed_company_records[key] = old_rec
                new_changed_company_records[key] = new_rec

        assert set(old_changed_company_records.keys()) == set(new_changed_company_records.keys()),\
                "old and new company records mismatch"
        assert set(old_changed_contact_records.keys()) == set(new_changed_contact_records.keys()),\
                "old and new contact records mismatch"
    else:
        abort('unknown METHOD: %r' % (method, ))
    #
    # at this point, all records are in AttrDict format, divided by company/contact
    # and deleted, added, changed
    #
    # process changes
    #
    print('processing company changes', border='flag')
    assert set(old_changed_company_records.keys()) == set(new_changed_company_records.keys()),\
            "old/new company records mismatch"
    changed_company_xml_ids = sorted(old_changed_company_records.keys())
    for xml_id in changed_company_xml_ids:
        #
        # TODO: check actual values in OpenERP and remove "changes" that are already set
        #
        # figure out the changes
        #
        old_record = old_changed_company_records[xml_id]
        new_record = new_changed_company_records[xml_id]
        assert old_record.keys() == new_record.keys(),\
                ('old/new keys mismatch\nold:%s\n%s\nnew:%s\n%s' %
                    ('|'.join(sorted(old_record.keys())), box(str(old_record)),
                     '|'.join(sorted(new_record.keys())), box(str(new_record))))
        if method == 'full':
            assert 'id' in old_record, box('id field missing for %r' % (xml_id, ))
            # check for user-updated-address and specials
            user_updates = old_record.fis_updated_by_user or ''
            if 'A' in user_updates:
                # drop all the address fields
                del old_record.use_parent_address
                del old_record.street, old_record.street2
                del old_record.city, old_record.state_id, old_record.zip, old_record.country_id
                del new_record.use_parent_address
                del new_record.street, new_record.street2
                del new_record.city, new_record.state_id, new_record.zip, new_record.country_id
            if 'S' in user_updates:
                del old_record.specials_notification
                del new_record.specials_notification
            if 'N' in user_updates:
                del old_record.name
                del new_record.name
        elif xml_id in ids:
            # maybe this xml_id has already been seen?
            new_record.id = old_record.id = ids[xml_id]
        else:
            # otherwise, we'll look it up when we check for changes against OpenERP
            pass
        changes = AttrDict()
        for key in old_record:
            if old_record[key] != new_record[key]:
                changes[key] = new_record[key]
        #
        # if this is a "full" update, we already have ids, and the changes are accurate
        # otherwise, we need to get the ids, and see if the "changes" have already been
        # put in place on the OpenERP side, as well as checking for user-updates that
        # should not be overridden
        #
        if method == 'quick':
            fields_to_check = changes.keys() + ['fis_updated_by_user']
            matches = res.partner.read(
                    domain=[('xml_id','=',xml_id),('module','=','F33')],
                    fields=fields_to_check+['fis_updated_by_user'],
                    )
            if not matches:
                res.partner.error('changed company F33:%s not found in OpenERP' % xml_id)
            [match] = matches
            new_record.id = old_record.id = match.id
            ids[xml_id] = match.id
            for field in changes:
                if match[field] == changes[field]:
                    del changes[field]
            user_updates = match.fis_updated_by_user or ''
            if 'N' in user_updates:
                changes.pop('name', None)
            if 'S' in user_updates:
                changes.pop('specials_notification', None)
            if 'A' in user_updates:
                for f in ('street', 'street2', 'city', 'state_id', 'zip', 'country_id'):
                    changes.pop(f, None)
        # quick and full from here
        if changes:
            changed_count += 1
            if LIST_RECORDS:
                echo('  F33:%s  %s' % (xml_id, new_record.name), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in changes.items()), '||', end='')
                echo()
            if not DRYRUN:
                res.partner.write(xml_id, new_record.id, changes)
    print('processing contact changes', border='flag')
    assert set(old_changed_contact_records.keys()) == set(new_changed_contact_records.keys()),\
            "old/new contact records mismatch"
    changed_contact_xml_ids = sorted(old_changed_contact_records.keys())
    for xml_id in changed_contact_xml_ids:
        #
        # TODO: check actual values in OpenERP and remove "changes" that are already set
        #
        # figure out the changes
        #
        old_record = old_changed_contact_records[xml_id]
        new_record = new_changed_contact_records[xml_id]
        assert old_record.keys() == new_record.keys(),\
                ('old/new keys mismatch\nold:%s\n%s\nnew:%s\n%s' %
                    ('|'.join(sorted(old_record.keys())), box(str(old_record)),
                     '|'.join(sorted(new_record.keys())), box(str(new_record))))
        if 'id' in old_record:
            # old record is OpenERP's so it has the ID field already
            new_record.id = old_record.id
        elif xml_id in ids:
            # maybe this xml_id has already been seen?
            new_record.id = old_record.id = ids[xml_id]
        else:
            # otherwise, we'll look it up when we check for changes against OpenERP
            pass
        changes = AttrDict()
        for key in old_record:
            if old_record[key] != new_record[key]:
                changes[key] = new_record[key]
        #
        # if this is a "full" update, we already have ids, and the changes are accurate
        # otherwise, we need to get the ids, and see if the "changes" have already been
        #   put in place on the OpenERP side
        #
        if method == 'quick':
            fields_to_check = changes.keys()
            matches = res.partner.read(
                    domain=[('xml_id','=',xml_id),('module','=','F33')],
                    fields=fields_to_check+['fis_updated_by_user'],
                    )
            if not matches:
                res.partner.error('changed contact F33:%s not found in OpenERP' % xml_id)
            [match] = matches
            new_record.id = old_record.id = match.id
            for field in changes:
                if match[field] == changes[field]:
                    del changes[field]
            user_updates = match.fis_updated_by_user or ''
            if 'N' in user_updates:
                changes.pop('name', None)
            if 'S' in user_updates:
                changes.pop('specials_notification', None)
            if 'A' in user_updates:
                for f in ('street', 'street2', 'city', 'state_id', 'zip', 'country_id'):
                    changes.pop(f, None)
        # quick and full from here
        if changes:
            changed_count += 1
            if LIST_RECORDS:
                echo('  F33:%s  %s' % (xml_id, new_record.name), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in changes.items()), '||', end='')
                echo()
            if not DRYRUN:
                res.partner.write(xml_id, new_record.id, changes)

    #
    # add new customers
    #
    print('adding company records', border='flag')
    for key, company in added_company_records.items():
        # double-check that record doesn't already exist
        customer_id = res.partner.search(domain=[('xml_id','=',key),('module','=','F33')])
        if customer_id:
            [customer_id] = customer_id
            ids[key] = customer_id
            res.partner.error('FIS ID F33:%s (%s) already exists in OpenERP' % (key, company.name))
        else:
            added_count += 1
            if LIST_RECORDS:
                echo('  F33:%s  %s' % (key, company.name), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in company.items()), '||', end='')
                echo()
            if not DRYRUN:
                customer_id = res.partner.create(key, company)
                if customer_id:
                    company.id = customer_id
                    ids[key] = customer_id
    #
    # add new contacts
    #
    print('adding contact records', border='flag')
    for key, contact in added_company_records.items():
        # double-check that record doesn't already exist
        parent_key = key[7:]
        customer_id = res.partner.search(domain=[('xml_id','=',key),('module','=','F33')])
        if customer_id:
            [customer_id] = customer_id
            ids[key] = customer_id
            res.partner.error('FIS ID F33:%s (%s) already exists in OpenERP' % (key, contact.name))
        else:
            # look for parent and get id
            contact.parent_id = ids.get(parent_key)
            if contact.parent_id is None:
                print('  looking up parent id in OpenERP')
                parent_id = res.partner.search(domain=[('xml_id','=',parent_key),('module','=','F33')])
                if parent_id:
                    contact.parent_id = parent_id[0]
                    ids[parent_key] = parent_id
                else:
                    print('  unable to find parent for %r' % key)
                    res.partner.error('unable to find parent for %r (%r)' % (key, parent_key, ))
                    continue
            added_count += 1
            if LIST_RECORDS:
                echo('  F33:%s  %s' % (key, contact.name), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in contact.items()), '||', end='')
                echo()
            if not DRYRUN:
                customer_id = res.partner.create(key, contact)
                if customer_id:
                    ids[key] = customer_id
                    contact.id = customer_id

    #
    # send email for deleted customers
    #
    print('deleting records', border='flag')
    if deleted_records:
        deleted_records = len(deleted_count)
        customer_list = ['%6s  %s' % ('FIS ID', 'Name')]
        data = []
        for datom in deleted_records:
            data.append(datom.key, datom.name)
        for rec in sorted(data, key=lambda r: r[1]):
            customer_list.append("%6s  %s" % rec)
        if DELETE and not DRYRUN:
            xml_ids = [datom.xml_id for datom in deleted_records]
            subject = 'Deleted customers  [csms, 33]'
            ids = res.partner.search([('xml_id','in',xml_ids)], context=context)
            if not res.partner.delete(ids, context=context):
                subject = "Unable to delete customers  [csms, 33]"
        else:
            subject = "customers deleted in FIS... what action in OpenERP?  [csms, 33]"
        mail(message=
                "From: FIS Integration Continuous Update <noreply@sunridgefarms.com>\n"
                # "To: Ron Giannini <rgiannini@sunridgefarms.com>\n"
                # "Cc: Emile van Sebille <emile@sunridgefarms.com>\n"
                # "Cc: Alyssa Corinne <alyssa@sunridgefarms.com>\n"
                "Cc: Ethan Furman <ethan@stoneleaf.us>\n"
                "Subject: %s\n"
                "\n" % subject
                + '\n'.join(customer_list),
                )
    print('%d records changed' % changed_count)
    print('%d records added' % added_count)
    print('%d records deleted' % deleted_count)

def handle_carrier(method):
    print('processing CNVZsv', border=('flag', '#'))
    context = {'fis-updates': True, 'active_test': False}
    res = AttrDict()
    res.partner = Model(oe.get_model('res.partner'), 'cnvzsv', 'F27', context)
    # these are for tracking original old/new records
    new_company_records = {}
    old_company_records = {}
    # these  are for tracking old/new versions of changed records
    old_changed_company_records = {}
    new_changed_company_records = {}
    # these are for added/deleted records
    added_company_records = {}
    deleted_records = {}
    # and the counts
    changed_count = 0
    added_count = 0
    deleted_count = 0
    ids = {}
    #
    # get the "old" data from:
    # - quick -> old fis file
    # - full -> current OpenERP data
    #
    cnvzsv = fisData(27, keymatch='SV10%s')
    print(cnvzsv.filename, verbose=2)
    print('gathering data', border='flag')
    if method == 'quick':
        #
        # for a quick compare we can use the fis records as-is
        #
        cnvzsv_old = fisData(27, keymatch='SV10%s', data_path=config.network.fis_data_local_old_path)
        print(cnvzsv_old.filename, verbose=2)
        print('collecting changed records')
        changes, added, deleted = get_changed_fis_records(
                cnvzsv_old.values(),
                cnvzsv.values(),
                enum_schema=[
                    F27.name, F27.tele, F27.fuel_surcharge,
                    ],
                address_fields=[
                    F27.addr1, F27.addr2, F27.addr3,
                    ],
                )
        #
        # we now have the subset of records that have changed, just need to separate them
        # into old and new
        #
        print('sorting changed records')
        for old, new, diffs in changes:
            old_company = convert_carrier_rec(old)
            old_company_records[old_company.xml_id] = old_company
            new_company = convert_carrier_rec(new)
            new_company_records[new_company.xml_id] = new_company
            # changes at the FIS level don't always translate to changes at the OpenERP level
            if old_company != new_company:
                old_changed_company_records[old_company.xml_id] = old_company
                new_changed_company_records[new_company.xml_id] = new_company
            assert set(old_changed_company_records.keys()) == set(new_changed_company_records.keys()),\
                    "old and new company records mismatch"
        #
        # and convert the new and deleted records
        #
        print('sorting new and deleted records')
        for fis_rec in added:
            company = convert_carrier_rec(fis_rec)
            new_company_records[company.xml_id] = company
            added_company_records[company.xml_id] = company
        for fis_rec in deleted:
            company = convert_carrier_rec(fis_rec)
            old_company_records[company.xml_id] = company
            deleted_records[company.xml_id] = company
    elif method == 'full':
        #
        # when doing a full compare, we have to convert every single fis record before we can
        # check for changes
        #
        all_fis_records = AttrDict()
        for fis_rec in cnvzsv.values():
            company = convert_carrier_rec(fis_rec)
            all_fis_records[company.xml_id] = company
        #
        # retrieve the OpenERP records that match the CNVZsv module
        #
        print('retrieving OpenERP records')
        all_oe_records = dict([
                (r.xml_id, r)
                for r in get_records(
                    oe, 'res.partner',
                    domain=[('module','=','F27')],
                    fields=[
                        'id', 'module', 'xml_id', 'is_carrier', 'is_company', 'use_parent_address',
                        'name', 'street', 'street2', 'city', 'state_id', 'zip', 'country_id',
                        'phone', 'fuel_surcharge', 'fis_updated_by_user',
                        ],
                    context=context,
                    )
                ])
        #
        # now we can separate into new, changed, and deleted buckets
        #
        print('sorting changed, new, and deleted carrier records')
        all_keys = set(all_fis_records.keys() + all_oe_records.keys())
        for key in all_keys:
            old_rec = all_oe_records.get(key)
            new_rec = all_fis_records.get(key)
            if old_rec is new_rec is None:
                continue
            if old_rec is None:
                added_company_records[key] = new_rec
                continue
            if new_rec is None:
                deleted_records[key] = old_rec
                continue
            # copy missing fields for proper equality testing
            new_rec.id = old_rec.id
            new_rec.fis_updated_by_user = old_rec.fis_updated_by_user
            if new_rec == old_rec:
                continue
            #
            # we have changes, save the records for later comparison
            #
            old_changed_company_records[key] = old_rec
            new_changed_company_records[key] = new_rec
        assert set(old_changed_company_records.keys()) == set(new_changed_company_records.keys()),\
                "old and new company records mismatch"
    else:
        abort('unknown METHOD: %r' % (method, ))
    #
    # at this point, all records are in AttrDict format, divided by deleted, added, and changed
    #
    # process changes
    #
    print('processing carrier changes', border='flag')
    assert set(old_changed_company_records.keys()) == set(new_changed_company_records.keys()),\
            "old/new carrier records mismatch"
    changed_company_xml_ids = sorted(old_changed_company_records.keys())
    for xml_id in changed_company_xml_ids:
        #
        # figure out the changes
        #
        old_record = old_changed_company_records[xml_id]
        new_record = new_changed_company_records[xml_id]
        assert old_record.keys() == new_record.keys(),\
                ('old/new keys mismatch\nold:%s\n%s\nnew:%s\n%s' %
                    ('|'.join(sorted(old_record.keys())), box(str(old_record)),
                     '|'.join(sorted(new_record.keys())), box(str(new_record))))
        if method == 'full':
            assert 'id' in old_record, box('id field missing for %r' % (xml_id, ))
            # check for user-updated-address and specials
            user_updates = old_record.fis_updated_by_user or ''
            if 'A' in user_updates:
                # drop all the address fields
                del old_record.use_parent_address
                del old_record.street, old_record.street2
                del old_record.city, old_record.state_id, old_record.zip, old_record.country_id
                del new_record.use_parent_address
                del new_record.street, new_record.street2
                del new_record.city, new_record.state_id, new_record.zip, new_record.country_id
            if 'N' in user_updates:
                del old_record.name
                del new_record.name
            if 'S' in user_updates:
                del old_record.specials_notification
                del new_record.specials_notification
        elif xml_id in ids:
            # maybe this xml_id has already been seen?
            new_record.id = old_record.id = ids[xml_id]
        else:
            # otherwise, we'll look it up when we check for changes against OpenERP
            pass
        changes = AttrDict()
        for key in old_record:
            if old_record[key] != new_record[key]:
                changes[key] = new_record[key]
        #
        # if this is a "full" update, we already have ids, and the changes are accurate
        # otherwise, we need to get the ids, and see if the "changes" have already been
        #   put in place on the OpenERP side
        #
        if method == 'quick':
            fields_to_check = changes.keys()
            matches = res.partner.read(
                    domain=[('xml_id','=',xml_id),('module','=','F27')],
                    fields=fields_to_check,
                    )
            if not matches:
                res.partner.error('changed company F27:%s not found in OpenERP' % xml_id)
            [match] = matches
            new_record.id = old_record.id = match.id
            ids[xml_id] = match.id
            for field in changes:
                if match[field] == changes[field]:
                    del changes[field]
            user_updates = match.fis_updated_by_user or ''
            if 'N' in user_updates:
                changes.pop('name', None)
            if 'S' in user_updates:
                changes.pop('specials_notification', None)
            if 'A' in user_updates:
                for f in ('street', 'street2', 'city', 'state_id', 'zip', 'country_id'):
                    changes.pop(f, None)
        # quick and full from here
        if changes:
            changed_count += 1
            if LIST_RECORDS:
                echo('  F27:%s  %s' % (xml_id, new_record.name), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in changes.items()), '||', end='')
                echo()
            if not DRYRUN:
                res.partner.write(xml_id, new_record.id, changes)
    #
    # now add new carriers
    #
    print('adding records', border='flag')
    for key, company in added_company_records.items():
        echo(company, border='box')
        # double-check that record doesn't already exist
        customer_id = res.partner.search(domain=[('xml_id','=',key),('module','=','F27')])
        if customer_id:
            [customer_id] = customer_id
            ids[key] = customer_id
            res.partner.error('FIS ID F27:%s (%s) already exists in OpenERP' % (key, company.name))
        else:
            added_count += 1
            if LIST_RECORDS:
                echo('  F27:%s  %s' % (key, company.name), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in company.items()), '||', end='')
                echo()
            if not DRYRUN:
                customer_id = res.partner.create(key, company)
                if customer_id:
                    company.id = customer_id
                    ids[key] = customer_id
    #
    # send email for deleted carriers
    #
    print('deleting records', border='flag')
    if deleted_records:
        deleted_records = len(deleted_count)
        customer_list = ['%6s  %s' % ('FIS ID', 'Name')]
        data = []
        for datom in deleted_records:
            data.append(datom.key, datom.name)
        for rec in sorted(data, key=lambda r: r[1]):
            customer_list.append("%6s  %s" % rec)
        if DELETE and not DRYRUN:
            xml_ids = [datom.xml_id for datom in deleted_records]
            subject = 'Deleted customers  [cnvzsv, 27]'
            ids = res.partner.search([('xml_id','in',xml_ids)], context=context)
            if not res.partner.delete(ids, context=context):
                subject = "Unable to delete customers  [cnvzsv, 27]"
        else:
            subject = "customers deleted in FIS... what action in OpenERP?  [cnvzsv, 27]"
        mail(message=
                "From: FIS Integration Continuous Update <noreply@sunridgefarms.com>\n"
                # "To: Ron Giannini <rgiannini@sunridgefarms.com>\n"
                # "Cc: Emile van Sebille <emile@sunridgefarms.com>\n"
                # "Cc: Alyssa Corinne <alyssa@sunridgefarms.com>\n"
                "Cc: Ethan Furman <ethan@stoneleaf.us>\n"
                "Subject: %s\n"
                "\n" % subject
                + '\n'.join(customer_list),
                )
    print('%d records changed' % changed_count)
    print('%d records added' % added_count)
    print('%d records deleted' % deleted_count)

def handle_emp1(method):
    print('processing EMP1', border='#')
    print(emp1.filename, verbose=2)
    context = {'hr_welcome': False, 'fis-updates': True, 'active_test': False}
    # today = Date.today()
    hr = AttrDict()
    hr.employee = Model(oe.get_model('hr.employee'), 'emp1', 'F74-emp', context)
    res = AttrDict()
    res.partner = Model(oe.get_model('res.partner'), 'emp1', 'F74', context)
    # these are for tracking original old/new records
    new_employee_records = {}
    old_employee_records = {}
    # these  are for tracking old/new versions of changed records
    old_changed_employee_records = {}
    new_changed_employee_records = {}
    # these are for added/deleted records
    added_employee_records = {}
    deleted_records = {}
    # and counts and tests
    changed_count = 0
    added_count = 0
    deleted_count = 0
    ids = {}
    active_test_needed = set()
    # birthday_test_needed = set()
    #
    # get the "old" data from:
    # - quick -> old fis file
    # - full -> current OpenERP data
    #
    print('gathering data', border='lined')
    if method == 'quick':
        #
        # for a quick compare we can use the fis records as-is
        #
        emp1_old = fisData(74, keymatch='10%s', data_path=config.network.fis_data_local_old_path)
        print(emp1_old.filename, verbose=2)
        print('collecting changed records')
        changes, added, deleted = get_changed_fis_records(
                emp1_old.values(),
                emp1.values(),
                enum_schema=[
                    F74.name, F74.ssn, F74.tele, F74.date_hired, F74.date_terminated,
                    F74.birth_date, F74.last_raise, F74.status_flag, F74.pay_type,
                    F74.marital_status, F74.pension_status, F74.gender, F74.emergency_contact,
                    F74.emergency_phone, F74.exempt_fed, F74.exempt_state, F74.hourly_rate,
                    ],
                address_fields=[
                    F74.addr1, F74.addr2, F74.addr3,
                    ],
                ignore=lambda r: int(r[F74.emp_num]) >= 9000,
                )
        #
        # we now have the subset of records that have changed, just need to separate them
        # into old and new
        #
        print('sorting changed records')
        for old, new, diffs in changes:
            old_employee = convert_emp1_rec(old)
            old_employee_records[old_employee.xml_id] = old_employee
            new_employee = convert_emp1_rec(new)
            new_employee_records[new_employee.xml_id] = new_employee
            # changes at the FIS level don't always translate to changes at the OpenERP level
            if old_employee != new_employee:
                old_changed_employee_records[old_employee.xml_id] = old_employee
                new_changed_employee_records[new_employee.xml_id] = new_employee
            assert set(old_changed_employee_records.keys()) == set(new_changed_employee_records.keys()),\
                    "old and new employee records mismatch"
        #
        # and convert the new and deleted records
        #
        print('sorting new and deleted records')
        for fis_rec in added:
            employee = convert_emp1_rec(fis_rec)
            new_employee_records[employee.xml_id] = employee
            added_employee_records[employee.xml_id] = employee
        for fis_rec in deleted:
            employee = convert_emp1_rec(fis_rec)
            old_employee_records[employee.xml_id] = employee
            deleted_records[employee.xml_id] = employee
    elif method == 'full':
        #
        # when doing a full compare, we have to convert every single fis record before we can
        # check for changes
        #
        all_fis_records = AttrDict()
        for fis_rec in emp1.values():
            employee = convert_emp1_rec(fis_rec)
            if employee is None:
                # print('skipping %r' % (fis_rec[F74.emp_num], ))
                continue
            all_fis_records[employee.xml_id] = employee
        #
        # retrieve the OpenERP records that match the CNVZsv module
        #
        print('retrieving OpenERP records')
        all_oe_records = dict([
                (r.xml_id, r)
                for r in get_records(
                    oe, 'hr.employee',
                    domain=[('module','=','F74-emp')],
                    fields=[
                        'id', 'module', 'xml_id', 'name', 'employment_type', 'ssnid', 'home_phone',
                        'home_street', 'home_street2', 'home_city', 'home_state_id', 'home_zip', 'home_country_id',
                        'hire_date', 'fire_date', 'active', 'status_flag', 'pension_plan',
                        'pay_type', 'hourly_rate', 'last_raise', 'marital', 'gender', 'identification_id',
                        'emergency_contact', 'emergency_number', 'state_exemptions', 'federal_exemptions',
                        ],
                    context=context,
                    )
                ])
        #
        # now we can separate into new, changed, and deleted buckets
        #
        print('sorting changed, new, and deleted emp1 records')
        all_keys = set(all_fis_records.keys() + all_oe_records.keys())
        for key in all_keys:
            old_rec = all_oe_records.get(key)
            new_rec = all_fis_records.get(key)
            if old_rec is new_rec is None:
                continue
            if old_rec is None:
                added_employee_records[key] = new_rec
                continue
            if new_rec is None:
                deleted_records[key] = old_rec
                continue
            # copy missing fields for proper equality testing
            new_rec.id = old_rec.id
            if new_rec == old_rec:
                continue
            #
            # we have changes, save the records for later comparison
            #
            old_changed_employee_records[key] = old_rec
            new_changed_employee_records[key] = new_rec
        assert set(old_changed_employee_records.keys()) == set(new_changed_employee_records.keys()),\
                "old and new employee records mismatch"
    else:
        abort('unknown METHOD: %r' % (method, ))
    #
    # at this point, all records are in AttrDict format, divided by deleted, added, and changed
    #
    # process changes
    #
    print('processing emp1 changes', border='lined')
    assert set(old_changed_employee_records.keys()) == set(new_changed_employee_records.keys()),\
            "old/new emp1 records mismatch"
    changed_employee_xml_ids = sorted(old_changed_employee_records.keys())
    for xml_id in changed_employee_xml_ids:
        #
        # figure out the changes
        #
        old_record = old_changed_employee_records[xml_id]
        new_record = new_changed_employee_records[xml_id]
        assert old_record.keys() == new_record.keys(),\
                ('old/new keys mismatch\nold:%s\n%s\nnew:%s\n%s' %
                    ('|'.join(sorted(old_record.keys())), box(str(old_record)),
                     '|'.join(sorted(new_record.keys())), box(str(new_record))))
        if method == 'full':
            assert 'id' in old_record, box('id field missing for %r' % (xml_id, ))
        elif xml_id in ids:
            # maybe this xml_id has already been seen?
            new_record.id = old_record.id = ids[xml_id]
        else:
            # otherwise, we'll look it up when we check for changes against OpenERP
            pass
        changes = AttrDict()
        for key in old_record:
            if old_record[key] != new_record[key]:
                changes[key] = new_record[key]
        #
        # if this is a "full" update, we already have ids, and the changes are accurate
        # otherwise, we need to get the ids, and see if the "changes" have already been
        #   put in place on the OpenERP side
        #
        if method == 'quick':
            fields_to_check = changes.keys()
            matches = hr.employee.read(
                    domain=[('xml_id','=',xml_id),('module','=','F74-emp')],
                    fields=fields_to_check,
                    )
            if not matches:
                hr.employee.error('changed employee F74-emp:%s not found in OpenERP' % xml_id)
                continue
            print(matches, border='box')
            [match] = matches
            new_record.id = old_record.id = match.id
            ids[xml_id] = match.id
            for field in changes:
                if match[field] == changes[field]:
                    del changes[field]
        # quick and full from here
        if changes:
            changed_count += 1
            if LIST_RECORDS:
                echo('  F74-emp:%s  %s' % (xml_id, new_record.name), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in changes.items()), '||', end='')
                echo()
            if not DRYRUN:
                hr.employee.write(xml_id, new_record.id, changes)
    #
    # now add new employees
    #
    print('adding records', border='lined')
    for key, employee in added_employee_records.items():
        # double-check that record doesn't already exist
        employee_id = hr.employee.search(domain=[('xml_id','=',key),('module','=','F74-emp')])
        if employee_id:
            [employee_id] = employee_id
            ids[key] = employee_id
            hr.employee.error('FIS ID F74-emp:%s (%s) already exists in OpenERP' % (key, employee.name))
        else:
            added_count += 1
            if LIST_RECORDS:
                echo('  F74-emp:%s  %s' % (key, employee.name), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in employee.items()), '||', end='')
                echo()
            if not DRYRUN:
                employee_id = hr.employee.create(key, employee)
                if not employee_id:
                    continue
                employee.id = employee_id
                ids[key] = employee_id
                # check for existing res.partner record, and use it if it exists
                emp_num = employee.xml_id
                emp_name = employee.name
                rp_id = hr.employee.search(domain=[('module','=','F74'),('xml_id','=',emp_num)])
                if rp_id:
                    # update res.partner record with employee link
                    rp_id = rp_id[0]
                    res.partner.write(emp_num, rp_id, {'employee_id': employee_id})
                else:
                    # otherwise, try to create it, leaving it at False (0) on failure
                    rp_id = res.partner.create(
                            emp_num,
                            {'name': emp_name, 'xml_id': emp_num, 'module': 'F74', 'employee_id': employee_id},
                            )


    #
    # send email for deleted employees
    #
    if deleted_records:
        deleted_count = len(deleted_records)
        employee_list = ['%6s  %-11s  %-11s  %s' % ('Emp. #', 'Start Date', 'End Date', 'Employee Name')]
        data = []
        for emp_num, datom in deleted_records.items():
            name = NameCaseReversed(datom.name)
            date_hired = datom.hire_date or ''
            date_terminated = datom.fire_date or ''
            data.append((emp_num, date_hired, date_terminated, name))
        for rec in sorted(data, key=lambda r: r[3]):
            employee_list.append("%6s  %-11s  %-11s  %s" % rec)
        if DELETE and not DRYRUN:
            xml_ids = [datom.xml_id for datom in deleted_records]
            subject = 'Deleted employees  [emp1, 74]'
            ids = hr.employee.search([('xml_id','in',xml_ids)], context=context)
            if not hr.employee.delete(ids, context=context):
                subject = "Unable to delete employees  [emp1, 74]"
        else:
            subject = "employees deleted in FIS... what action in OpenERP?  [emp1, 74]"
        mail(message=
                "From: FIS Integration Continuous Update <noreply@sunridgefarms.com>\n"
                # "To: Ron Giannini <rgiannini@sunridgefarms.com>\n"
                # "Cc: Emile van Sebille <emile@sunridgefarms.com>\n"
                # "Cc: Alyssa Corinne <alyssa@sunridgefarms.com>\n"
                "Cc: Ethan Furman <ethan@stoneleaf.us>\n"
                "Subject: %s\n"
                "\n" % subject
                + '\n'.join(employee_list),
                )
    #
    # check for suspect birthdates
    #
    # if birthday_test_needed:
    #     underage = today.replace(delta_year=-18).strftime(DEFAULT_SERVER_DATE_FORMAT)
    #     overage = today.replace(delta_year=+65).strftime(DEFAULT_SERVER_DATE_FORMAT)
    #     bad_birthdays = hr.employee.read(
    #             domain=[('id','in',list(birthday_test_needed)),'|',('birthday','<',underage),('birthday','>',overage)],
    #             fields=['id', 'birthday', 'name', 'xml_id'],
    #             )
    #     if bad_birthdays:
    #         employee_list = []
    #         for rec in bad_birthdays:
    #             rec.name = NameCaseReversed(rec.name)
    #             rec.birthday = Date.strptime(rec.birthday, DEFAULT_SERVER_DATE_FORMAT)#.strftime('%d-%b-%Y')
    #         for rec in sorted(bad_birthdays, key=lambda r: r.name):
    #             employee_list.append("%5s:  %s - %s" % (rec.xml_id, rec.birthday, rec.name))
    #         mail(message=
    #                 "From: FIS Integration Continuous Update <noreply@sunridgefarms.com>\n"
    #                 # "To: Ron Giannini <rgiannini@sunridgefarms.com>\n"
    #                 # "Cc: Emile van Sebille <emile@sunridgefarms.com>\n"
    #                 # "Cc: Alyssa Corinne <alyssa@sunridgefarms.com>\n"
    #                 "Cc: Ethan Furman <ethan@stoneleaf.us>\n"
    #                 "Subject: employees with suspect birthdates in FIS [emp1, 74]\n"
    #                 "\n"
    #                 + '\n'.join(employee_list),
    #                 )
    #
    # check for (in)active records
    #
    if active_test_needed:
        active_test = hr.employee.read(
                domain=[('id','in',list(active_test_needed))],
                fields=['id', 'hire_date', 'fire_date','xml_id'],
                )
        active = []
        active_keys = []
        inactive = []
        inactive_keys = []
        for rec in active_test:
            if not rec.fire_date:
                active.append(rec.id)
                active_keys.append(rec.xml_id)
            elif rec.fire_date < rec.hire_date:
                active.append(rec.id)
                active_keys.append(rec.xml_id)
            else:
                inactive.append(rec.id)
                inactive_keys.append(rec.xml_id)
        if active:
            print('setting %d records active' % len(active_keys))
            if not DRYRUN:
                hr.employee.write(active_keys, active, {'active': True})
        if inactive:
            print('setting %d records inactive' % len(inactive_keys))
            if not DRYRUN:
                hr.employee.write(inactive_keys, inactive, {'active': False})
    print(
            '%d records changed\n%d records added\n%d records (maybe) deleted'
                % (changed_count, added_count, deleted_count),
            border='box',
            )


def handle_posm(method):
    print('processing POSM')
    print(posm.filename, verbose=2)
    context = {'fis-updates': True, 'active_test': False}
    res = AttrDict()
    res.partner = Model(oe.get_model('res.partner'), 'posm', 'F163', context)
    if method == 'quick':
        posm_old = fisData(163, keymatch='10%s', data_path=config.network.fis_data_local_old_path)
    changed_records = 0
    changes, added, deleted = get_changed_fis_records(
            posm_old.values(),
            posm.values(),
            enum_schema=[
                F163.name, F163.tele, F163.fax, F163.vendor, F163.org_cert_file,
                F163.non_gmo, F163.kosher, F163.cert_exp, F163.gmo_exp, F163.kosher_exp,
                ],
            address_fields=[
                F163.addr1, F163.addr2, F163.addr3,
                ],
            ignore=is_invalid_posm_record,
            )
    print('\n%d changes; %d additions; %d deletions' % (len(changes), len(added), len(deleted)))
    changed_map = combine_by_value(F163, changes)
    print('--== PROCESSING CHANGES ==--')
    for changed_fields, records in sorted(changed_map.items()):
        print('\n---- changed fields ----\n', changed_fields, verbose=2)
        # get ids for existing records
        keys = [r[F163.code].strip() for r in records]
        oe_ids = res.partner.search(domain=[('module','=','F163'),('xml_id','in',keys)])
        if not oe_ids:
            # unable to find these "changed" records in OpenERP -- log, and move records
            # to the add queue
            for rec in records:
                res.partner.error('changed record F163:%s not found not found in OpenERP' % rec[F163.code])
            continue
        # changed_fields = (field_enum, new_value, field_enum, new_value, ...)
        #
        # create values update dict for OpenERP
        values = {}
        address_done = False
        sample_rec = records[0]
        for field, value in grouped(changed_fields, 2):
            if field is F163.name:
                values['name'] = re.sub('sunridge', 'SunRidge', BsnsCase(value), flags=re.I)
            elif field in (F163.addr1, F163.addr2, F163.addr3):
                if address_done is True:
                    continue
                address_done = True
                values.update(process_address(F163, sample_rec, key=sample_rec[F163.code], module='posm'))
            elif field is F163.tele:
                values['phone'] = fix_phone(value)
            elif field is F163.fax:
                values['fax'] = fix_phone(value)
            elif field is F163.vendor:
                for rec in records:
                    vendor_suppliers.add(F163.code)
            elif field is F163.org_cert_file:
                values['fis_org_cert_file'] = value.upper() in 'YO'
            elif field is F163.non_gmo:
                values['fis_non_gmo'] = value.upper() in 'Y'
            elif field is F163.kosher:
                values['fis_kosher'] = value.upper() in 'Y'
            elif field is F163.cert_exp:
                values['fis_org_exp'] = fix_date(value)
            elif field is F163.gmo_exp:
                values['fis_gmo_exp'] = fix_date(value)
            elif field is F163.kosher_exp:
                values['fis_kosher_exp'] = fix_date(value)
        # and update OpenERP
        assert values, "no changed fields?  problem with get_changed_fis_records or combine by value?"
        changed_records += len(records)
        res.partner.write(keys, oe_ids, values)
    #
    # add new records
    #
    print('--== ADDING RECORDS ==--')
    for sup_rec in added:
        print('\nadding:', sup_rec, sep='\n', verbose=2)
        values = {'active': True}
        # valid supplier code? active account?
        values['xml_id'] = key = sup_rec[F163.code]
        values['module'] = 'F163'
        values['fis_valid'] = True
        values['name'] = sup_name = re.sub('sunridge', 'SunRidge', BsnsCase(sup_rec[F163.name]), flags=re.I)
        values['is_company'] = True
        values['supplier'] = True
        values['customer'] = False
        values['use_parent_address'] = False
        values.update(process_address(F163, sup_rec, key=sup_rec[F163.code], module='posm'))
        values['phone'] = fix_phone(sup_rec[F163.tele])
        values['fax'] = fix_phone(sup_rec[F163.fax])
        values['fis_org_cert_file'] = sup_rec[F163.org_cert_file] in 'YO'
        values['fis_org_exp'] = fix_date(sup_rec[F163.cert_exp])
        values['fis_non_gmo'] = sup_rec[F163.non_gmo] in 'Y'
        values['fis_gmo_exp'] = fix_date(sup_rec[F163.gmo_exp])
        values['fis_kosher'] = sup_rec[F163.kosher] in 'Y'
        values['fis_kosher_exp'] = fix_date(sup_rec[F163.kosher_exp])
        # double-check that record doesn't already exist
        if res.partner.search(domain=[('xml_id','=',key),('module','=','F163')]):
            res.partner.error('FIS ID F163:%s (%s) already exists in OpenERP' % (key, sup_name))
        else:
            res.partner.create(key, values)
    #
    # send email for deleted suppliers
    #
    if deleted:
        supplier_list = ['%6s  %s' % ('FIS ID', 'Name')]
        data = []
        for rec in deleted:
            xml_id = rec[F163.code]
            name = BsnsCase(rec[F163.name])
            data.append((xml_id, name))
        for rec in sorted(data, key=lambda r: r[1]):
            supplier_list.append("%6s  %s" % rec)
        mail(message=
                "From: FIS Integration Continuous Update <noreply@sunridgefarms.com>\n"
                # "To: Ron Giannini <rgiannini@sunridgefarms.com>\n"
                # "Cc: Emile van Sebille <emile@sunridgefarms.com>\n"
                # "Cc: Alyssa Corinne <alyssa@sunridgefarms.com>\n"
                "Cc: Ethan Furman <ethan@stoneleaf.us>\n"
                "Subject: suppliers deleted in FIS... what action in OpenERP?  [posm, 163]\n"
                "\n"
                + '\n'.join(supplier_list),
                )


def handle_vnms(method):
    print('processing VNMS')
    print(vnms.filename, verbose=2)
    context = {'fis-updates': True, 'active_test': False}
    res = AttrDict()
    res.partner = Model(oe.get_model('res.partner'), 'vnms', 'F65', context)
    changed_records = 0
    if method == 'quick':
        vnms_old = fisData(65, keymatch='10%s', data_path=config.network.fis_data_local_old_path)
    if not ven2sup:
        # posm not processed on this invocation, run through those
        # records now
        for rec in posm.values():
            is_invalid_posm_record(rec)
    def is_invalid_vnms(rec):
        xml_id = rec[F65.code]
        name = rec[F65.name]
        if (
                len(xml_id) == 6
                and xml_id.isdigit()
                and name
            ):
            # valid record
            return False
        # invalid record
        return True
    changes, added, deleted = get_changed_fis_records(
            vnms_old.values(),
            vnms.values(),
            enum_schema=[
                F65.name, F65.tele, F65.fax, F65.contact,
                F65.org_cert, F65.org_cert_file, F65.cert_exp,
                ],
            address_fields=[
                F65.addr1, F65.addr2, F65.addr3,
                ],
            ignore=is_invalid_vnms
            )
    changed_map = combine_by_value(F65, changes)
    print('--== PROCESSING CHANGES ==--')
    for changed_fields, records in sorted(changed_map.items()):
        print('changed fields:', changed_fields, verbose=2)
        # get ids for existing records
        keys = [r[F65.code].strip() for r in records]
        oe_ids = res.partner.search(domain=[('module','=','F65'),('xml_id','in',keys)])
        if not oe_ids:
            # unable to find these "changed" records in OpenERP -- log, and move records
            # to the add queue
            for rec in records:
                res.partner.error('changed record F65:%s not found in OpenERP' % rec[F65.code])
                continue
        # changed_fields = (field_enum, new_value, field_enum, new_value, ...)
        for oe_id, rec in zip(oe_ids, records):
            # create values update dict for OpenERP
            values = {}
            contact_only = {}
            address_done = False
            key = rec[F65.code]
            sup_xml_id = ven2sup.get(key)
            is_contact = sup_xml_id is not None
            if is_contact:
                sup_rec = posm[sup_xml_id]
                sup_rec_oe_id = res.partner.search(domain=[('xml_id','=',sup_xml_id),('module','=','F163')])
                if sup_rec_oe_id:
                    sup_rec_oe_id = sup_rec_oe_id[0]
                else:
                    sup_rec_oe_id = False
                values['is_company'] = False
                values['use_parent_address'] = True
            else:
                values['is_company'] = True
                values['use_parent_address'] = False
            for field, value in grouped(changed_fields, 2):
                if field is F65.name and not is_contact:
                    values['name'] = re.sub('sunridge', 'SunRidge', BsnsCase(records[0][F65.name]), flags=re.I)
                elif field is F65.contact and is_contact:
                    values['name'] = BsnsCase(value)
                elif field is F65.contact:
                    # save for updating later
                    contact_only['name'] = NameCase(value)
                    contact_only['parent_id'] = oe_id
                    contact_only['use_parent_address'] = True
                    contact_only['xml_id'] = 'cntct_%s' % key
                    contact_only['module'] = 'F65'
                elif field in (F65.addr1, F65.addr2, F65.addr3):
                    if address_done is True:
                        continue
                    address_done = True
                    vendor_address = process_address(F65, rec, key=rec[F163.code], module='vnms')
                    supplier_address = {}
                    if is_contact:
                        supplier_address = process_address(F163, sup_rec)
                    # is this vendor address different from the supplier's?
                    if vendor_address != supplier_address:
                        values['use_parent_address'] = False
                        values.update(vendor_address)
                elif field is F65.tele:
                    values['phone'] = fix_phone(value)
                elif field is F65.fax:
                    values['fax'] = fix_phone(value)
                if is_contact:
                    values['parent_id'] = sup_rec_oe_id
                    values['fis_org_cert'] = False
                    values['fis_org_cert_file'] = False
                    values['fis_cert_exp'] = False
                else:
                    values['parent_id'] = False
                    if field is F65.org_cert:
                        values['fis_org_cert'] = value.upper() in 'Y'
                    elif field is F65.org_cert_file:
                        values['fis_org_cert_file'] = value.upper() in 'Y'
                    elif field is F65.cert_exp:
                        values['fis_org_exp'] = fix_date(value)
            # and update OpenERP
            if values:
                changed_records += 1
                res.partner.write(key, oe_id, values)
            if contact_only:
                # get contact id and update
                contact_id = res.partner.search(
                        domain=[('xml_id','=',contact_only['xml_id']),('module','=','F65')],
                        )
                contact_id = contact_id and contact_id[0] or False
                changed_records += 1
                res.partner.write(key, contact_id, contact_only)
    #
    # add new records
    #
    print('--== ADDING RECORDS ==--')
    for ven_rec in added:
        print('\nadding:', ven_rec, sep='\n', verbose=2)
        values = {'active': True}
        # valid supplier code? active account?
        values['xml_id'] = key = ven_rec[F65.code]
        values['module'] = 'F65'
        values['fis_valid'] = True
        values['supplier'] = True
        values['customer'] = False
        sup_xml_id = ven2sup.get(key)
        is_contact = sup_xml_id is not None
        contact_only = {}
        if is_contact:
            sup_rec = posm[sup_xml_id]
            sup_rec_oe_id = res.partner.search(domain=[('xml_id','=',sup_xml_id),('module','=','F163')])
            sup_rec_oe_id = sup_rec_oe_id and sup_rec_oe_id[0] or False
            values['parent_id'] = sup_rec_oe_id
            values['is_company'] = False
            values['use_parent_address'] = True
            values['name'] = ven_name = NameCase(ven_rec[F65.contact]) or BsnsCase(ven_rec[F65.name])
            contact_phone = fix_phone(ven_rec[F65.tele])
            if contact_phone != fix_phone(sup_rec[F163.tele]):
                values['phone'] = contact_phone
            fax_phone = fix_phone(ven_rec[F65.fax])
            if fax_phone != fix_phone(sup_rec[F163.fax]):
                values['fax'] = fax_phone
        else:
            values['parent_id'] = False
            values['is_company'] = True
            values['use_parent_address'] = False
            values['name'] = ven_name = re.sub('sunridge', 'SunRidge', BsnsCase(ven_rec[F65.name]), flags=re.I)
            values['phone'] = fix_phone(ven_rec[F65.tele])
            values['fax'] = fix_phone(ven_rec[F65.fax])
            values['fis_org_cert'] = ven_rec[F65.org_cert] in 'Y'
            values['fis_org_cert_file'] = ven_rec[F65.org_cert_file] in 'Y'
            values['fis_org_exp'] = fix_date(ven_rec[F65.cert_exp])
            contact_name = NameCase(ven_rec[F65.contact])
            if contact_name:
                contact_only['name'] = cntct_name = contact_name
                contact_only['use_parent_address'] = True
                contact_only['xml_id'] = cntct_key = 'cntct_%s' % key
                contact_only['module'] = 'F65'
        # figure out which address to use (contact? different from supplier?)
        vendor_address = process_address(F65, ven_rec, key=ven_rec[F163.code], module='vnms')
        supplier_address = {}
        if is_contact:
            supplier_address = process_address(F163, sup_rec)
        # is this vendor address different from the supplier's?
        if vendor_address != supplier_address:
            # this is correct for both vendor-is-company and vendor-is-contact-with-different-address
            values['use_parent_address'] = False
            values.update(vendor_address)
        oe_id = res.partner.search(domain=[('xml_id','=',key),('module','=','F65')])
        if oe_id:
            oe_id = oe_id[0]
            res.partner.error('FIS ID F65:%s (%s) already exists in OpenERP' % (key, ven_name))
        else:
            oe_id = res.partner.create(key, values)
            if not oe_id:
                continue
        if contact_only:
            contact_only['parent_id'] = oe_id
            if res.partner.search(domain=[('xml_id','=',cntct_key),('module','=','F65')]):
                res.partner.error('FIS ID F65:%s (%s) already exists in OpenERP' % (cntct_key, cntct_name))
            else:
                res.partner.create(key, contact_only)
    #
    # send email for deleted vendors
    #
    if deleted:
        vendor_list = ['%6s  %s' % ('FIS ID', 'Name')]
        data = []
        for rec in deleted:
            xml_id = rec[F65.code]
            name = BsnsCase(rec[F65.name])
            data.append(xml_id, name)
        for rec in sorted(data, key=lambda r: r[1]):
            vendor_list.append("%6s  %s" % rec)
        mail(message=
                "From: FIS Integration Continuous Update <noreply@sunridgefarms.com>\n"
                # "To: Ron Giannini <rgiannini@sunridgefarms.com>\n"
                # "Cc: Emile van Sebille <emile@sunridgefarms.com>\n"
                # "Cc: Alyssa Corinne <alyssa@sunridgefarms.com>\n"
                "Cc: Ethan Furman <ethan@stoneleaf.us>\n"
                "Subject: vendors deleted in FIS... what action in OpenERP?  [vnms, 65]\n"
                "\n"
                + '\n'.join(vendor_list),
                )

def convert_emp1_rec(fis_rec):
    employee = AttrDict()
    employee.name = re.sub('sunridge', 'SunRidge', NameCase(fis_rec[F74.name]), flags=re.I)
    employee.xml_id = employee.identification_id = emp_num = fis_rec[F74.emp_num].strip()
    employee.module = 'F74-emp'
    try:
        if int(emp_num) >= 9000:
            return None
    except (ValueError, TypeError):
        return None
    employee.employment_type = 'standard'
    employee.update(process_address(F74, fis_rec, key=fis_rec[F74.emp_num], module='emp1', home=True))
    employee.home_phone = fix_phone(fis_rec[F74.tele])
    ssn = fis_rec[F74.ssn]
    if len(ssn) == 9:
        ssn = '%s-%s-%s' % (ssn[:3], ssn[3:5], ssn[5:])
    employee.ssnid = ssn
    hired = fix_date(fis_rec[F74.date_hired])
    employee.hire_date = hired and hired.strftime('%Y-%m-%d') or False
    fired = fix_date(fis_rec[F74.date_terminated])
    employee.fire_date = fired and fired.strftime('%Y-%m-%d') or False
    employee.active = (not fired or hired > fired)
    # emp_birthday = fix_date(fis_rec[F74.birth_date])
    # employee.birthday = emp_birthday and emp_birthday.strftime('%Y-%m-%d') or False
    employee.status_flag = fis_rec[F74.status_flag]
    employee.pension_plan = fis_rec[F74.pension_status].upper() == 'Y'
    employee.pay_type = ('salary', 'hourly')[fis_rec[F74.pay_type].upper() == 'H']
    employee.hourly_rate = fis_rec[F74.hourly_rate]
    last_raise = fix_date(fis_rec[F74.last_raise])
    employee.last_raise = last_raise and last_raise.strftime('%Y-%m-%d') or False
    employee.marital = ('single', 'married')[fis_rec[F74.marital_status].upper() == 'M']
    employee.gender = ('male', 'female')[fis_rec[F74.gender].upper() == 'F']
    employee.emergency_contact = NameCase(fis_rec[F74.emergency_contact])
    employee.emergency_number = fix_phone(fis_rec[F74.emergency_phone])
    employee.federal_exemptions = int(fis_rec[F74.exempt_fed] or 0)
    employee.state_exemptions = int(fis_rec[F74.exempt_state] or 0)
    return employee

def convert_carrier_rec(fis_rec):
    company = AttrDict()
    company.name = re.sub('sunridge', 'SunRidge', BsnsCase(fis_rec[F27.name]), flags=re.I)
    company.xml_id = key = fis_rec[F27.code].strip()
    company.module = 'F27'
    company.is_company = True
    company.is_carrier = True
    company.use_parent_address = False
    if key == '99':
        company.name = '____________'
    company.update(process_address(F27, fis_rec, key=key, module='cnvzsv'))
    company.phone = fis_rec[F27.tele]
    company.fuel_surcharge = fis_rec[F27.fuel_surcharge].upper() == 'Y'
    return company

def convert_csms_rec(fis_rec):
    #
    # creates an AttrDict with the following fields
    # - 'module', 'xml_id',
    # - 'name', 'street', 'street2', 'city', 'state_id', 'zip', 'country_id',
    # - 'fis_valid', 'specials_notification', 'phone', 'is_company', 'customer',
    # - 'use_parent_address', 'active'
    #
    # fields coming from OpenERP that are missing/invalid on the FIS side
    # - 'id', 'fis_updated_by_user'
    # - address fields (for contact)
    #
    # fis records use the following fields to detect changes
    #
    # enum_schema=[
    #     F33.name, F33.salesrep, F33.catalog_category, F33.this_year_sales,
    #     F33.last_year_sales, F33.tele, F33.contact,
    #     ],
    # address_fields=[
    #     F33.addr1, F33.addr2, F33.addr3,
    #     ],
    #
    company = AttrDict()
    # TODO: get salesrep working
    # rep = cus_rec[F33.salesrep]
    # rep = sales_people.get(rep, False)
    company.module = 'F33'
    company.xml_id = key = fis_rec[F33.code]
    company.name = re.sub('sunridge', 'SunRidge', BsnsCase(fis_rec[F33.name]), flags=re.I)
    company.is_company = True
    company.customer = True
    company.use_parent_address = False
    # valid customer code? active account?
    company.fis_valid = len(key) == 5
    company.active = False
    if (
            fis_rec[F33.this_year_sales]
         or fis_rec[F33.last_year_sales]
        ):
        company.active = True
    else:
        # TODO check for open orders
        pass
    notify_by = Specials.get_member(fis_rec[F33.catalog_category].upper(), Specials.neither)
    company.specials_notification = notify_by.value
    company.update(process_address(F33, fis_rec, key=fis_rec[F33.code], module='csms'))
    company.phone = fix_phone(fis_rec[F33.tele])
    contact = None
    if fis_rec[F33.contact] and fis_rec[F33.contact] != fis_rec[F33.name]:
        contact = AttrDict()
        contact.name = NameCase(fis_rec[F33.contact])
        contact.xml_id = 'cntct_' + key
        contact.module = 'F33'
        contact.is_company = False
        contact.customer = True
        contact.use_parent_address = True
        contact.specials_notification = Specials.company
        contact.fis_valid = company.fis_valid
        contact.active = company.active
    return company, contact

_raise_lookup = object()
class Specials(str, Enum):
    _order_ = 'neither catalog specials both default'
    neither   = 'N'
    catalog   = 'C'
    specials  = 'S'
    both      = 'B'
    default   = 'D'
    company   = default
    @classmethod
    def get_member(cls, text, default=_raise_lookup):
        for member in cls:
            if member.value == text:
                return member
        else:
            if default is not _raise_lookup:
                return default
        raise LookupError('%r not found in %s' % (text, cls.__name__))

def pfm(values):
    "prepare values dict for marshalling"
    result = {}
    for k, v in values.items():
        if v is None:
            result[k] = False
        elif isinstance(v, Date):
            result[k] = v.strftime(DEFAULT_SERVER_DATE_FORMAT)
        elif isinstance(v, Many2One):
            result[k] = v.id
        elif isinstance(v, PostalCode):
            result[k] = v.code
        elif isinstance(v, Enum):
            result[k] = v.value
        else:
            result[k] = v
    return result

def process_address(schema, fis_rec, key=None, module=None, home=False):
    if module is not None and key is None:
        raise ValueError('module specified but key was not')
    result = {}
    addr1, addr2, addr3 = Sift(fis_rec[schema.addr1], fis_rec[schema.addr2], fis_rec[schema.addr3])
    addr2, city, state, postal, country = cszk(addr2, addr3)
    addr3 = ''
    addr1 = normalize_address(addr1)
    addr2 = normalize_address(addr2)
    addr1, addr2 = AddrCase(Rise(addr1, addr2))
    city = NameCase(city)
    state, country = NameCase(state), NameCase(country)
    valid_address = True
    if (
            not (addr1 or addr2)
            or not (city or state or country)
        ):
        # just use the FIS data without processing
        addr1, addr2, city = Rise(fis_rec[schema.addr1], fis_rec[schema.addr2], fis_rec[schema.addr3])
        state = country = ''
        postal = PostalCode('', '')
        valid_address = False
    if home:
        sf = 'home_street'
        s2f = 'home_street2'
        cf = 'home_city'
        sidf = 'home_state_id'
        zf = 'home_zip'
        kidf = 'home_country_id'
    else:
        sf = 'street'
        s2f = 'street2'
        cf = 'city'
        sidf = 'state_id'
        zf = 'zip'
        kidf = 'country_id'
    result[sf] = addr1
    result[s2f] = addr2
    result[cf] = city
    result[zf] = postal
    result[sidf] = False
    result[kidf] = False
    if valid_address:
        if state:
            result[sidf] = state_recs[state][0]
            result[kidf] = country = state_recs[state][2]
        elif country:
            country_id = country_recs.get(country, False)
            if country_id is False:
                if module is not None:
                    Model.errors[module].append("%s record %s has invalid country <%r>" % (module, key, country))
            else:
                result[kidf] = country_id
    return result

def is_invalid_posm_record(rec):
    if rec is None:
        return True
    xml_id = rec[F163.code]
    name = rec[F163.name]
    vendor_xml_id = rec[F163.vendor]
    vendor_rec = vnms.get(vendor_xml_id)
    if (
            len(xml_id) == 6
            and xml_id.isdigit()
            and name
            and len(vendor_xml_id) == 6
            and vendor_xml_id.isdigit()
            and vendor_rec is not None
        ):
        # valid record, record vendor mapping
        ven2sup[vendor_xml_id] = xml_id
        return False
    # invalid record
    return True

def is_contact(obj):
    "obj must be either a string or have an xml_id key"
    if not isinstance(obj, basestring):
        obj = obj.get('xml_id')
    return obj.startswith('cntct_')

class Model(object):

    models = []
    errors = defaultdict(list)

    def __init__(self, table, abbr, module, context):
        self.models.append(self)
        self.table = table
        self.abbr = abbr
        self.module = module
        self.context = context

    def error(self, msg):
        self.errors[self.abbr].append(msg)

    def create(self, key, values, context=None):
        if context is None:
            context = self.context
        try:
            return self.table.create(pfm(values), context=context)
        except:
            cls, exc, tb = sys.exc_info()
            self.errors[self.abbr].append('FIS ID %s:%s create caused exception %r' % (self.module, key, exc))
            # error(''.join(format_exception(cls, exc, tb)))
            return False

    def delete(self, ids, context=None):
        if context is None:
            context = self.context
        try:
            return self.table.unlink(ids)
        except:
            cls, exc, tb = sys.exc_info()
            self.errors[self.abbr].append('%s: deleting ID(s) %s caused exception %r' % (self.module, ', '.join([str(n) for n in ids]), exc))
            # error(''.join(format_exception(cls, exc, tb)))
            return False

    def read(self, **kwds):
        if 'context' not in kwds:
            kwds['context'] = self.context
        return get_records(self.table, **kwds)

    def search(self, domain, context=None):
        if context is None:
            context = self.context
        return self.table.search(domain, context=context)

    def write(self, key, ids, values, context=None):
        if context is None:
            context = self.context
        try:
            print('writing to %s using %s\n and %s' % (ids, pfm(values), context), border='box', verbose=2)
            print(str(self.table.write(ids, pfm(values), context=context)), border='box', verbose=2)
            return True
        except:
            cls, exc, tb = sys.exc_info()
            self.errors[self.abbr].append('FIS ID %s:%s write caused exception %r' % (self.module, key, exc))
            # error(format_exception(cls, exc, tb))
            return False

# old code
# def handle_sales_reps():
#     context = {'fis-updates': True}
#     res = AttrDict()
#     res.partner = oe.get_model('res.partner')
#     cnvzz = fisData(47)
#     if method == 'quick':
#         cnvz_old = fisData(47, data_path=config.network.fis_data_local_old_path)
#     failed_match = set()
#     def is_invalid_cnvz(sales_rec):
#         sales_id = rec[F47.salesperson_id].upper()
#         sales_name = rec[F47.salesperson_name]
#         company_id = rec[F47.company_id]
#         if company_id != '10':
#             return True
#         if '-' in sales_name:
#             sales_name, extra = sales_name.split('-')
#             if not extra.strip().isdigit() and sales_id != 'BAD':
#                 return True
#         return False
#     #
#     # saving below for later
#     #
#         sales_full_name = sales_name.lower()
#         names = sales_full_name.split()
#         if len(names) > 1:
#             sales_name = ' '.join([names[0], names[-1]])
#         else:
#             sales_name = sales_name.lower()
#         if sales_name in failed_match:
#             # this name already failed to match
#             continue
#         if var(potential_sales_people.get(sales_name)) is not None and len(var()) == 1:
#             # full-name match
#             sales_people[sales_id] = var()[0]
#         # elif len(names) == 1:
#         #     # if it didn't match before, it's not going to match now
#         #     pass
#         #     # potential_sales_people[sales_id] = None
#         #     # failed_match.add(sales_name)
#         elif var(potential_sales_people.get(names[-1])) and len(var()) == 1:
#             # last name match
#             sales_people[sales_id] = var()[0]
#         elif var(potential_sales_people.get(names[0])) and len(var()) == 1:
#             # first name match
#             sales_people[sales_id] = var()[0]
#         else:
#             # no match at all
#             # look for user matches and previously created dummy user accounts
#             all_users = res_users.browse(cr, uid, context=inactive_too)
#             all_users.sort(key=lambda r: not r.active)
#             if len(names) > 1:
#                 # try to match sales name with beginning of user name
#                 # e.g. "billy bob" with "billy bob joe"
#                 user = [u for u in all_users if u.name.lower().startswith(sales_name)]
#                 if user:
#                     if len(user) == 1:
#                         sales_people[sales_id] = user[0].id
#                         continue
#                     else:
#                         _logger.warning('unable to match %s (%s): too many possibles', sales_name, sales_id)
#                         failed_match.add(sales_name)
#                         continue
#
#                 login = names[0][0] + names[1]
#             else:
#                 login = names[0]
#             # try to match against login
#             # e.g. "billy bob" with "bbob"
#             for user in all_users:
#                 if login == user.login:
#                     sales_people[sales_id] = user.id
#                     break
#             else:
#                 # if we make it this far, no matches -- so let's create a new (inactive)
#                 # user so we can properly categorize customers
#                 _logger.warning('unable to match %s: creating dummy user', sales_name)
#                 id = res_users.create(
#                         cr, uid,
#                         {
#                             'name': NameCase(sales_name),
#                             'login': login,
#                             'active': False,
#                             'tz': 'America/Los_Angeles',
#                             },
#                         context=context)
#                 sales_people[sales_id] = id
#                 all_users.append(res_users.browse(cr, uid, id, context=inactive_too))
#             # continue
#             # failed_match.add(sales_name)

# main
Main()
