#!/usr/local/sbin/suid-python --virtualenv

# imports
from __future__ import print_function

from scription import *
from aenum import Enum, NamedTuple
from antipathy import Path
from collections import defaultdict
from dbf import Date, DateTime, Time
from fis_schema import F8, F11, F27, F33, F34, F47, F65, F74, F97, F135
from fis_schema import F163, F192, F262, F320, F322, F328, F329, F341
from logging import INFO, getLogger, Formatter, handlers
from openerplib import get_connection, get_records, local_to_utc
from openerplib import AttrDict, Many2One, XidRec
    # from traceback import format_exception
from pandaemonium import PidLockFile
from recipe import ignored_ingredients
from tools import Model
# from tools import combine_by_value
from tools import Synchronize, SynchronizeAddress, XmlLink, ProductLabelDescription, odoo_erp
from VSS.address import NameCase, BsnsCase
# from VSS.BBxXlate.fisData import fisData
from VSS.utils import fix_phone, fix_date
# from warnings import warn
import errno
import math
import re
import os
import socket
import traceback


virtualenv = Path(os.environ['VIRTUAL_ENV'])
logger = getLogger()
logger.setLevel(INFO)
_handler = handlers.TimedRotatingFileHandler(
        virtualenv / 'var/log/openerp/continuous_sync_records.log',
        when='midnight',
        backupCount=30,
        )
_formatter = Formatter('%(asctime)s %(funcName)-25s %(message)s')
_handler.setFormatter(_formatter)
logger.addHandler(_handler)
del _handler, _formatter

# Constants

C = Color
grey = C.Dim | C.FG_White
white = C.Normal | C.FG_White
same = C.Normal | C.FG_White
oldv = C.Normal | C.FG_Red
newv = C.Normal | C.FG_Green

ONE_YEAR_AGO = Date.today().replace(delta_year=-1)

SALEABLE_CATEGORY_XMLID = 'product_category_1'
INVALID_CATEGORY_XMLID = 'fis_product_category_invalid' 
ETC_CATEGORY_XMLID = '9'


# TODO: implement EXTRA handling for
#       - EMP1
#       - POSM/VNMS
#       - CSMS
#       - NVTY          --> done
#       - CNVZd0
#       - CNVZz
#       - CNVZsv
#       - CNVZas
#       - CNVZaa

# API
@Script(
        dryrun=Spec('do not make changes, only show what changes would be made', FLAG),
        list_records=Spec('list added/changed records', FLAG),
        raise_on_exception=Spec('do not ignore exceptions', FLAG, abbrev=('r', 'raise')),
        )
def main(dryrun, list_records, raise_on_exception):
    global config, oe, ir_model_data, errors
    global DRYRUN, LIST_RECORDS, RAISE_ON_EXCEPTION, VIEW_TYPE, BORDER, script_verbosity
    DRYRUN = LIST_RECORDS = False
    config = OrmFile(virtualenv / 'config/fnx.ini', types={'_path': Path})
    oe = config.openerp
    oe = get_connection(hostname=oe.host, database=oe.db, login=oe.user, password=oe.pw)
    ir_model_data = oe.get_model('ir.model.data')
    errors = defaultdict(list)
    if dryrun:
        DRYRUN = True
        if not script_verbosity:
            script_verbosity = 1
    LIST_RECORDS = list_records
    RAISE_ON_EXCEPTION = raise_on_exception
    VIEW_TYPE = 'none' if LIST_RECORDS else 'percent'
    BORDER = 'box' if LIST_RECORDS and script_verbosity > 1 else None
    global logger
    logger = getLogger('orders')

@Command(
        files=Spec('changed FIS files', type=lambda f: f.lower()),
        method=Spec(
            'perform quick or full comparison ['
            'quick: compare against old FIS files; '
            'full: compare against OpenERP records; '
            'check: directly compare OpenERP vs FIS by using in-record data (not ir.model.data); '
            'imd-update: add ir.model.names for existing records;'
            ']',
            OPTION,
            choices=['quick', 'full', 'check', 'imd-update'],
            type=lambda m: m.lower(),
            ),
        delete=Spec('delete records [default: send email]', FLAG,),
        extra=Spec('misc key-value pairs', OPTION),
        )
def fis_integration(method, delete, *files, **extra):
    global skipped_suppliers, vendor_suppliers, ven2sup, vendor_codes
    global models, DELETE, EXTRA
    DELETE = delete
    EXTRA = extra
    try:
        # make sure we are the only one running
        with PidLockFile(virtualenv / 'var/run/fis_update.pid'):
            # update users first



            # then update from FIS
            ven2sup = {}
            state_recs = dict([
                (r.name, (Many2One(r.id, r.name, 'res.country.state'), r.country_id))
                for r in get_records(oe, 'res.country.state')
                ])
            country_recs = dict([
                (r.name, Many2One(r.id, r.name, 'res.country'))
                for r in get_records(oe, 'res.country')
                ])
            for name, rec_id in country_recs.items():
                country_recs[rec_id] = name
            skipped_suppliers = set()
            vendor_suppliers = {}
            vendor_codes = set()
            if 'cnvz' in files:
                for handler in (
                    CNVZaa,      # product location, 97
                    CNVZas,      # product category, 11
                    CNVZd0,      # customer terms, 8
                    CNVZf,       # production lines, 341
                    CNVZO1,      # transmitter numbers, 192
                    CNVZz,       # sales reps, 47
                    ):
                    handler(oe, config).run(method)
                # shipping carriers, 27
                CNVZsv(oe, config, state_recs, country_recs).run(method)
            for filename, handler in (
                    ('arci', ARCI),
                    ('nvty', NVTY),
                    ('ifms', IFMS),
                    ('ifdt', IFDT),
                    ('ifpp', IFPP0),
                    ('ifpp', IFPP1),
                ):
                if filename in files:
                    handler(oe, config).run(method)
            if 'emp1' in files:
                EMP1(oe, config, state_recs, country_recs).run(method)
            if 'posm' in files or 'vnms' in files:
                POSM_VNMS(oe, config, state_recs, country_recs).run(method)
            if 'csms' in files:
                CSMS(oe, config, state_recs, country_recs).run(method)
                CSMSS(oe, config, state_recs, country_recs).run(method)
    except socket.error as s_error:
        if s_error.errno in (
                errno.ECONNREFUSED,
                errno.EHOSTDOWN,
            ):
            raise SystemExit(Exit.Unavailable)
        else:
            raise SystemExit(Exit.IoError)
    except Exception:
        traceback.print_exc()
        raise SystemExit(Exit.Software)
    finally:
        for m, problems in sorted(Model.errors.items()):
            error()
            error(m, border=('lined', '='), sep='')
            for p in problems:
                error('  ', p)
            error()

@Command()
def aging():
    aging_data = get_customer_aging('%s/customer_aging.txt' % config.network.fis_data_local_path)
    res_partner = oe.get_model('res.partner')
    customers = dict([
            (r.xml_id, r.id)
            for r in get_records(
                oe, 'res.partner',
                domain=[('customer','=',True),('xml_id','!=',False)],
                fields=['id','xml_id'],
                )])
    not_found = []
    for xml_id, aging in aging_data.items():
        try:
            id = customers[xml_id]
        except KeyError:
            not_found.append(xml_id)
            continue
        res_partner.write(
                id,
                {
                    'fis_credit_limit':   aging.limit,
                    'fis_credit_current': aging.current,
                    'fis_credit_10_days': aging.d10,
                    'fis_credit_20_days': aging.d20,
                    'fis_credit_30_days': aging.d30,
                    'fis_credit_total':   aging.total,
                    },
                )
    error('unable to find OpenERP records matching: %r' % ', '.join(not_found))

# helpers
#
# For those helpers that treat 'quick' and 'full' diferently, there are two ways to calculate changes
# in 'quick' mode after using get_changed_fis_records() to isolate the potential changes:
#
# - convert the new records into OpenERP records and retrieve the existing OpenERP
#   records for comparison
#
# - partially convert the records (in case a full conversion is too messy), then complete
#   the conversion later when it is determined the records are actually needed
#

class ARCI(Synchronize):

    # customer product cross reference, 262
    TN = 262
    FN = 'arci'
    F = 'F262'
    RE = r'10 HE447......'
    OE = (
            'fis_integration.customer_product_cross_reference',
            'fis.customer_product_xref',
            )[odoo_erp]
    IMD = 'customer_product_xref'
    OE_KEY = 'key'
    OE_KEY_MODULE = 'source','fis'
    OE_FIELDS = (
            'id','key','list_code','fis_code',
            'partner_id','fis_product_id','customer_product_code',
            'source',
            )

    def convert_fis_rec(self, fis_rec, use_ignore=False):
        if use_ignore and self.FIS_IGNORE_RECORD(fis_rec):
            return ()
        cust_no = fis_rec[F262.cust_no]
        our_item_id = fis_rec[F262.our_item_id]
        key = '%s-%s' % (cust_no, our_item_id)
        imd = AttrDict(
                id=0,
                model=self.OE,
                res_id=0,
                module='fis',
                name=self.calc_xid(key),
                )
        cust_item_id = fis_rec[F262.cust_item_id]
        #
        # fis record
        #
        item = AttrDict.fromkeys(self.OE_FIELDS, None)
        item.key = key
        item.list_code = cust_no
        item.fis_code = our_item_id
        item.partner_id = CSMS.Partner(cust_no)
        item.fis_product_id = NVTY.Product(our_item_id)
        item.customer_product_code = cust_item_id or None
        item.source = 'fis'
        #
        return (XidRec.fromdict(item, imd), )


class CNVZaa(Synchronize):

    # product location, 97
    TN = 97
    FN = 'cnvzaa'
    F = 'F097'
    OE = (
            'product.available_at',
            'product.availability',
            )[odoo_erp]
    IMD = 'product_availability'
    RE = r"aa10."
    OE_KEY = 'xml_id'
    OE_KEY_MODULE = 'F97'
    OE_FIELDS = (
            ('id', 'module', 'xml_id', 'name', 'available'),
            ('id', 'fis_module', 'fis_id', 'name', 'saleable'),
            )[odoo_erp]
    #
    ProductLocation = XmlLink

    def convert_fis_rec(self, fis_rec, use_ignore=False):
        if use_ignore and self.FIS_IGNORE_RECORD(fis_rec):
            return ()
        key = fis_rec[F97.availability_id].strip()
        imd = AttrDict(
                id=0,
                model=self.OE,
                res_id=0,
                module='fis',
                name=self.calc_xid(key),
                )
        location = AttrDict.fromkeys(self.OE_FIELDS, None)
        location.xml_id = key
        location.module = self.OE_KEY_MODULE
        location.name = re.sub('sunridge', 'SunRidge', fis_rec[F97.desc].title(), flags=re.I) or None
        avail = fis_rec[F97.availability].upper()
        if avail not in 'YN':
            avail = None
        location.available = avail
        return (XidRec.fromdict(location, imd), )


class CNVZas(Synchronize):

    # product category, 11
    TN = 11
    FN = 'cnvzas'
    F = 'F011'
    OE = 'product.category'
    IMD = 'product_category'
    RE = r"as10.."
    OE_KEY = 'xml_id'
    OE_KEY_MODULE = 'F11'
    OE_FIELDS = ('id', 'module', 'xml_id', 'name', 'parent_id', 'fis_shelf_life')
    #
    ProductCategory = XmlLink

    def __init__(self, *args, **kwds):
        super(CNVZas, self).__init__(*args, **kwds)
        self.SALEABLE_CATEGORY = self.ProductCategory(SALEABLE_CATEGORY_XMLID)
        _, self.SALEABLE_CATEGORY.id = self.ir_model_data.get_object_reference('product', SALEABLE_CATEGORY_XMLID)
        self.ETC_CATEGORY = self.ProductCategory(ETC_CATEGORY_XMLID)

    def convert_fis_rec(self, fis_rec, use_ignore=False):
        if use_ignore and self.FIS_IGNORE_RECORD(fis_rec):
            return ()
        key = fis_rec[F11.sales_category_id].strip()
        imd = AttrDict(
                id=0,
                model=self.OE,
                res_id=0,
                module='fis',
                name=self.calc_xid(key),
                )
        category = AttrDict.fromkeys(self.OE_FIELDS, None)
        category.xml_id = key
        category.module = self.OE_KEY_MODULE
        category.fis_shelf_life = fis_rec[F11.shelf_life]
        name = re.sub('sunridge', 'SunRidge', fis_rec[F11.desc].title(), flags=re.I)
        if len(key) == 1:
            name = key + ' - ' + name.strip('- ')
            category.parent_id = self.SALEABLE_CATEGORY
        else:
            parent_key = key[0]
            if parent_key.isdigit():
                parent_id = self.ProductCategory(parent_key)
            else:
                parent_id = self.ETC_CATEGORY
            category.parent_id = parent_id
        category.name = name or None
        return (XidRec.fromdict(category, imd), )


class CNVZd0(Synchronize):

    # customer terms, 8
    TN = 8
    FN = 'cnvzd0'
    F = 'F008'
    RE = r"D010."
    OE = 'fis.account.customer_terms'
    IMD = 'account_customer_terms'
    OE_KEY = 'xml_id'
    OE_KEY_MODULE = 'F8'
    OE_FIELDS = (
            'id', 'module', 'xml_id', 'description',
            )
    #
    CustomerTerms = XmlLink

    def convert_fis_rec(self, fis_rec, use_ignore=False):
        if use_ignore and self.FIS_IGNORE_RECORD(fis_rec):
            return ()
        key = fis_rec[F8.code]
        imd = AttrDict(
                id=0,
                model=self.OE,
                res_id=0,
                module='fis',
                name=self.calc_xid(key),
                )
        terms = AttrDict.fromkeys(self.OE_FIELDS, None)
        terms.xml_id = key
        terms.module = self.OE_KEY_MODULE
        terms.description = ' / '.join([t.strip() for t in fis_rec[F8.description].split('/')]) or None
        return (XidRec.fromdict(terms, imd), )


class CNVZf(Synchronize):

    # production lines, 341
    TN = 341
    FN = 'cnvzf'
    F = 'F341'
    OE = (
            'fis_integration.production_line',
            'fis.production.line',
            )[odoo_erp]
    IMD = 'production_line'
    RE = r"f10.."
    OE_KEY = 'xml_id'
    OE_KEY_MODULE = 'F341'
    OE_FIELDS = (
            ('id', 'xml_id', 'module', 'desc'),
            ('id', 'fis_id', 'module', 'description'),
            )[odoo_erp]
    #
    ProductionLine = XmlLink

    def convert_fis_rec(self, fis_rec, use_ignore=False):
        if use_ignore and self.FIS_IGNORE_RECORD(fis_rec):
            return ()
        key = fis_rec[F341.prod_line_code]
        imd = AttrDict(
                id=0,
                model=self.OE,
                res_id=0,
                module='fis',
                name=self.calc_xid(key),
                )
        line = AttrDict.fromkeys(self.OE_FIELDS, None)
        line.module = self.OE_KEY_MODULE
        desc = fis_rec[F341.desc] or None
        if desc:
            new_desc = []
            for word in desc.split():
                if word.upper() in ('KFK','USA','LLC'):
                    new_desc.append(word.upper())
                else:
                    new_desc.append(word.title())
            desc = ' '.join(new_desc)
        if odoo_erp == 'odoo':
            line.fis_id = key
            line.description = desc
        else:
            line.xml_id = key
            line.desc = desc
        return (XidRec.fromdict(line, imd), )


class CNVZO1(Synchronize):

    # transmitter numbers, 192
    TN = 192
    FN = 'cnvzo1'
    F = 'F192'
    OE = (
            'fis.transmitter_code',
            'fis.account.transmitter_code',
            )[odoo_erp]
    IMD = 'account_transmitter_code'
    #
    RE = r"O110......"
    OE_KEY = 'transmitter_no'
    OE_FIELDS = ('id', 'transmitter_no', 'transmitter_name', 'partner_xml_id', 'ship_to_code')
    #
    FIS_IGNORE_RECORD = lambda self, rec: not rec[F192.transmitter_no].strip().isdigit()
    #
    TransmitterCode = XmlLink

    def convert_fis_rec(self, fis_rec, use_ignore=False):
        if use_ignore and self.FIS_IGNORE_RECORD(fis_rec):
            return ()
        key = fis_rec[F192.transmitter_no].strip()
        imd = AttrDict(
                id=0,
                model=self.OE,
                res_id=0,
                module='fis',
                name=self.calc_xid(key),
                )
        tran_code = AttrDict.fromkeys(self.OE_FIELDS, None)
        tran_code.transmitter_no = key
        tran_code.transmitter_name = fis_rec[F192.transmitter_name].strip() or None
        tran_code.ship_to_code = fis_rec[F192.ship_to_id].strip() or None
        tran_code.partner_xml_id = fis_rec[F192.cust_no].strip() or None
        return (XidRec.fromdict(tran_code, imd), )


class CNVZsv(SynchronizeAddress):

    # shipping carriers, 27
    TN = 27
    FN = 'cnvzsv'
    F = 'F027'
    OE = 'res.partner'
    IMD = 'res_partner'
    RE = r"SV10.."
    OE_KEY = 'xml_id'
    OE_KEY_MODULE = 'F27'
    OE_FIELDS = (
            'id', 'module', 'xml_id', 'is_carrier', 'is_company', 'use_parent_address',
            'name', 'street', 'street2', 'city', 'state_id', 'zip', 'country_id',
            'phone', 'fuel_surcharge', 'fis_updated_by_user',
            )
    FIS_SCHEMA = (
            F27.name, F27.tele, F27.fuel_surcharge,
            )

    def convert_fis_rec(self, fis_rec, use_ignore=False):
        if use_ignore and self.FIS_IGNORE_RECORD(fis_rec):
            return ()
        key = fis_rec[F27.code].strip()
        imd = AttrDict(
                id=0,
                model=self.OE,
                res_id=0,
                module='fis',
                name=self.calc_xid(key),
                )
        company = AttrDict.fromkeys(self.OE_FIELDS, None)
        company.name = re.sub('sunridge', 'SunRidge', BsnsCase(fis_rec[F27.name]), flags=re.I)
        company.xml_id = key
        company.module = self.OE_KEY_MODULE
        company.fis_updated_by_user = None
        company.is_company = True
        company.is_carrier = True
        company.use_parent_address = False
        if key == '99':
            company.name = '____________'
        company.update(self.process_address(F27, fis_rec))
        company.phone = fis_rec[F27.tele].strip() or None
        company.fuel_surcharge = fis_rec[F27.fuel_surcharge].upper() == 'Y'
        return (XidRec.fromdict(company, imd), )


class CNVZz(Synchronize):

    # customer sales reps, 47
    TN = 47
    FN = 'cnvzz'
    F = 'F047'
    OE = 'fis.account.salesperson'
    IMD = 'account_salesperson'
    RE = r"Z..."
    OE_KEY = 'xml_id'
    OE_KEY_MODULE = 'F47'
    OE_FIELDS = ('id', 'module', 'xml_id', 'fis_name', 'user_id')
    #
    SalesRep = XmlLink

    def __init__(self, *args, **kwds):
        super(CNVZz, self).__init__(*args, **kwds)
        self.users = self.get_xid_records(
                self.erp,
                domain=[('module','=','fis'),('name','=like','F074_%_res_users')],
                fields=['id','login','name'],
                context=self.context,
                )

    def convert_fis_rec(self, fis_rec, use_ignore=False):
        if use_ignore and self.FIS_IGNORE_RECORD(fis_rec):
            return ()
        key = fis_rec[F47.salesperson_id]
        imd = AttrDict(
                id=0,
                model=self.OE,
                res_id=0,
                module='fis',
                name=self.calc_xid(key),
                )
        salesrep = AttrDict.fromkeys(self.OE_FIELDS, None)
        salesrep.xml_id = key
        salesrep.module = self.OE_KEY_MODULE
        salesrep.fis_name = fis_name = fis_rec[F47.salesperson_name].split('-')[0] or None
        if fis_name is None:
            salesrep.user_id = None
        else:
            # try to find a match in res.users
            salesrep.user_id = self.match(fis_name)
            if salesrep.user_id is not None:
                salesrep.user_id = Many2One(salesrep.user_id, key, 'res.users')
        return (XidRec.fromdict(salesrep, imd), )

    def match(self, name):
        # try to match names, looping several times if necessary
        # - perfect match
        # - first and last match
        # - contained first, and last match
        # - all of given is in target
        # - first match
        # - last match
        name = name.upper()
        # perfect match?
        for user in self.users:
            user_name = user.name.upper()
            if name == user_name:
                return user.id
        # first/last match
        names = name.split()
        first = names[0]
        last = names[-1]
        for user in self.users:
            user_names = user.name.upper().split()
            user_first = user_names[0]
            user_last = user_names[-1]
            if first == user_first and last == user_last:
                return user.id
        # contained first, and last match
        for user in self.users:
            user_names = user.name.upper().split()
            user_first = user_names[0]
            user_last = user_names[-1]
            if user_first.startswith(first) and last == user_last:
                return user.id
        # name is fully contained in user name
        for user in self.users:
            user_name = user.name.upper()
            if name in user_name:
                return user.id
        # first match
        for user in self.users:
            user_names = user.name.upper().split()
            user_first = user_names[0]
            if first == user_first:
                return user.id
        # last match
        for user in self.users:
            user_names = user.name.upper().split()
            user_last = user_names[-1]
            if last == user_last:
                return user.id
        # no match
        return None


class CSMS(SynchronizeAddress):

    # customers, 33
    TN = 33
    FN = 'csms'
    F = 'F033'
    RE = r"10...... "
    OE = 'res.partner'
    IMD = 'res_partner'
    OE_KEY = 'xml_id'
    OE_KEY_MODULE = 'F33'
    OE_FIELDS_QUICK = [
            'id', 'module', 'xml_id', 'fis_csms_terms', 'fis_price_list',
            'name', 'street', 'street2', 'city', 'state_id', 'zip', 'country_id',
            'fis_valid', 'specials_notification', 'phone', 'is_company', 'customer',
            'fis_updated_by_user', 'active', 'use_parent_address', 'user_id',
            'fis_transmitter_id',
            ]
    OE_FIELDS_LONG = [
            'id', 'module', 'xml_id', 'fis_csms_terms', 'fis_price_list',
            'name', 'street', 'street2', 'city', 'state_id', 'zip', 'country_id',
            'fis_valid', 'specials_notification', 'phone', 'is_company', 'customer',
            'fis_updated_by_user', 'active', 'use_parent_address', 'fis_credit_limit',
            'fis_credit_10_days', 'fis_credit_20_days', 'fis_credit_30_days',
            'fis_credit_current', 'fis_credit_total', 'user_id', 'fis_transmitter_id',
            ]
    FIS_SCHEMA = [
            F33.name, F33.salesrep, F33.catalog_category, F33.this_year_sales,
            F33.last_year_sales, F33.tele, F33.contact,
            ]
    FIELDS_CHECK_IGNORE = ('active', 'name')

    Partner = XmlLink

    def __init__(self, oe, config, *args, **kwds):
        super(CSMS, self).__init__(oe, config, *args, **kwds)
        CNVZz(oe, config).reify(fields=['user_id'])

    def run(self, method):
        if method == 'full':
            print('getting aging data')
            aging = get_customer_aging('%s/customer_aging.txt' % config.network.fis_data_local_path)
        else:
            aging = None
        self.aging_data = aging
        super(CSMS, self).run(method)

    def convert_fis_rec(self, fis_rec, use_ignore=False):
        #
        # creates an AttrDict with the following fields
        # - 'module', 'xml_id',
        # - 'name', 'street', 'street2', 'city', 'state_id', 'zip', 'country_id',
        # - 'fis_valid', 'specials_notification', 'phone', 'is_company', 'customer',
        # - 'use_parent_address', 'active', 'fis_transmitter_id',
        #
        # fields coming from OpenERP that are missing/invalid on the FIS side
        # - 'id', 'fis_updated_by_user'
        # - address fields (for contact)
        #
        # fis records use the following fields to detect changes
        #
        # enum_schema=[
        #     F33.name, F33.salesrep, F33.catalog_category, F33.this_year_sales,
        #     F33.last_year_sales, F33.tele, F33.contact,
        #     ],
        # address_fields=[
        #     F33.addr1, F33.addr2, F33.addr3,
        #     ],
        #
        if use_ignore and self.FIS_IGNORE_RECORD(fis_rec):
            return ()
        key = fis_rec[F33.code]
        imd = AttrDict(
                id=0,
                model=self.OE,
                res_id=0,
                module='fis',
                name=self.calc_xid(key),
                )
        company = AttrDict.fromkeys(self.OE_FIELDS, None)
        # TODO: get salesrep working
        # rep = cus_rec[F33.salesrep]
        # rep = sales_people.get(rep, False)
        company.module = self.OE_KEY_MODULE
        company.xml_id = key
        company.name = re.sub('sunridge', 'SunRidge', BsnsCase(fis_rec[F33.name]), flags=re.I) or None
        company.fis_updated_by_user = None
        company.is_company = True
        company.customer = True
        company.use_parent_address = False
        # valid customer code? active account?
        company.fis_valid = len(key) == 5
        company.active = False
        added = fis_rec[F33.date_added] or Date()
        if added:
            year, month, day = added[:2], int(added[2:4]), int(added[4:])
            if year.isdigit():
                year = 1900 + int(year)
            else:
                year = 1840 + int(year, 16)
            added = Date(year, month, day)
        if (
                fis_rec[F33.this_year_sales]
             or fis_rec[F33.last_year_sales]
             or added >= ONE_YEAR_AGO
            ):
            company.active = True
        else:
            # TODO check for open orders
            pass
        company.user_id = getattr(CNVZz.SalesRep(fis_rec[F33.salesrep]), 'user_id', None)
        # sr = sales_person_recs.get(salesrep, False)
        # if not sr or not sr.user_id:
        #     company.user_id = False
        #     if salesrep not in _missing_reps:
        #         _missing_reps.add(salesrep)
        #         error('no salesrep match found for %r' % (salesrep, ))
        # else:
        #     company.user_id = sr.user_id.id
        notify_by = Specials.get_member(fis_rec[F33.catalog_category].upper(), Specials.neither)
        company.specials_notification = notify_by   #.value
        company.update(self.process_address(F33, fis_rec))
        company.phone = fix_phone(fis_rec[F33.tele]) or None
        company.fis_csms_terms = CNVZd0.CustomerTerms(fis_rec[F33.payment_terms_id])
        company.fis_price_list = fis_rec[F33.price_list_id] or None
        if self.aging_data:
            if key in self.aging_data:
                account = self.aging_data[key]
                company.fis_credit_limit = account.limit
                company.fis_credit_current = account.current
                company.fis_credit_10_days = account.d10
                company.fis_credit_20_days = account.d20
                company.fis_credit_30_days = account.d30
                company.fis_credit_total = account.total
            else:
                company.fis_credit_limit = 0
                company.fis_credit_current = 0
                company.fis_credit_10_days = 0
                company.fis_credit_20_days = 0
                company.fis_credit_30_days = 0
                company.fis_credit_total = 0
        company.fis_transmitter_id = CNVZO1.TransmitterCode(key+'-default')
        company = XidRec.fromdict(company, imd)
        contact = None
        if fis_rec[F33.contact] and fis_rec[F33.contact] != fis_rec[F33.name]:
            key = 'cntct_' + key
            imd = AttrDict(
                    id=0,
                    model=self.OE,
                    res_id=0,
                    module='fis',
                    name='F033_%s_res_partner' % (key),
                    )
            contact = AttrDict.fromkeys(self.OE_FIELDS, None)
            contact.name = NameCase(fis_rec[F33.contact]) or None
            contact.xml_id = key
            contact.module = 'F33'
            contact.fis_updated_by_user = None
            contact.is_company = False
            contact.customer = True
            contact.use_parent_address = True
            contact.specials_notification = Specials.company
            contact.fis_valid = company.fis_valid
            contact.active = company.active
            contact.user_id = company.user_id
            if self.aging_data:
                contact.fis_credit_limit = 0
                contact.fis_credit_current = 0
                contact.fis_credit_10_days = 0
                contact.fis_credit_20_days = 0
                contact.fis_credit_30_days = 0
                contact.fis_credit_total = 0
            contact = XidRec.fromdict(contact, imd)
            return company, contact
        return (company, )


class CSMSS(SynchronizeAddress):

    # general name and file number
    TN = 34
    FN = 'csmss'
    F = 'F034'
    RE = r"10......1...."
    OE = 'res.partner'
    IMD = 'res_partner'
    OE_KEY = 'xml_id'
    OE_KEY_MODULE = 'F%s' % TN
    OE_FIELDS = [
            'id', 'module', 'xml_id', 'phone',
            'name', 'street', 'street2', 'city', 'state_id', 'zip', 'country_id',
            'customer', 'fis_ship_to_parent_id', 'use_parent_address', 'is_company',
            'fis_transmitter_id', 'fis_ship_to_code', 'active',
            ]
    FIS_IGNORE_RECORD = lambda self, rec: (
                not rec[F34.name]
                or re.search('.*additional.*ship.*to.*', rec[F34.name], re.I)
                or re.search('.*additional.*ship.*to.*', rec[F34.addr1], re.I)
                or re.search('.*additional.*ship.*to.*', rec[F34.addr2], re.I)
                or re.search('.*additional.*ship.*to.*', rec[F34.addr3], re.I)
                )

    def convert_fis_rec(self, fis_rec, use_ignore=False):
        "additional ship-to addresses"
        #
        # creates an XidRec with the following fields
        # - 'module', 'xml_id', 'active',
        # - 'name', 'street', 'street2', 'city', 'state_id', 'zip', 'country_id',
        # - 'phone', 'is_company', 'customer','use_parent_address',
        # - 'fis_ship_to_code', 'fis_ship_to_parent_id', 'fis_transmitter_id',
        #
        # fields coming from OpenERP that are missing/invalid on the FIS side
        # - 'id',
        #
        # fis records use the following fields to detect changes
        #
        # enum_schema=[
        #     F34.name, F34.addr1, F34.addr2, F34.addr3, F34.postal, F34.tele, F34.sales_contact,
        #     ],
        # address_fields=[
        #     F34.addr1, F34.addr2, F34.addr3,
        #     ],
        #
        if use_ignore and self.FIS_IGNORE_RECORD(fis_rec):
            return ()
        parent_xml_id = fis_rec[F34.code]
        name = re.sub('sunridge', 'SunRidge', BsnsCase(fis_rec[F34.name]), flags=re.I)
        code = fis_rec[F34.ship_to_no].strip() or 'default'
        key = '%s-%s' % (fis_rec[F34.code], code)
        imd = AttrDict(
                id=0,
                model=self.OE,
                res_id=0,
                module='fis',
                name=self.calc_xid(key),
                )
        ship_to = AttrDict.fromkeys(self.OE_FIELDS, None)
        ship_to.name = name
        ship_to.active = True
        ship_to.fis_ship_to_code = code
        ship_to.module = self.OE_KEY_MODULE
        ship_to.xml_id = key
        ship_to.update(self.process_address(F34, fis_rec))
        ship_to.is_company = False
        ship_to.customer = False
        ship_to.use_parent_address = False
        ship_to.phone = fix_phone(fis_rec[F34.tele]) or None
        ship_to.fis_ship_to_parent_id = CSMS.Partner(parent_xml_id)
        ship_to.fis_transmitter_id = CNVZO1.TransmitterCode(key)
        return (XidRec.fromdict(ship_to, imd), )


class EMP1(SynchronizeAddress):

    # employees, 74
    TN = 74
    FN = 'emp1'
    F = 'F074'
    OE = 'hr.employee'
    IMD = 'hr_employee'
    RE = r"10....."
    OE_KEY = 'xml_id'
    OE_KEY_MODULE = 'F74'
    OE_FIELDS = (
            'id', 'module', 'xml_id', 'name', 'employment_type', 'ssnid', 'birthday', 'home_phone',
            'home_street', 'home_street2', 'home_city', 'home_state_id', 'home_zip', 'home_country_id',
            'hire_date', 'fire_date', 'active', 'status_flag', 'pension_plan',
            'pay_type', 'hourly_rate', 'last_raise', 'marital', 'gender', 'identification_id',
            'emergency_contact', 'emergency_number', 'state_exemptions', 'federal_exemptions',
            )
    FIS_SCHEMA = (
            F74.name, F74.ssn, F74.tele, F74.date_hired, F74.date_terminated,
            F74.birth_date, F74.last_raise, F74.status_flag, F74.pay_type,
            F74.marital_status, F74.pension_status, F74.gender, F74.emergency_contact,
            F74.emergency_phone, F74.exempt_fed, F74.exempt_state, F74.hourly_rate,
            )
    FIS_IGNORE_RECORD = lambda self, rec: int(rec[F74.emp_num]) >= 9000

    def convert_fis_rec(self, fis_rec, use_ignore=False):
        if use_ignore and self.FIS_IGNORE_RECORD(fis_rec):
            return ()
        emp_num = fis_rec[F74.emp_num].strip()
        imd = AttrDict(
                id=0,
                model=self.OE,
                res_id=0,
                module='fis',
                name=self.calc_xid(emp_num),
                )
        employee = AttrDict.fromkeys(self.OE_FIELDS, None)
        employee.name = re.sub('sunridge', 'SunRidge', NameCase(fis_rec[F74.name]), flags=re.I)
        employee.xml_id = employee.identification_id = emp_num
        employee.module = self.OE_KEY_MODULE
        try:
            if int(emp_num) >= 9000:
                return ()
        except (ValueError, TypeError):
            return ()
        employee.employment_type = 'standard'
        employee.update(self.process_address(F74, fis_rec, home=True))
        employee.home_phone = fix_phone(fis_rec[F74.tele]) or None
        ssn = fis_rec[F74.ssn]
        if len(ssn) == 9:
            ssn = '%s-%s-%s' % (ssn[:3], ssn[3:5], ssn[5:])
        employee.ssnid = ssn or None
        employee.hire_date = hired = fix_date(fis_rec[F74.date_hired]) or None
        employee.fire_date = fired = fix_date(fis_rec[F74.date_terminated]) or None
        employee.active = (not fired or hired > fired)
        # employee birth dates are stored extra weirdly: if the year is 99 or less
        #   then the it's 19xx, but if any hex digits are present then the year is
        #   1740 + xx
        text = fis_rec[F74.birth_date]
        emp_birthday = None
        if text:
            month, day, year = int(text[:2]), int(text[2:4]), text[4:]
            if year.isdigit():
                year = 1900 + int(year)
            else:
                year = 1740 + int(year, 16)
            emp_birthday = Date(year, month, day)
        employee.birthday = emp_birthday or None
        employee.status_flag = fis_rec[F74.status_flag] or None
        employee.pension_plan = fis_rec[F74.pension_status].upper() == 'Y'
        employee.pay_type = ('salary', 'hourly')[fis_rec[F74.pay_type].upper() == 'H']
        employee.hourly_rate = fis_rec[F74.hourly_rate]
        employee.last_raise = fix_date(fis_rec[F74.last_raise]) or None
        employee.marital = ('single', 'married')[fis_rec[F74.marital_status].upper() == 'M']
        employee.gender = ('male', 'female')[fis_rec[F74.gender].upper() == 'F']
        employee.emergency_contact = NameCase(fis_rec[F74.emergency_contact]) or None
        employee.emergency_number = fix_phone(fis_rec[F74.emergency_phone]) or None
        employee.federal_exemptions = int(fis_rec[F74.exempt_fed] or 0)
        employee.state_exemptions = int(fis_rec[F74.exempt_state] or 0)
        return (XidRec.fromdict(employee, imd), )


class IFMS(Synchronize):

    # product formula, 320
    TN = 320
    FN = 'ifms'
    F = 'F320'
    RE = r'10(..........)..(...)0'
    OE = (
            'fnx.pd.product.formula',
            'fis.product.formula',
            )[odoo_erp]
    IMD = 'product_formula'
    OE_KEY = 'name'
    OE_FIELDS = [
            'id', 'name', 'formula', 'description', 'coating', 'allergens',
            ]
    FIS_SCHEMA = [
            F320.formula_id, F320.rev_no,
            F320.desc, F320.coating, F320.allergens,
            ]
    FIS_IGNORE_RECORD = lambda self, rec: len(rec[F320.formula_id]) != 6
    #
    ProductFormula = XmlLink

    def convert_fis_rec(self, fis_rec, use_ignore=False):
        "product formula"
        # convert the record into the following fields:
        #   formula, description, coating, allergens
        #
        # using:
        #   F320.formula, F320.rev_no, F320.desc, F320.coating, F320.allergens
        #
        if use_ignore and self.FIS_IGNORE_RECORD(fis_rec):
            return ()
        key = fis_rec[F320.formula_id]
        imd = AttrDict(
                id=0,
                model=self.OE,
                res_id=0,
                module='fis',
                name=self.calc_xid(key),
                )
        formula = AttrDict().fromkeys(self.OE_FIELDS, None)
        formula.name = key
        formula.formula = '%s-%s' % (key, fis_rec[F320.rev_no])
        formula.description = fis_rec[F320.desc] or None
        formula.coating = fis_rec[F320.coating] or None
        formula.allergens = fis_rec[F320.allergens] or None
        return (XidRec.fromdict(formula, imd), )


class IFDT(Synchronize):

    # product ingredient
    TN = 322
    FN = 'ifdt'
    F = 'F322'
    RE = r'10(..........)..(...)0...'
    OE = (
            'fnx.pd.product.ingredient',
            'fis.product.formula.ingredient',
            )[odoo_erp]

    IMD = 'product_ingredient'
    OE_KEY = 'name'
    OE_FIELDS = [
            'id', 'name', 'sequence', 'formula_id', 'item_id', 'qty_needed', 'qty_desc',
            ]
    FIS_SCHEMA = [
            F322.formula_id, F322.rev_no, F322.desc_batch_1, F322.line_no,
            ]
    FIS_IGNORE_RECORD = lambda self, rec: (
              not IFMS.ProductFormula('%s-%s' % (rec[F322.formula_id], rec[F322.rev_no]))
              or rec[F322.ingr_code_batch_1] not in self.oe_items
              or rec[F322.ingr_code_batch_1] in ignored_ingredients
              or rec[F322.qty_batch_1] <= 0
              )

    def __init__(self, oe, config, *args, **kwds):
        super(IFDT, self).__init__(oe, config, *args, **kwds)
        #
        # load formulae from OE
        #
        IFMS(oe, config).reify()

    def convert_fis_rec(self, fis_rec, use_ignore=False):
        "product ingredient"
        # convert the record into the following fields:
        #   formula_id, item_id, qty_needed, qty_desc
        #
        # using:
        #   F322.formula_id, F322.rev_no,
        #   F322.ingr_code_batch_1, F322.qty_batch_1, F322.units_batch_1
        #
        if use_ignore and self.FIS_IGNORE_RECORD(fis_rec):
            return ()
        oe_key = '%s-%s' % (fis_rec[F322.formula_id], fis_rec[F322.rev_no])
        fis_key = fis_rec[F322.formula_id], fis_rec[F322.rev_no]
        item = fis_rec[F322.ingr_code_batch_1]
        imd = AttrDict(
                id=0,
                model=self.OE,
                res_id=0,
                module='fis',
                name=self.calc_xid(oe_key),
                )
        ingredient = AttrDict().fromkeys(self.OE_FIELDS, None)
        ingredient.formula_id = IFMS.ProductFormula(fis_key)
        ingredient.item_id = NVTY.Product(item)
        ingredient.name = '%s:%s' % (oe_key, item)
        ingredient.sequence = int(fis_rec[F322.line_no] or 0)
        ingredient.qty_needed = fis_rec[F322.qty_batch_1]
        ingredient.qty_desc = fis_rec[F322.units_batch_1] or None
        return (XidRec.fromdict(ingredient, imd), )


class IFPP0(Synchronize):

    # production order
    TN = 328
    FN = 'ifpp0'
    F = 'F328'
    RE = r'10(......)000010000'
    OE = (
            'fnx.pd.order',
            'fis.production.order',
            )[odoo_erp]
    IMD = 'production_order'
    OE_KEY = 'order_no'
    OE_FIELDS = [
            'id', 'order_no', 'completed_fis_qty', 'confirmed', 'item_id',
            'formula_code', 'line_id', 'schedule_date', 'finish_date',
            'line_id_set', 'schedule_date_set', 'state',
            ]
    OE_FIELDS.append(('dept','department')[odoo_erp])
    FIS_SCHEMA = [
            F328.order_no, F328.produced, F328.order_confirmed, F328.prod_no,
            F328.formula_id, F328.formula_rev, F328.dept_id, F328.prod_line,
            F328.prod_scheduled_date, F328.prod_date, F328.units_produced,
            ]
    #
    ProductionOrder = XmlLink

    def __init__(self, oe, config, *args, **kwds):
        super(IFPP0, self).__init__(oe ,config, *args, **kwds)
        #
        # get current production lines from OE as there may be user
        # specified multi-lines
        #
        # line_table = ('fis_integration.production_line','fis.production.line')[odoo_erp]
        multiline_table = ('fnx.pd.multiline','fis.production.multiline')[odoo_erp]
        multiline_entry_table = ('fnx.pd.multiline.entry','fis.production.multiline.entry')[odoo_erp]
        cnvzf_name = '%s_%%_%s' % (CNVZf.F, CNVZf.IMD)
        self.production_lines = dict(
                (r.xml_id, Many2One(r.id, r.xml_id, CNVZf.OE))
                for r in self.get_xid_records(
                    self.erp,
                    domain=[('module','=','fis'),('name','=like',cnvzf_name)],
                    fields=['id', 'xml_id'],
                    context=self.context,
                    ))
        multi_line_entries = dict(
                (r.id, r.line_id)
                for r in get_records(
                    self.erp,
                    multiline_entry_table,
                    fields=['id','line_id'],
                    ))
        multi_lines = dict(
                (r.key, r.line_ids)
                for r in get_records(
                    self.erp,
                    multiline_table,
                    fields=['key','line_ids'],
                    ))
        for key, lines in multi_lines.items():
            for i, line in enumerate(lines):
                lines[i] = CNVZf.ProductionLine(line.name, line.id)
            self.production_lines[key] = lines
        IFMS(oe, config).reify(['coating','allergens'])

    def convert_fis_rec(self, fis_rec, use_ignore=False):
        "sales production order"
        # convert the record into the following fields:
        #   id, order_no, completed_fis_qty, confirmed, item_id,
        #   formula_code, dept, line_id,
        #   schedule_date, finish_date, completed_fis_qty,
        #
        # F328.order_no, F328.produced, F328.order_confirmed, F328.prod_no,
        # F328.formula_id, F328.formula_rev, F328.dept_id, F328.prod_line,
        # F328.prod_scheduled_date, F328.prod_date, F328.units_produced,
        #
        # multiple lines ARE NOT split
        #
        if use_ignore and self.FIS_IGNORE_RECORD(fis_rec):
            return ()
        key = fis_rec[F328.order_no]
        item = fis_rec[F328.prod_no]
        imd = AttrDict(
                id=0,
                model=self.OE,
                res_id=0,
                module='fis',
                name=self.calc_xid(key),
                )
        order = AttrDict().fromkeys(self.OE_FIELDS, None)
        order.order_no = key
        order.item_id = NVTY.Product(item)
        order.completed_fis_qty = fis_rec[F328.units_produced]
        status = fis_rec[F328.produced]
        if status == 'Y':
            order.state = 'complete'
        elif status == 'X':
            order.state = 'cancelled'
        else:
            order.state = 'draft'
        order.confirmed = (None, 'fis')[fis_rec[F328.order_confirmed] == 'Y']
        formula = '%s-%s' % (fis_rec[F328.formula_id], fis_rec[F328.formula_rev])
        order.formula_code = ('[%s] %s' % (formula, fis_rec[F328.label_name])).replace('\x01','')
        order.dept = fis_rec[F328.dept_id] or None
        line_id = fis_rec[F328.prod_line]
        if line_id and len(line_id) == 1:
            line_id = '0' + line_id
        order.line_id = self.production_lines.get(line_id)
        order.line_id_set = False
        sched_date = fix_date(fis_rec[F328.prod_scheduled_date], 'ymd') or None
        order.schedule_date = sched_date
        order.schedule_date_set = False
        fin_date = fix_date(fis_rec[F328.prod_date], 'mdy') or None
        if fin_date:
            fin_date = local_to_utc(DateTime.combine(fin_date, Time(17)))
        order.finish_date = fin_date
        order.completed_fis_qty = fis_rec[F328.units_produced] or 0
        formula = IFMS.ProductFormula(formula)
        if formula:
            order.coating = formula.coating
            order.allergens = formula.allergens
        #
        # do we need more than one order?
        #
        if not isinstance(order.line_id, list):
            return (XidRec.fromdict(order, imd), )
        #
        # yes we do
        #
        orders = []
        template = order
        total = len(template.line_id)
        for i, line in enumerate(template.line_id, start=1):
            key = '%s-%d_%d' % (template.order_no, i, total)
            imd = AttrDict(
                    id=0,
                    model=self.OE,
                    res_id=0,
                    module='fis',
                    name=self.calc_xid(key),
                    )
            order = AttrDict().fromkeys(self.OE_FIELDS, None)
            order.update(template)
            order.order_no = key
            order.line_id = line
            orders.append(XidRec.fromdict(order, imd))
        return tuple(orders)

    def normalize_records(self, fis_rec, oe_rec):
        super(IFPP0, self).normalize_records(fis_rec, oe_rec)
        #
        fis_rec.state = oe_rec.state
        # if oe_rec already has a finish date, remove it
        # TODO: figure out why a changed finish_date isn't updated on OpenERP
        if oe_rec.finish_date:
            fis_rec.finish_date = oe_rec.finish_date
        if oe_rec.line_id_set:
            fis_rec.line_id_set = True
            fis_rec.line_id = oe_rec.line_id
        if oe_rec.schedule_date_set:
            fis_rec.schedule_date_set = True
            fis_rec.schedule_date = oe_rec.schedule_date

    def handle_production_order(method):
        #
        # to fix wrong names format
        #   update fnx_pd_order set order_no = regexp_replace(order_no, '(\d*)_(\d_\d)', '\1-\2');
        #
        global ifms
        cutoff_date = cutoff.strftime('%Y-%m-%d')
        print('processing production orders (IFPP0 - 328)', border=('flag', '#'))
        print('EXTRA ->', EXTRA)
        context = {'fis-updates': True, 'active_test': False}
        fnx_pd_order = Model(oe.get_model('fnx.pd.order'), 'ifpp0', 'F328', context, RAISE_ON_EXCEPTION)
        all_oe_records = {}
        all_fis_records = {}
        # these are for tracking original old/new records
        new_order_records = {}
        old_order_records = {}
        # these  are for tracking old/new versions of changed records
        old_changed_order_records = {}
        new_changed_order_records = {}
        # these are for added/deleted records
        added_order_records = {}
        deleted_records = {}
        # the counts
        changed_count = 0
        added_count = 0
        deleted_count = 0
        #
        # get the "old" data from:
        # - quick -> old fis file
        # - full -> current OpenERP data
        #
        print('gathering data')
        ifpp0 = fisData(328, rematch=r'10(......)000010000')
        ifms = fisData(320, rematch=r'10(..........)..(...)0')
        print('  ', ifpp0.filename, len(ifpp0), verbose=2)
        print('  ', ifms.filename, len(ifms), verbose=2)
        #
        target_order = EXTRA.get('order')
        def ignore_order(order):
            return target_order and target_order != order[F328.order_no]
        #
        if method == 'quick':
            #
            # for a quick compare we can use the fis records as-is when looking for changes
            #
            ifpp_old = fisData(328, rematch=r'10(......)000010000', data_path=config.network.fis_data_local_old_path)
            print(ifpp_old.filename, verbose=2)
            print('collecting changed records')
            changes, added, deleted = get_changed_fis_records(
                    ifpp_old.values(),
                    ifpp0.values(),
                    enum_schema=[
                        F328.order_no, F328.produced, F328.order_confirmed, F328.prod_no,
                        F328.formula_id, F328.formula_rev, F328.dept_id, F328.prod_line,
                        F328.prod_scheduled_date, F328.prod_date, F328.units_produced,
                        ],
                    address_fields=[],
                    ignore=ignore_order,
                    )
            #
            # and convert the new and deleted records
            #
            print('sorting %d new and %d deleted records' % (len(added), len(deleted)))
            for fis_rec in added:
                for rec in split_steps(convert_ifpp0_rec(fis_rec)).values():
                    added_order_records[rec.order_no] = add_ac(fis_rec, rec)
            for fis_rec in deleted:
                for rec in split_steps(convert_ifpp0_rec(fis_rec)).values():
                    deleted_records[rec.order_no] = rec
            for old, new, diffs in ProgressView(
                    iterable=changes,
                    message='sorting $total changed records',
                    view_type=VIEW_TYPE,
                ):
                order_no = old[F328.order_no]
                old_order = convert_ifpp0_rec(old)
                old_order_records[order_no] = old_order
                new_order = convert_ifpp0_rec(new)
                new_order_records[order_no] = new_order
                # changes at the FIS level don't always translate to changes at the OpenERP level
                if old_order != new_order:
                    # split orders up
                    old_orders = split_steps(old_order)
                    new_orders = split_steps(new_order)
                    for order_no in set(old_orders.keys() + new_orders.keys()):
                        old_order = old_orders.get(order_no)
                        new_order = new_orders.get(order_no)
                        if old_order is None:
                            added_order_records[order_no] = new_order
                        elif new_order is None:
                            if old_order.state not in ('complete', 'cancelled'):
                                deleted_records[order_no] = old_order
                        else:
                            old_changed_order_records[order_no] = old_order
                            new_changed_order_records[order_no] = new_order
                assert set(old_changed_order_records.keys()) == set(new_changed_order_records.keys()),\
                        "old and new order records mismatch"
            all_oe_records = dict([
                (r.order_no, r)
                for r in fnx_pd_order.read(
                    domain=[
                        ('order_no','in',
                            added_order_records.keys()
                            + deleted_records.keys()
                            + old_changed_order_records.keys()
                            ),
                        ],
                    fields=[
                        'id', 'order_no', 'completed_fis_qty', 'confirmed', 'item_id',
                        'formula_code', 'dept', 'line_id', 'schedule_date', 'finish_date',
                        'line_id_set', 'schedule_date_set', 'state',
                        ],
                    )])
        elif method == 'full':
            #
            # for a full compare we fully convert the fis records, the compare against all open
            # orders and closed/cancelled orders referenced by the fis records
            #
            # fis first
            #
            print('getting fis records')
            order_numbers = []
            for fis_rec in ifpp0.values():
                for rec in split_steps(convert_ifpp0_rec(fis_rec)).values():
                    if target_order and not rec.order_no.startswith(target_order):
                        continue
                    order_numbers.append(rec.order_no)
                    all_fis_records[rec.order_no] = rec
            #
            # and then openerp
            #
            print('getting openerp records')
            all_oe_records = dict([
                (r.order_no, r)
                for r in fnx_pd_order.read(
                    domain=[
                        '|',
                        ('order_no','in',order_numbers),
                        ('state','in',['draft','sequenced','released','running','stopped']),
                        ],
                    fields=[
                        'id', 'order_no', 'completed_fis_qty', 'confirmed', 'item_id',
                        'formula_code', 'dept', 'line_id', 'schedule_date', 'finish_date',
                        'line_id_set', 'schedule_date_set', 'state',
                        ],
                    )])
            #
            # and then we compare
            #
            print('sorting changed, new, and deleted records')
            for order_no in set(all_oe_records.keys() + all_fis_records.keys()):
                old_order = all_oe_records.get(order_no)
                new_order = all_fis_records.get(order_no)
                if old_order is None:
                    added_order_records[order_no] = new_order
                    continue
                elif new_order is None:
                    if old_order.state not in ('complete', 'cancelled'):
                        deleted_records[order_no] = old_order
                    continue
                # save for later comparison
                old_changed_order_records[order_no] = old_order
                new_changed_order_records[order_no] = new_order
            assert set(old_changed_order_records.keys()) == set(new_changed_order_records.keys()),\
                    "old and new order records mismatch"
        else:
            abort('unknown METHOD: %r' % (method, ))
        #
        # at this point all records are in AttrDict format and divided by
        # new, deleted, and changed
        #
        # process changes
        #
        print('%d potentially changed records' % len(old_changed_order_records), verbose=2)
        for order_no, new_order in ProgressView(
                iterable=new_changed_order_records.items(),
                message='double-checking $total changes',
                view_type=VIEW_TYPE
            ):
            # is order out of range?
            if new_order.schedule_date > cutoff_date:
                deleted_records[order_no] = new_order
                del old_changed_order_records[order_no]
                del new_changed_order_records[order_no]
                continue
            old_order = all_oe_records.get(order_no)
            if old_order is None:
                added_order_records[order_no] = new_order
                del old_changed_order_records[order_no]
                del new_changed_order_records[order_no]
                continue
            # now normalize records for good comparison
            new_order.id = old_order.id
            new_order.state = new_order.state or old_order.state
            # if old_order already has a finish date, remove it
            # TODO: figure out why a changed finish_date isn't updated on OpenERP
            if old_order.finish_date:
                del old_order.finish_date
                del new_order.finish_date
            if old_order.line_id_set:
                new_order.line_id_set = True
                new_order.line_id = old_order.line_id
            if old_order.schedule_date_set:
                new_order.schedule_date_set = True
                new_order.schedule_date = old_order.schedule_date
            # and check for actionable changes
            if new_order == old_order:
                del old_changed_order_records[order_no]
                del new_changed_order_records[order_no]
                continue
            else:
                # update old_changed_order_records in case method is 'quick'
                old_changed_order_records[order_no] = old_order
        #
        changed_map = combine_by_value(old_changed_order_records, new_changed_order_records)
        print('%d groups in changed_map' % len(changed_map), verbose=2)
        print('%d records in those groups' % sum([len(r) for r in changed_map.values()]), verbose=2)
        for changes, records in ProgressView(
                iterable=sorted(changed_map.items()),
                message='processing changed records',
                view_type=VIEW_TYPE,
            ):
            values = dict(changes)
            order_nos = [r.order_no for r in records]
            print('values: ', values, verbose=2)
            print('order numbers: ', order_nos, verbose=2)
            oe_ids = dict([
                (r.order_no, r)
                for r in
                    fnx_pd_order.read(domain=[('order_no','in',order_nos)], fields=['id','order_no'])
                    ])
            changed_count += len(oe_ids)
            logger.info(
                    'F328: changing -- %s  -->  %s',
                    order_nos,
                    ', '.join("%s=%r" % (k, v) for k, v in sorted(changes))
                    )
            if LIST_RECORDS:
                body = []
                for rec in records:
                    body.append(('  F328:%s' % (rec.order_no, )))
                if script_verbosity > 1:
                    body.append('---')
                    body.append(str(AttrDict(changes)))
                echo('\n'.join(body), border='box' if script_verbosity > 1 else None)
            if not DRYRUN:
                for order_no in order_nos:
                    fnx_pd_order.write(order_no, oe_ids[order_no].id, values, context={})
        # process additions, checking first for already existing orders
        print('adding records')
        order_nos = added_order_records.keys()
        existing_order_nos = [o.order_no for o in all_oe_records.values()]
        for order_no, order in added_order_records.items():
            if order_no in existing_order_nos:
                fnx_pd_order.error('FIS Order F328:%s already exists in OpenERP' % (order_no, ))
                continue
            if cutoff < order.schedule_date:
                continue
            added_count += 1
            logger.info(
                    'F328:%s -- adding -- %s',
                    order_no,
                    (', '.join(['%s=%r' % (k, v) for k, v in order.items()]))
                    )
            if LIST_RECORDS:
                echo('  F328:%s' % order_no, end='  ')
                print(','.join(['%s=%r' % (k, v) for k, v in order.items()]), end='', verbose=2)
                echo('\n', '- -' * 25)
            if not DRYRUN:
                fnx_pd_order.create(order_no, order)
        #
        # process deletions, but only for orders that still exist
        #
        print('removing records')
        order_nos = deleted_records.keys()
        orders = dict([(o.id, o) for o in all_oe_records.values() if o.order_no in deleted_records])
        if orders:
            deleted_count = len(orders)
            logger.info(
                    'F328 -- removing -- %s',
                    ', '.join(order_nos)
                    )
            if LIST_RECORDS:
                echo('\n'.join(['  F328:%s' % o.order_no for o in orders.values()]))
            if not DRYRUN:
                fnx_pd_order.unlink(orders.keys())
        #
        print('%d orders changed\n%d orders added\n%d orders deleted'
                % (changed_count, added_count, deleted_count, ),
                border='box',
                )


class IFPP1(Synchronize):

    # production order ingredient
    TN = 329
    FN = 'ifpp1'
    F = 'F329'
    RE = r"10(......)000011..."
    OE = (
            'fnx.pd.ingredient',
            'fis.production.ingredient',
            )[odoo_erp]
    IMD = 'production_ingredient'
    OE_KEY = 'name'
    OE_FIELDS = [
            'id', 'name', 'sequence', 'order_ids', 'item_id', 'qty_needed', 'qty_desc',
            ]
    FIS_SCHEMA = [
            F329.order_no, F329.ingr_code_batch_1, F329.units_batch_1, F329.qty_batch_1, F329.formula_line_no
            ]
    def FIS_IGNORE_RECORD(self, rec):
        if rec[F329.item_type_batch_1] == 'M':
            return True
        elif rec[F329.ingr_code_batch_1] in ignored_ingredients:
            return True
        elif rec[F329.qty_batch_1] <= 0:
            return True
        order_no = rec[F329.order_no]
        if order_no not in self.oe_orders:
            return True
        # if all([order.state in ['complete','cancelled'] for order in oe_orders[order_no]]):
        #     return True
        return False

    def __init__(self, oe, config, *args, **kwds):
        super(IFPP1, self).__init__(oe, config, *args, **kwds)
        #
        # get batch quantity from order
        #
        self.ifpp0 = IFPP0(oe, config)
        self.ifpp0.reify(fields=['batches'])
        #
        # add coating and allergens from product formula
        #
        IFMS(oe, config).reify(fields=['coating','allergens'])
        #
        # get all valid order numbers from OE
        #
        ifpp0_name = '%s_%%_%s' % (IFPP0.F, IFPP0.IMD)
        orders = self.get_xid_records(
                self.erp,
                domain=[('module','=','fis'),('name','=like',ifpp0_name)],
                fields=['id','order_no'],
                context=self.context,
                )
        self.oe_orders = {}
        # combine multiple steps under main order number, and convert order references
        # to Many2One
        for order in orders:
            self.oe_orders.setdefault(
                    order.order_no[:6], []
                    ).append(
                    Many2One(order.id, order.order_no, IFPP0.OE)
                    )
        # convert single order tuples to individual item
        # for order_no, orders in self.oe_orders.items():
        #     if len(orders) == 1:
        #         self.oe_orders[order_no] = orders[0]

    def convert_fis_rec(self, fis_rec, use_ignore=False):
        "order ingredient"
        # convert the record into the following fields:
        #   name, order_id, item_id, qty_needed, qty_desc
        #
        # multiply qty_needed by F328.no_of_batches_a
        #
        # using:
        #   F329.order_no, F329.ingr_code_batch_1, F329.qty_batch_1, F329.units_batch_1
        #
        if use_ignore and self.FIS_IGNORE_RECORD(fis_rec):
            return ()
        order = fis_rec[F329.order_no]
        item = fis_rec[F329.ingr_code_batch_1]
        key = '%s:%s' % (order, item)
        imd = AttrDict(
                id=0,
                model=self.OE,
                res_id=0,
                module='fis',
                name=self.calc_xid(key),
                )
        ingredient = AttrDict().fromkeys(self.OE_FIELDS, None)
        ingredient.order_ids = self.oe_orders.get(fis_rec[F329.order_no])
        ingredient.item_id = NVTY.Product(fis_rec[F329.ingr_code_batch_1])
        ingredient.name = key
        ingredient.sequence = int(fis_rec[F329.formula_line_no] or 0)
        ingredient.qty_desc = fis_rec[F329.units_batch_1] or None
        product_formula = IFMS.ProductFormula(key)
        production_order = IFPP0.ProductionOrder(order)
        if product_formula:
            ingredient.coating = product_formula.coating
            ingredient.allergens = product_formula.allergens
        if production_order:
            batches_needed = production_order.batches
        else:
            batches_needed = 0
        ingredient.qty_needed = fis_rec[F329.qty_batch_1] * batches_needed
        return (XidRec.fromdict(ingredient, imd), )

    def handle_production_detail(method):
        global ifpp0, oe_orders
        print('processing product ingredients (IFPP1 - 329)', border=('flag', '#'))
        print('EXTRA ->', EXTRA)
        context = {'fis-updates': True, 'active_test': False}
        fnx_pd_ingredient = Model(oe.get_model('fnx.pd.ingredient'), 'ifpp1', 'F329', context, RAISE_ON_EXCEPTION)
        all_oe_records = {}
        all_fis_records = {}
        # all old and new records
        old_ingredient_records = {}
        new_ingredient_records = {}
        # these are for tracking old/new versions of changed records
        old_changed_ingredient_records = {}
        new_changed_ingredient_records = {}
        # these are for added/deleted records
        added_ingredient_records = {}
        deleted_records = {}
        # the counts
        changed_count = 0
        added_count = 0
        deleted_count = 0
        #
        # get the "old" data from:
        # - quick -> old fis file
        # - full -> current OpenERP data
        #
        print('gathering data')
        oe_orders = {}
        oe_static_orders = set()
        for order in get_records(oe, 'fnx.pd.order', fields=['id','order_no','state']):
            order.id = Many2One(order.id, order.order_no)
            if order.state in ('complete', 'cancelled'):
                oe_static_orders.add(order.order_no[:6])
            else:
                oe_orders.setdefault(order.order_no[:6], []).append(order)
        for static_order in oe_static_orders:
            oe_orders.pop(static_order, None)
        print('%d orders' % len(oe_orders))
        oe_items = dict([
            (i.xml_id, Many2One(i.id, i.xml_id))
            for i in get_records(oe, 'product.product', fields=['id','xml_id'], domain=[('module','=','F135')])
            ])
        print('%d items found' % len(oe_items), verbose=2)
        ifpp0 = fisData(328, rematch=r"10(......)000010000")
        ifpp1 = fisData(329, rematch=r"10(......)000011...")
        print('%s:  %d records' % (ifpp1.filename, len(ifpp1)), verbose=2)
        #
        target_order = EXTRA.get('order')
        def ignore_order_detail(rec):
            if target_order and rec[F329.order_no] != target_order:
                return True
            if rec[F329.item_type_batch_1] == 'M':
                return True
            elif rec[F329.ingr_code_batch_1] in ignored_ingredients:
                return True
            elif rec[F329.qty_batch_1] <= 0:
                return True
            order_no = rec[F329.order_no]
            if order_no not in oe_orders:
                return True
            if all([order.state in ['complete','cancelled'] for order in oe_orders[order_no]]):
                return True
            return False
        #
        if method == 'quick':
            #
            # for a quick compare we can use the fis records as-is when looking for changes
            #
            ifpp1_old = fisData(329, rematch=r"10(......)000011...", data_path=config.network.fis_data_local_old_path)
            print('%s:  %d records' % (ifpp1_old.filename, len(ifpp1_old)), verbose=2)
            print('collecting changed records')
            changes, added, deleted = get_changed_fis_records(
                    ifpp1_old.values(),
                    ifpp1.values(),
                    enum_schema=[
                        F329.order_no, F329.ingr_code_batch_1, F329.units_batch_1, F329.qty_batch_1, F329.formula_line_no
                        ],
                    address_fields=[],
                    ignore=ignore_order_detail,
                    key=(F329.company_id, F329.order_no, F329.ingr_code_batch_1),
                    )
            #
            # and convert the new and deleted records
            #
            print('sorting new and deleted records')
            for fis_rec in added:
                new_ingredient = convert_ifpp1_rec(fis_rec)
                order_no = new_ingredient.order_id
                if order_no in oe_orders:
                    if any(o.state not in ('complete','cancelled') for o in oe_orders[order_no]):
                        new_ingredient.order_ids = [o.id for o in oe_orders[order_no]]
                        del new_ingredient.order_id
                else:
                    fnx_pd_ingredient.error('F329:%s: unable to find in OpenERP' % order_no)
                new_ingredient.item_id = oe_items[new_ingredient.item_id]
                added_ingredient_records[new_ingredient.name] = new_ingredient
                new_ingredient_records[new_ingredient.name] = new_ingredient
            for fis_rec in deleted:
                old_ingredient = convert_ifpp1_rec(fis_rec)
                order_no = old_ingredient.order_id
                if order_no in oe_orders:
                    if all(o.state not in ('complete','cancelled') for o in oe_orders[order_no]):
                        deleted_records[old_ingredient.name] = old_ingredient
                        old_ingredient_records[old_ingredient.name] = old_ingredient
                else:
                    fnx_pd_ingredient.error('F329:%s: unable to find in OpenERP' % order_no)
            for old, new, diffs in ProgressView(
                    iterable=changes,
                    message='sorting changed records',
                    view_type=VIEW_TYPE,
                ):
                new_ingredient = convert_ifpp1_rec(new)
                old_ingredient = convert_ifpp1_rec(old)
                # changes at the FIS level don't always translate to changes at the OpenERP level
                if old_ingredient == new_ingredient:
                    continue
                order_no = new_ingredient.order_id
                if order_no in oe_orders:
                    order_ids = [o.id for o in oe_orders[order_no]]
                    if any(o.state not in ('complete','cancelled') for o in oe_orders[order_no]):
                        old_ingredient.order_ids = order_ids
                        new_ingredient.order_ids = order_ids
                        del old_ingredient.order_id
                        del new_ingredient.order_id
                        old_ingredient.item_id = oe_items[old_ingredient.item_id]
                        new_ingredient.item_id = oe_items[new_ingredient.item_id]
                        old_changed_ingredient_records[old_ingredient.name] = old_ingredient
                        old_ingredient_records[old_ingredient.name] = old_ingredient
                        new_changed_ingredient_records[new_ingredient.name] = new_ingredient
                        new_ingredient_records[new_ingredient.name] = new_ingredient
                else:
                    fnx_pd_ingredient.error('F329:%s: unable to find in OpenERP' % order_no)
            assert set(old_changed_ingredient_records.keys()) == set(new_changed_ingredient_records.keys()),\
                    "old and new ingredient records mismatch\n%r\%r" % (
                            sorted(old_changed_ingredient_records),
                            sorted(new_changed_ingredient_records),
                            )
            all_oe_records = dict([
                (r.name, r)
                for r in fnx_pd_ingredient.read(
                    domain=[('name','in',
                            added_ingredient_records.keys()
                            +deleted_records.keys()
                            +old_changed_ingredient_records.keys()
                            )],
                    fields=[
                        'id', 'name', 'order_ids', 'item_id', 'qty_needed', 'qty_desc',
                        ],
                    )])
            # update old records to OpenERP version;
            # possibly move records to added category
            for name, old_ingredient in old_changed_ingredient_records.items():
                if name in all_oe_records:
                    old_changed_ingredient_records[name] = all_oe_records[name]
                    new_changed_ingredient_records[name].id = all_oe_records[name].id
                    continue
                elif name in new_ingredient_records:
                    # record doesn't exist - add to added_ingredient_records and remove
                    # from [old|new]_changed_ingredient_records
                    added_ingredient_records[name] = new_ingredient_records[name]
                else:
                    fnx_pd_ingredient('%s not found in OpenERP' % name)
                del old_changed_ingredient_records[name]
                del new_changed_ingredient_records[name]
        elif method == 'full':
            #
            # for a full compare we fully convert the fis records, then compare against all
            # ingredients
            #
            # fis first
            #
            print('getting fis records')
            for fis_rec in ifpp1.values():
                if ignore_order_detail(fis_rec):
                    continue
                ingredient = convert_ifpp1_rec(fis_rec)
                all_fis_records[ingredient.name] = ingredient
            #
            # and then openerp
            #
            print('\ngetting openerp records')
            all_oe_records = dict([
                (r.name, r)
                for r in fnx_pd_ingredient.read(
                    domain=[('name','in',all_fis_records.keys())],
                    fields=[
                        'id', 'name', 'sequence', 'order_ids', 'item_id', 'qty_needed', 'qty_desc',
                        ],
                    )])
            #
            # and then we compare
            #
            print('sorting changed, new, and deleted records')
            for name in set(all_oe_records.keys() + all_fis_records.keys()):
                old_ingredient = all_oe_records.get(name)
                new_ingredient = all_fis_records.get(name)
                if new_ingredient is None:
                    deleted_records[name] = old_ingredient
                    continue
                order_ids = oe_orders.get(new_ingredient.order_id)
                if order_ids is None:
                    continue
                order_ids = [o.id for o in order_ids]
                new_ingredient.order_ids = order_ids
                del new_ingredient.order_id
                item_id = oe_items.get(new_ingredient.item_id)
                if item_id is None:
                    continue
                new_ingredient.item_id = item_id
                if old_ingredient is None:
                    added_ingredient_records[name] = new_ingredient
                    continue
                old_ingredient.pop('order_id', None)
                # now normalize records for good comparison
                new_ingredient.id = old_ingredient.id
                if old_ingredient != new_ingredient:
                    old_changed_ingredient_records[name] = old_ingredient
                    new_changed_ingredient_records[name] = new_ingredient
            assert set(old_changed_ingredient_records.keys()) == set(new_changed_ingredient_records.keys()),\
                    "old and new ingredient records mismatch"
        else:
            abort('unknown METHOD: %r' % (method, ))
        #
        # at this point all records are in AttrDict format and divided by
        # new, deleted, and changed
        #
        # process additions, checking first for already existing ingredients
        print('adding records')
        for name, ingredient in added_ingredient_records.items():
            if name in all_oe_records:
                fnx_pd_ingredient.error('FIS Order F329:%s already exists in OpenERP' % (name, ))
                continue
            added_count += 1
            ingredient.order_ids = [(6, 0, ingredient.order_ids)]
            logger.info(
                    'F329:%s -- adding -- %s',
                    name,
                    (', '.join(['%s=%r' % (k, v) for k, v in ingredient.items()]))
                    )
            if LIST_RECORDS:
                echo('  F329:%s' % name, end='  ')
                print(','.join(['%s=%r' % (k, v) for k, v in ingredient.items()]), end='', verbose=2)
                echo()
            if not DRYRUN:
                fnx_pd_ingredient.create(name, ingredient)
        #
        # process deletions, but only for ingredients that still exist
        #
        print('removing records')
        missing_ingredients = dict([
            (i.name, i)
            for i in all_oe_records.values()
            if i.name in deleted_records
            ])
        if missing_ingredients:
            deleted_count = len(missing_ingredients)
            logger.info(
                    'F329 -- removing -- %s',
                    ', '.join(missing_ingredients.keys())
                    )
            if LIST_RECORDS:
                echo('\n'.join(['  F329:%s' % i.name for i in missing_ingredients.values()]))
            if not DRYRUN:
                fnx_pd_ingredient.unlink(missing_ingredients.keys())
        #
        # process changes
        #
        changed_map = combine_by_value(old_changed_ingredient_records, new_changed_ingredient_records)
        for changes, records in ProgressView(
                iterable=sorted(changed_map.items()),
                message='processing changed records',
                view_type=VIEW_TYPE,
            ):
            values = AttrDict(changes)
            if 'order_ids' in values:
                values.order_ids = [(6, 0, values.order_ids)]
            records = list(records)
            oe_ids = [o.id for o in records]
            names = [o.name for o in records]
            assert len(oe_ids)
            changed_count += len(oe_ids)
            logger.info(
                    'F329: changing -- %s  -->  %s',
                    names,
                    ', '.join("%s=%r" % (k, v) for k, v in sorted(changes))
                    )
            if LIST_RECORDS:
                body = []
                for i in records:
                    body.append(('  F329:%s' % (i.name, )))
                if script_verbosity > 1:
                    body.append('---')
                    body.append(str(values))
                echo('\n'.join(body), border='box' if script_verbosity > 1 else None)
            if not DRYRUN:
                fnx_pd_ingredient.write(', '.join(names), oe_ids, values, context={})
        #
        print('%d ingredients changed\n%d ingredients added\n%d ingredients deleted'
                % (changed_count, added_count, deleted_count, ),
                border='box',
                )

class NVTY(Synchronize):

    # products, 135
    TN = 135
    FN = 'nvty'
    F = 'F135'
    RE = r'......101000    101\*\*'
    OE = 'product.product'
    IMD = 'product_product'
    OE_KEY = 'xml_id'
    OE_KEY_MODULE = 'F%s' % TN
    if odoo_erp:
        OE_FIELDS_QUICK = [
                'id', 'fis_module', 'fis_id', 'active', 'name', 'fis_name', 'fis_qty_on_hand',
                'fis_availability_code', 'sale_ok', 'fis_whsle_price', 'trademarks', 'ean13',
                'fis_location', 'fis_shipping_size', 'categ_id', 'fis_shelf_life',
                'default_code', 'weight', 'weight_net', 'list_price',
                ]
        OE_FIELDS_LONG = [
                'id', 'fis_module', 'fis_id', 'active', 'name', 'fis_name', 'fis_qty_on_hand',
                'fis_availability_code', 'sale_ok', 'fis_whsle_price', 'trademarks', 'ean13',
                'fis_location', 'fis_shipping_size', 'categ_id', 'fis_shelf_life', 'list_price',
                'fis_qty_produced', 'fis_10_day_produced', 'fis_21_day_produced',
                'fis_qty_consumed', 'fis_10_day_consumed', 'fis_21_day_consumed',
                'fis_qty_purchased', 'fis_10_day_purchased', 'fis_21_day_purchased',
                'fis_qty_sold', 'fis_10_day_sold', 'fis_21_day_sold',
                'fis_qty_available', 'fis_10_day_available', 'fis_21_day_available',
                'default_code', 'weight', 'weight_net',
                'fis_web_ingredients', 'fis_web_prep_instructions',
                ]
    else:
        OE_FIELDS_QUICK = [
                'id', 'module', 'xml_id', 'active', 'name', 'fis_name', 'fis_qty_on_hand',
                'fis_availability_code', 'sale_ok', 'fis_whsle_price', 'trademarks', 'ean13',
                'fis_location', 'fis_shipping_size', 'categ_id', 'warranty',
                'default_code', 'weight', 'weight_net', 'list_price',
                ]
        OE_FIELDS_LONG = [
                'id', 'module', 'xml_id', 'active', 'name', 'fis_name', 'fis_qty_on_hand',
                'fis_availability_code', 'sale_ok', 'fis_whsle_price', 'trademarks', 'ean13',
                'fis_location', 'fis_shipping_size', 'categ_id', 'warranty', 'list_price',
                'fis_qty_produced', 'fis_10_day_produced', 'fis_21_day_produced',
                'fis_qty_consumed', 'fis_10_day_consumed', 'fis_21_day_consumed',
                'fis_qty_purchased', 'fis_10_day_purchased', 'fis_21_day_purchased',
                'fis_qty_sold', 'fis_10_day_sold', 'fis_21_day_sold',
                'fis_qty_available', 'fis_10_day_available', 'fis_21_day_available',
                'default_code', 'weight', 'weight_net',
                'fis_web_ingredients', 'fis_web_prep_instructions',
                ]
    FIS_SCHEMA = [
            F135.item_id,
            F135.available_key, F135.sales_cat, F135.trademarkd,
            F135.catalog_location, F135.desc, F135.size, F135.upc_no, F135.primary_location,
            F135.supplier_id, F135.new_retail, F135.new_whlsl,
            F135.net_un_wt, F135.grs_un_wt,
            ]
    FIELDS_CHECK_IGNORE = ('name', )
    #
    Product = XmlLink

    def __init__(self, *args, **kwds):
        super(NVTY, self).__init__(*args, **kwds)
        module = 'fis' if odoo_erp == 1 else 'fis_integration'
        self.INVALID_CATEGORY = CNVZas.ProductCategory(INVALID_CATEGORY_XMLID)
        _, self.INVALID_CATEGORY.id = self.ir_model_data.get_object_reference(module, INVALID_CATEGORY_XMLID)

    def convert_fis_rec(self, fis_rec, use_ignore=False):
        # some fields come from non-FIS locations or are only updated once per
        # day -- those fields will not be evaluated here:
        # - name -> get_product_descriptions()
        # - fis_qty: _produced, _consumed, _purchased, _sold, _available
        # - fis_10_day: _produced, _consumed, _purchased, _sold, _available
        # - fis_21_day: _produced, _cosnumed, _purchased, _sold, _available
        if use_ignore and self.FIS_IGNORE_RECORD(fis_rec):
            return ()
        key = fis_rec[F135.item_id]
        imd = AttrDict(
                id=0,
                model=self.OE,
                res_id=0,
                module='fis',
                name=self.calc_xid(key),
                )
        item = AttrDict.fromkeys(self.OE_FIELDS, None)
        if odoo_erp:
            item.fis_id = key
            item.fis_module = self.OE_KEY_MODULE
            item.fis_shelf_life = float(fis_rec[F135.shelf_life_mos] or 0.0)
        else:
            item.xml_id = key
            item.module = self.OE_KEY_MODULE
            item.warranty = float(fis_rec[F135.shelf_life_mos] or 0.0)
        item.default_code = key
        name = NameCase(fis_rec[F135.desc].strip())
        name = re.sub('sunridge', 'SunRidge', name, flags=re.I) or None
        item.fis_name = name
        item.name = name
        item.active = True
        item.fis_availability_code = fis_rec[F135.available_key] or None
        # sale_ok actually tracks whether item is in the catalog
        item.sale_ok = len(fis_rec[F135.catalog_location]) == 10
        item.fis_whsle_price = fis_rec[F135.new_whlsl]
        item.trademarks = fis_rec[F135.trademarkd] or None
        item.ean13 = sanitize_ean13(fis_rec[F135.upc_no]) or None
        item.fis_location = fis_rec[F135.primary_location] or None
        item.fis_qty_on_hand = fis_rec[F135.qty_on_hand]
        item.weight = numeric(fis_rec[F135.grs_un_wt])
        item.weight_net = numeric(fis_rec[F135.net_un_wt])
        item.list_price = numeric(fis_rec[F135.new_retail])
        #
        shipping_size = fis_rec[F135.size].strip()
        if shipping_size.lower() in ('each','1 each','1/each'):
            shipping_size = '1 each'
        elif shipping_size:
            first, last = [], []
            letters = False
            for char in shipping_size:
                if char < ' ':
                    char = ' '
                if letters or char.isalpha():
                    last.append(char)
                    letters = True
                else:
                    first.append(char)
            if last == 'z':
                last = 'oz'
            shipping_size = ('%s %s' % (''.join(first).strip(), ''.join(last).strip())).strip()
        item.fis_shipping_size = shipping_size or None
        #
        category_code = fis_rec[F135.sales_cat].strip()
        if len(category_code) == 2 and category_code[0] in 'OIG':
            category_code = {'O':'0', 'I':'1', 'G':'6'}[category_code[0]] + category_code[1]
        item.categ_id = CNVZas.ProductCategory(category_code)
        #
        #
        return (XidRec.fromdict(item, imd), )

    def normalize_fis(self):
        super(NVTY, self).normalize_fis()
        print('getting forecast data')
        forecast_data = get_product_forecast()
        print('getting description data')
        description_data = get_product_descriptions()
        for xml_id, rec in self.fis_records.items():
            #
            label_data = ProductLabelDescription(xml_id)
            rec.fis_web_ingredients = label_data.ingredients_text or None
            rec.fis_web_prep_instructions = label_data.recipe_text or None
            #
            desc = description_data.get(xml_id)
            rec.name = desc or rec.fis_name or None
            #
            if not rec.categ_id:
                rec.categ_id = self.INVALID_CATEGORY
            #
            forecast = forecast_data.get(xml_id)
            rec.fis_qty_produced = 0
            rec.fis_qty_consumed = 0
            rec.fis_qty_purchased = 0
            rec.fis_qty_sold = 0
            rec.fis_qty_available = 0
            rec.fis_10_day_produced = 0
            rec.fis_10_day_consumed = 0
            rec.fis_10_day_purchased = 0
            rec.fis_10_day_sold = 0
            rec.fis_10_day_available = 0
            rec.fis_21_day_produced = 0
            rec.fis_21_day_consumed = 0
            rec.fis_21_day_purchased = 0
            rec.fis_21_day_sold = 0
            rec.fis_21_day_available = 0
            if forecast is not None:
                # the first four of the above values do not change
                _, _10_day, _21_day = forecast
                rec.fis_qty_available = rec.fis_qty_on_hand
                rec.fis_10_day_produced = _10_day.produced
                rec.fis_10_day_consumed = _10_day.consumed
                rec.fis_10_day_purchased = _10_day.purchased
                rec.fis_10_day_sold = _10_day.sold
                rec.fis_10_day_available = rec.fis_qty_on_hand + sum(_10_day)
                rec.fis_21_day_produced = _21_day.produced
                rec.fis_21_day_consumed = _21_day.consumed
                rec.fis_21_day_purchased = _21_day.purchased
                rec.fis_21_day_sold = _21_day.sold
                rec.fis_21_day_available = rec.fis_qty_on_hand + sum(_21_day)

    def normalize_records(self, fis_rec, oe_rec):
        super(NVTY, self).normalize_records(fis_rec, oe_rec)
        if fis_rec.name is None:
            fis_rec.name = oe_rec.name


    def _handle_nvty(method):
        global product_available_at, product_sales_category, product
        print('processing NVTY', border=('flag', '#'))
        examine = EXTRA.get('NVTY')
        context = {'fis-updates': True, 'active_test': False}
        product = Model(oe.get_model('product.product'), 'nvty', 'F135', context, RAISE_ON_EXCEPTION)
        all_oe_records = {}
        # these are for tracking original old/new records
        new_item_records = {}
        old_item_records = {}
        # these  are for tracking old/new versions of changed records
        old_changed_item_records = {}
        new_changed_item_records = {}
        # these are for added/deleted records
        added_item_records = {}
        deleted_records = {}
        # the counts
        changed_count = 0
        added_count = 0
        deleted_count = 0
        # get dependent data
        #
        # get the "old" data from:
        # - quick -> old fis file
        # - full -> current OpenERP data
        #
        nvty = fisData(135, rematch=r"......101000    101\*\*")
        print(nvty.filename, verbose=2)
        print('gathering data')
        if method == 'quick':
            #
            # for a quick compare we can use the fis records as-is when looking for changes
            #
            nvty_old = fisData(135, rematch=r"......101000    101\*\*", data_path=config.network.fis_data_local_old_path)
            print(nvty_old.filename, verbose=2)
            print('collecting changed records')
            changes, added, deleted = get_changed_fis_records(
                    nvty_old.values(),
                    nvty.values(),
                    enum_schema=[
                        F135.item_id,
                        F135.available_key, F135.sales_cat, F135.trademarkd,
                        F135.catalog_location, F135.desc, F135.size, F135.upc_no, F135.primary_location,
                        F135.supplier_id, F135.new_retail, F135.new_whlsl,
                        F135.net_un_wt, F135.grs_un_wt,
                        ],
                    address_fields=[],
                    )
            #
            # we now have the subset of records that have changed, now fetch the OpenERP records
            # to see if any meaningful changes
            #
            all_xml_ids = [t[0][F135.item_id] for t in changes]
            all_xml_ids.extend([f[F135.item_id] for f in added])
            all_xml_ids.extend([f[F135.item_id] for f in deleted])
            all_oe_records = dict([
                (r.xml_id, r)
                for r in product.read(
                    domain=[('module','=','F135'),('xml_id','in',all_xml_ids)],
                    fields=[
                        'id', 'module', 'xml_id', 'active', 'name', 'fis_name', 'fis_qty_on_hand',
                        'fis_availability_code', 'sale_ok', 'list_price', 'trademarks', 'ean13',
                        'fis_location', 'fis_shipping_size', 'categ_id', 'warranty',
                        'default_code', 'weight', 'weight_net', 'list_price',
                        ],
                    )
                ])
            for old, new, diffs in ProgressView(
                    iterable=changes,
                    message='sorting changed records',
                    view_type=VIEW_TYPE,
                ):
                xml_id = old[F135.item_id]
                old_item = all_oe_records[xml_id]
                old_item_records[xml_id] = old_item
                new_item = self.convert_fis_rec(new)
                # normalize fields
                new_item.id = old_item.id
                new_item_records[new_item.xml_id] = new_item
                # changes at the FIS level don't always translate to changes at the OpenERP level
                if old_item != new_item:
                    old_changed_item_records[old_item.xml_id] = old_item
                    new_changed_item_records[new_item.xml_id] = new_item
                assert set(old_changed_item_records.keys()) == set(new_changed_item_records.keys()),\
                        "old and new item records mismatch"
            #
            # and convert the new and deleted records
            #
            for fis_rec in added:
                rec = self.convert_fis_rec(fis_rec)
                rec.name = rec.fis_name
                added_item_records[rec.xml_id] = rec
            # XXX: disable for now in hopes of removing false inactive designations
            # for fis_rec in deleted:
            #     rec = convert_nvty_rec(fis_rec)
            #     deleted_records[rec.xml_id] = rec
        elif method == 'full':
            #
            # get the forecast and description data -- only used in "full"
            #
            print('getting forecast data')
            forecast_data = get_product_forecast()
            print('getting description data')
            description_data = get_product_descriptions()
            #
            # when doing a full compare, we have to convert every single fis record before we can
            # check for changes
            #
            all_fis_records = dict([
                (r.xml_id, r)
                for r in
                    [self.convert_fis_rec(f) for f in nvty.values()]
                ])
            if examine:
                echo(examine, all_fis_records.get(examine), sep='\n---\n', border='box')
            # and update with forecasts and descriptions
            for xml_id, rec in all_fis_records.items():
                #
                label_data = ProductLabelDescription(xml_id)
                rec.fis_web_ingredients = label_data.ingredients_text
                rec.fis_web_prep_instructions = label_data.recipe_text
                #
                desc = description_data.get(xml_id)
                rec.name = desc or rec.fis_name or None
                if rec.name is False:
                    del rec.name
                #
                forecast = forecast_data.get(xml_id)
                if xml_id == examine:
                    echo('forecast', forecast, sep='\n---\n', border='box')
                rec.fis_qty_produced = 0
                rec.fis_qty_consumed = 0
                rec.fis_qty_purchased = 0
                rec.fis_qty_sold = 0
                rec.fis_qty_available = 0
                rec.fis_10_day_produced = 0
                rec.fis_10_day_consumed = 0
                rec.fis_10_day_purchased = 0
                rec.fis_10_day_sold = 0
                rec.fis_10_day_available = 0
                rec.fis_21_day_produced = 0
                rec.fis_21_day_consumed = 0
                rec.fis_21_day_purchased = 0
                rec.fis_21_day_sold = 0
                rec.fis_21_day_available = 0
                if forecast is not None:
                    # the first four of the above values do not change
                    _, _10_day, _21_day = forecast
                    rec.fis_qty_available = rec.fis_qty_on_hand
                    rec.fis_10_day_produced = _10_day.produced
                    rec.fis_10_day_consumed = _10_day.consumed
                    rec.fis_10_day_purchased = _10_day.purchased
                    rec.fis_10_day_sold = _10_day.sold
                    rec.fis_10_day_available = rec.fis_qty_on_hand + sum(_10_day)
                    rec.fis_21_day_produced = _21_day.produced
                    rec.fis_21_day_consumed = _21_day.consumed
                    rec.fis_21_day_purchased = _21_day.purchased
                    rec.fis_21_day_sold = _21_day.sold
                    rec.fis_21_day_available = rec.fis_qty_on_hand + sum(_21_day)
            #
            # retrieve the OpenERP records that match the NVTY module
            #
            print('retrieving OpenERP records')
            all_oe_records = dict([
                    (r.xml_id, r)
                    for r in get_records(
                        oe, 'product.product',
                        domain=[('module','=','F135')],
                        fields=[
                            'id', 'module', 'xml_id', 'active', 'name', 'fis_name', 'fis_qty_on_hand',
                            'fis_availability_code', 'sale_ok', 'list_price', 'trademarks', 'ean13',
                            'fis_location', 'fis_shipping_size', 'categ_id', 'warranty',
                            'fis_qty_produced', 'fis_10_day_produced', 'fis_21_day_produced',
                            'fis_qty_consumed', 'fis_10_day_consumed', 'fis_21_day_consumed',
                            'fis_qty_purchased', 'fis_10_day_purchased', 'fis_21_day_purchased',
                            'fis_qty_sold', 'fis_10_day_sold', 'fis_21_day_sold',
                            'fis_qty_available', 'fis_10_day_available', 'fis_21_day_available',
                            'default_code', 'weight', 'weight_net',
                            'fis_web_ingredients', 'fis_web_prep_instructions',
                            ],
                        context=context,
                        )
                    ])
            if examine:
                echo(examine, all_oe_records.get(examine), sep='\n---\n', border='box')
            # print('sorting changed, new, and deleted product records')
            all_keys = set(all_fis_records.keys() + all_oe_records.keys())
            for key in ProgressView(
                    iterable=sorted(all_keys),
                    message='sorting product records',
                    view_type=VIEW_TYPE,
                ):
                old_rec = all_oe_records.get(key)
                new_rec = all_fis_records.get(key)
                if old_rec is new_rec is None:
                    continue
                if old_rec is None:
                    added_item_records[key] = new_rec
                    continue
                if new_rec is None:
                    deleted_records[key] = old_rec
                    continue
                # copy missing fields for proper equality testing
                new_rec.id = old_rec.id
                for field in old_rec.keys():
                    if field not in new_rec:
                        new_rec[field] = old_rec[field]
                        product.error(
                                "%s: field %r missing from new record; using old value of %r"
                                    % (key, field, old_rec[field])
                                )
                if old_rec == new_rec or close_enough(old_rec, new_rec):
                    continue
                #
                # we have changes, save the records for later comparison
                #
                old_changed_item_records[key] = old_rec
                new_changed_item_records[key] = new_rec
                if key == examine:
                    echo(key, old_rec, new_rec, sep='\n---\n', box='border')
            assert set(old_changed_item_records.keys()) == set(new_changed_item_records.keys()),\
                    "old and new item records mismatch"
        else:
            abort('unknown METHOD: %r' % (method, ))
        #
        # at this point, all records are in AttrDict format, divided by deleted, added, and changed
        # new records are from FIS files, old records are from OpenERP
        #
        # add new products
        #
        for xml_id, item in ProgressView(
                iterable=sorted(added_item_records.items()),
                message='adding new records',
                view_type=VIEW_TYPE,
            ):
            name = item.fis_name
            if xml_id in all_oe_records:
                product.error('FIS ID F135:%s (%s) already exists in OpenERP' % (xml_id, name))
                continue
            added_count += 1
            logger.info(
                    'F135:%s -- adding -- %s',
                    xml_id,
                    (', '.join(['%s=%r' % (k, v) for k, v in item.items()]))
                    )
            if LIST_RECORDS:
                echo('  F135:%s  %s' % (item.xml_id, name), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in item.items()), '||', end='')
                echo()
            if not DRYRUN:
                product_id = product.create(xml_id, item)
                if product_id:
                    item.id = product_id
                    all_oe_records[xml_id] = item
        #
        # process changes
        #
        changed_map = combine_by_value(old_changed_item_records, new_changed_item_records)
        echo('%d items' % len(old_changed_item_records))
        for changes, records in ProgressView(
                iterable=sorted(changed_map.items()),
                message='processing changed records',
                view_type=VIEW_TYPE,
            ):
            values = dict(changes)
            xml_ids = [r.xml_id for r in records]
            oe_ids = product.search([('module','=','F135'),('xml_id','in',xml_ids)])
            changed_count += len(oe_ids)
            logger.info(
                    'F135: changing -- %s  -->  %s',
                    xml_ids,
                    ', '.join("%s=%r" % (k, v) for k, v in sorted(changes))
                    )
            if LIST_RECORDS:
                body = []
                for rec in records:
                    body.append(('  F135:%s  %s' % (rec.xml_id, rec.fis_name)))
                if script_verbosity > 1:
                    body.append('---')
                    body.append(str(AttrDict(changes)))
                echo('\n'.join(body), border='box' if script_verbosity > 1 else None)
            if examine in xml_ids:
                echo(
                        'changing %s to' % examine,
                        '\n'.join(['%s = %r' % (k, v) for k, v in sorted(values.items())]),
                        sep='\n---\n',
                        border='box',
                        )
            if not DRYRUN:
                product.write('|'.join(xml_ids), oe_ids, values, context={})
        #
        # deleted/deactivate products
        #
        if not DELETE:
            delete_message = 'deactivating old records'
        else:
            delete_message = 'deleting old records'
        for _ in ProgressView(
                iterable=(True, ),
                message=delete_message,
                view_type=VIEW_TYPE,
            ):
            # get the ids of actually existing records
            xml_ids = deleted_records.keys()
            if examine in xml_ids:
                echo('deleting', examine, border='box')
            if DELETE:
                ids = [rec.id for key, rec in all_oe_records.items() if key in xml_ids]
            else:
                ids = [rec.id for key, rec in all_oe_records.items() if key in xml_ids and rec.active]
            if ids:
                deleted_count = len(ids)
                if deleted_count:
                    logger.info(
                            'F135 -- removing -- %s',
                            ', '.join(sorted(deleted_records.keys()))
                            )
                    if LIST_RECORDS:
                        for xml_id, rec in sorted(deleted_records.items()):
                            echo('  F135:%s  %s' % (rec.xml_id, rec.fis_name))
                    if not DRYRUN:
                        if DELETE:
                            product.delete(ids, context=context)
                        else:
                            product.write('...', ids, {'active': False})
        #
        # update ir.model.data mappings
        #
        oe_records = dict(
                (r.id, r.xml_id)
                for r in get_records(
                    oe,
                    'product.product',
                    domain=[('module','=','F135')],
                    fields=['xml_id'],
                    ))
        update_ir_model_data('product.product', 135, oe_records)
        #
        print('%d products changed\n%d products added\n%d products %s'
                % (changed_count, added_count, deleted_count, ('deactivated','deleted')[DELETE]),
                border='box',
                )

class POSM_VNMS(SynchronizeAddress):

    # VNMS_TN = 163
    # VNMS_FN = 'vnms'
    # VNMS_F = 'F163'
    # VNMS_OE = 'res.partner'
    # VNMS_IMD = VNMS_OE.replace('.','_')
    # suppliers/vendors, 65 & 163
    TN = 163
    TN_2ND = 65
    FN = 'posm'
    FN_2ND = 'vnms'
    F = 'F163'
    OE = 'res.partner'
    IMD = 'res_partner'
    RE = r"10(......)"
    OE_KEY = 'xml_id'
    OE_KEY_MODULE = 'F%s' % TN
    OE_FIELDS = (
            'id', 'module', 'xml_id', 'active', 'phone', 'fax',
            'name', 'street', 'street2', 'city', 'state_id', 'zip', 'country_id',
            'fis_valid', 'is_company', 'customer', 'supplier',
            'fis_updated_by_user', 'use_parent_address',
            'fis_org_cert_file', 'fis_non_gmo', 'fis_kosher', 'fis_org_exp',
            'fis_gmo_exp', 'fis_kosher_exp',
            )
    FIELDS_CHECK_IGNORE = ('active', 'name')

    def FIS_IGNORE_RECORD(self, rec):
        NAME = 'Bn$'  # common index for the name field in both POSM and VNMS
        return not bool(rec[NAME])

    def convert_fis_rec(self, posm_vnms, use_ignore=True):
        #
        # creates a company AttrDict with the following fields
        # - 'module', 'xml_id', 'active',
        # - 'name', 'street', 'street2', 'city', 'state_id', 'zip', 'country_id',
        # - 'fis_valid', 'phone', 'fax', 'is_company', 'customer', 'fis_org_cert_file',
        # - 'fis_non_gmo', 'fis_kosher', 'fis_org_exp', 'fis_gmo_exp', 'fis_kosher_exp',
        #
        # creates a contact AttrDict with the following fields
        # - 'module', 'xml_id', 'active', 'name', 'phone', 'fax',
        # - 'is_company', 'customer', 'supplier', 'fis_valid',
        #
        # fields coming from OpenERP that are missing/invalid on the FIS side
        # - 'id', 'fis_updated_by_user'
        # - address fields (for contact)
        #
        posm_rec, vnms_rec = posm_vnms
        if use_ignore and posm_rec and self.FIS_IGNORE_RECORD(posm_rec):
            posm_rec = None
        if use_ignore and vnms_rec and self.FIS_IGNORE_RECORD(vnms_rec):
            vnms_rec = None
        if posm_rec is vnms_rec is None:
            return ()
        # vendor_codes.add(key)
        if posm_rec is not None:
            contact_key = posm_rec[F163.vendor]
            if not contact_key:
                vnms_rec = None
        key = posm_rec and posm_rec[F163.code] or vnms_rec and vnms_rec[F65.code]
        imd = AttrDict(
                id=0,
                model=self.OE,
                res_id=0,
                module='fis',
                name=self.calc_xid(key),
                )
        company = AttrDict().fromkeys(self.OE_FIELDS, 7)
        company.module = self.OE_KEY_MODULE
        company.xml_id = key
        company.active = True
        company.fis_updated_by_user = ''
        company.is_company = True
        company.customer = False
        company.supplier = True
        company.use_parent_address = False
        company.fis_valid = len(key) == 6 and key.isdigit()
        if posm_rec is not None:
            company.name = re.sub('sunridge', 'SunRidge', BsnsCase(posm_rec[F163.name]), flags=re.I) or None
            company.update(self.process_address(F163, posm_rec))
            company.phone = fix_phone(posm_rec[F163.tele]) or None
            company.fax = fix_phone(posm_rec[F163.fax]) or None
            company.fis_org_cert_file = posm_rec[F163.org_cert_file].upper() in 'YO'
            company.fis_org_exp = fix_date(posm_rec[F163.cert_exp]) or None
            company.fis_non_gmo = posm_rec[F163.non_gmo].upper() in 'Y'
            company.fis_kosher = posm_rec[F163.kosher].upper() in 'Y'
            company.fis_gmo_exp = fix_date(posm_rec[F163.gmo_exp]) or None
            company.fis_kosher_exp = fix_date(posm_rec[F163.kosher_exp]) or None
        elif vnms_rec is not None:
            company.name = re.sub('sunridge', 'SunRidge', BsnsCase(vnms_rec[F65.name]), flags=re.I) or None
            company.update(self.process_address(F65, vnms_rec))
            company.phone = fix_phone(vnms_rec[F65.tele]) or None
            company.fax = fix_phone(vnms_rec[F65.fax]) or None
            company.fis_org_cert_file = vnms_rec[F65.org_cert_file].upper() in 'YO'
            company.fis_org_exp = fix_date(vnms_rec[F65.cert_exp]) or None
            company.fis_non_gmo = False
            company.fis_kosher = False
            company.fis_gmo_exp = None
            company.fis_kosher_exp = None
        else:
            error("invalid POSM/VNMS xml_id: %r" % (key, ))
            return ()
        if (
                not company.name
                or not company.fis_valid
                or '**NO LONGER HERE**' in (company.name or '').upper()
                or '**OLDER/N.L.H. EMPLOYEE**' in (company.name or '').upper()
                or '**DISCO' in (company.street or '').upper()
            ):
            company.active = False
        company = XidRec.fromdict(
                company,
                imd,
                types={
                    'fis_kosher': (bool, ),
                    'fis_non_gmo': (bool, ),
                    'fis_org_cert_file': (bool, ),
                    },
                )
        #
        contact = None
        if vnms_rec is not None and vnms_rec[F65.contact]:
            name = NameCase(vnms_rec[F65.contact])
            contact = AttrDict().fromkeys(self.OE_FIELDS, None)
            contact.module = 'F163'
            contact.xml_id = 'cntct_' + key
            contact.fis_updated_by_user = ''
            contact.active = company.active
            contact.name = name
            contact.fis_valid = company.fis_valid
            contact.is_company = False
            contact.customer = False
            contact.supplier = True
            contact.use_parent_address = True
            contact.phone = fix_phone(vnms_rec[F65.tele]) or None
            contact.fax = fix_phone(vnms_rec[F65.fax]) or None
            contact.fis_org_cert_file = False
            contact.fis_non_gmo = False
            contact.fis_kosher = False
            imd = AttrDict(
                    id=0,
                    model=self.OE,
                    res_id=0,
                    module='fis',
                    name=self.calc_xid(contact.xml_id),
                    )
            contact = XidRec.fromdict(
                    contact,
                    imd,
                    types={
                        'fis_kosher': (bool, ),
                        'fis_non_gmo': (bool, ),
                        'fis_org_cert_file': (bool, ),
                        },
                    )
        if contact is not None:
            if not re.match('\w{2,}', name):
                contact.active = False
            return company, contact
        else:
            return (company, )

    fis_quick_load = SynchronizeAddress.fis_long_load

    def open_fis_tables(self):
        posm_table = self.get_fis_table(self.TN, rematch=self.RE)
        vnms_table = self.get_fis_table(self.TN_2ND, rematch=self.RE)
        old_posm_table = self.get_fis_table(
                self.TN,
                rematch=self.RE,
                data_path=self.config.network.fis_data_local_old_path,
                )
        old_vnms_table = self.get_fis_table(
                self.TN_2ND,
                rematch=self.RE,
                data_path=self.config.network.fis_data_local_old_path,
                )
        print('posm: %d\nvnms: %d\nold posm: %d\nold vnms: %d' %
                (len(posm_table), len(vnms_table),
                    len(old_posm_table), len(old_vnms_table))
                )
        class PsuedoFisTable(object):
            __slots__ = 'filename', 'data'
            def __init__(self, filename):
                self.filename = filename
                self.data = {}
            def __getattr__(self, name):
                return getattr(self.data, name)
            def __getitem__(self, name):
                return self.data[name]
            def __setitem__(self, name, value):
                self.data[name] = value
        self.fis_table = PsuedoFisTable('combined posm/vnms table')
        self.old_fis_table = PsuedoFisTable('old combined posm/vnms table')
        all_keys = list(posm_table.keys()) + list(vnms_table.keys())
        all_old_keys = list(old_posm_table.keys()) + list(old_vnms_table.keys())
        for key in all_keys:
            self.fis_table[key] = posm_table.get(key), vnms_table.get(key)
        for key in all_old_keys:
            self.old_fis_table[key] = old_posm_table.get(key), old_vnms_table.get(key)

    def _handle_supplier(method):
        #
        # combine the posm and vnms tables to create supplier records;
        # majority of data comes from the posm table, with contact name,
        # phone, and fax numbers coming from vnms
        #
        # always use "full" method
        #
        global posm, vnms
        print('processing POSM/VNMS', border=('box','#'))
        vnms = fisData(65, rematch=r"10(......)")
        posm = fisData(163, rematch=r"10(......)")
        print(posm.filename, verbose=2)
        print(vnms.filename, verbose=2)
        context = {'fis-updates': True, 'active_test': False}
        # on the OpenERP side, supplier records use F163 as the FIS module
        res_partner = Model(oe.get_model('res.partner'), 'posm/vnms', 'F163/F65', context, RAISE_ON_EXCEPTION)
        # these are for tracking original old/new records
        new_company_records = {}
        old_company_records = {}
        new_contact_records = {}
        old_contact_records = {}
        # these  are for tracking old/new versions of changed records
        old_changed_company_records = {}
        new_changed_company_records = {}
        old_changed_contact_records = {}
        new_changed_contact_records = {}
        # these are for added/deleted records
        added_company_records = {}
        added_contact_records = {}
        deleted_records = {}
        # and the counts
        changed_count = 0
        added_count = 0
        deleted_count = 0
        ids = {}
        #
        # get the "old" data from:
        # - full -> current OpenERP data
        #
        print('gathering data', border='flag')
        #
        # when doing a full compare, we have to convert every single fis record before we can
        # check for changes
        #
        print('retrieving and converting FIS records')
        all_keys = set(posm.keys() + vnms.keys())
        all_fis_records = AttrDict()
        for code in sorted(posm.keys()):
            key = code[2:]
            company, contact = self.convert_fis_rec(key)
            if company is None:
                continue
            # if company/contact are invalid, just put them in the deleted category
            all_fis_records[company.xml_id] = company
            if '**NO LONGER HERE**' in company.name or '**OLDER/N.L.H. EMPLOYEE**' in company.name:
                deleted_records[company.xml_id] = company
            else:
                new_company_records[company.xml_id] = company
            if contact is not None:
                all_fis_records[contact.xml_id] = contact
                if '**NO LONGER HERE**' in contact.name or '**OLDER/N.L.H. EMPLOYEE**' in contact.name:
                    deleted_records[contact.xml_id] = contact
                else:
                    new_contact_records[contact.xml_id] = contact
        for code in sorted(vnms.keys()):
            key = code[2:]
            if key in vendor_codes:
                continue
            company, contact = self.convert_fis_rec(key)
            if company is None:
                continue
            # if company/contact are invalid, just put them in the deleted category
            all_fis_records[company.xml_id] = company
            if '**NO LONGER HERE**' in company.name or '**OLDER/N.L.H. EMPLOYEE**' in company.name:
                deleted_records[company.xml_id] = company
            else:
                new_company_records[company.xml_id] = company
            if contact is not None:
                all_fis_records[contact.xml_id] = contact
                if '**NO LONGER HERE**' in contact.name or '**OLDER/N.L.H. EMPLOYEE**' in contact.name:
                    deleted_records[contact.xml_id] = contact
                else:
                    new_contact_records[contact.xml_id] = contact
        #
        # retrieve the OpenERP records that match the POSM/VNMS module, and divvy them up into company
        # and contact records
        #
        print('retrieving OpenERP records')
        all_oe_records = dict([
                (r.xml_id, r)
                for r in get_records(
                    oe, 'res.partner',
                    domain=[('module','=','F163')],
                    fields=[
                        'id', 'module', 'xml_id', 'active', 'phone', 'fax',
                        'name', 'street', 'street2', 'city', 'state_id', 'zip', 'country_id',
                        'fis_valid', 'is_company', 'customer', 'supplier',
                        'fis_updated_by_user', 'use_parent_address',
                        'fis_org_cert_file', 'fis_non_gmo', 'fis_kosher', 'fis_org_exp',
                        'fis_gmo_exp', 'fis_kosher_exp',
                        ],
                    context=context,
                    )
                ])
        print('sorting company and contact records')
        for xml_id, datom in all_oe_records.items():
            ids[xml_id] = datom.id
            if xml_id.startswith('cntct_'):
                # do not update address from here -- it's either the default of "use parent's"
                # or it's been changed by the user (same with specials_notification)
                del datom.use_parent_address
                del datom.street, datom.street2
                del datom.city, datom.state_id, datom.zip, datom.country_id
                del datom.fis_org_cert_file, datom.fis_non_gmo, datom.fis_kosher
                del datom.fis_org_exp, datom.fis_gmo_exp, datom.fis_kosher_exp
                old_contact_records[xml_id] = datom
            else:
                old_company_records[xml_id] = datom
        #
        # now we can separate into new, changed, and deleted buckets
        #
        print('sorting company records into changed, new, and deleted')
        all_keys = set(new_company_records.keys() + old_company_records.keys())
        for key in all_keys:
            old_rec = all_oe_records.get(key)
            new_rec = all_fis_records.get(key)
            if old_rec is new_rec is None:
                assert False, "a key is missing from both old and new records???"
            if old_rec is None:
                if new_rec.active:
                    added_company_records[key] = new_rec
                continue
            if new_rec is None:
                deleted_records[key] = old_rec
                continue
            if not new_rec.active:
                deleted_records[key] = old_rec
                continue
            # copy missing fields for proper equality testing / remove unused-for-comparison fields
            new_rec.id = old_rec.id
            new_rec.fis_updated_by_user = old_rec.fis_updated_by_user
            # for now, we don't want the FIS active status overwriting the OpenERP active status
            del new_rec.active, old_rec.active
            if set(new_rec.keys()) != set(old_rec.keys()):
                error('old_rec: %r  -- new_rec: %r' % (type(old_rec), type(new_rec)))
                error('old_rec._values.keys() --> %r\nnew_rec._values.keys() --> %r' % (
                    old_rec._values.keys(), new_rec._values.keys()))
                raise AssertionError('old_rec/new_rec keys mismatch')
            if new_rec == old_rec:
                continue
            #
            # we have changes, save the records for later comparison
            #
            old_changed_company_records[key] = old_rec
            new_changed_company_records[key] = new_rec
        if set(old_changed_company_records.keys()) != set(new_changed_company_records.keys()):
            error('old_rec: %r  -- new_rec: %r' % (type(old_changed_company_records), type(new_changed_company_records)))
            raise AssertionError('old_changed_company_records/new_changed_company_records keys mismatch')
        #
        print('sorting contact records into changed, new, and deleted')
        all_keys = set(new_contact_records.keys() + old_contact_records.keys())
        for key in all_keys:
            parent_key = key[6:]
            old_rec = all_oe_records.get(key)
            new_rec = all_fis_records.get(key)
            if old_rec is new_rec is None:
                assert False, "a key is missing from both old and new records???"
            if old_rec is None:
                if new_rec.active:
                    added_contact_records[key] = new_rec
                continue
            if new_rec is None:
                deleted_records[key] = old_rec
                continue
            if not new_rec.active:
                deleted_records[key] = old_rec
                continue
            if parent_key in deleted_records:
                deleted_records[key] = old_rec
                continue
            # copy missing fields for proper equality testing / remove unused-for-comparison fields
            new_rec.id = old_rec.id
            new_rec.fis_updated_by_user = old_rec.fis_updated_by_user
            del new_rec.use_parent_address
            # for now, we don't want the FIS active status overwriting the OpenERP active status
            del new_rec.active, old_rec.active
            assert set(new_rec.keys()) == set(old_rec.keys()), '\n'+box(
                    "keys mismatch\n---\nold record:\n%s\n---\nnew record:\n%s"
                    % ('\n'.join(old_rec.keys()), '\n'.join(new_rec.keys()))
                    )
            if new_rec == old_rec:
                continue
            #
            # we have changes, save the records for later comparison
            #
            old_changed_contact_records[key] = old_rec
            new_changed_contact_records[key] = new_rec
        assert set(old_changed_contact_records.keys()) == set(new_changed_contact_records.keys()),\
                "old and new contact records mismatch"
        #
        # at this point, all records are in AttrDict format, divided by deleted, added, changed
        #
        # process company changes
        #
        if old_changed_company_records:
            print('processing company changes', border='flag')
        assert set(old_changed_company_records.keys()) == set(new_changed_company_records.keys()),\
                "old/new company records mismatch"
        changed_company_xml_ids = sorted(old_changed_company_records.keys())
        relevant_changes = False
        for xml_id in changed_company_xml_ids:
            #
            # TODO: check actual values in OpenERP and remove "changes" that are already set
            #
            # figure out the changes
            #
            old_record = old_changed_company_records[xml_id]
            new_record = new_changed_company_records[xml_id]
            assert set(old_record.keys()) == set(new_record.keys()),\
                    ('old/new keys mismatch\nold:%s\n%s\nnew:%s\n%s' %
                        ('|'.join(sorted(old_record.keys())), box(str(old_record)),
                         '|'.join(sorted(new_record.keys())), box(str(new_record))))
            # check for user-updated-address and specials
            user_updates = old_record.fis_updated_by_user or ''
            if 'A' in user_updates:
                # drop all the address fields
                del old_record.use_parent_address
                del old_record.street, old_record.street2
                del old_record.city, old_record.state_id, old_record.zip, old_record.country_id
                del new_record.use_parent_address
                del new_record.street, new_record.street2
                del new_record.city, new_record.state_id, new_record.zip, new_record.country_id
            if 'N' in user_updates:
                del old_record.name
                del new_record.name
            changes = get_updated_values(old_record, new_record)
            if changes:
                relevant_changes = True
                changed_count += 1
                logger.info(
                        'F163: changing -- %s  -->  %s',
                        xml_id,
                        ', '.join("%s=%r" % (k, v) for k, v in changes.items())
                        )
                if LIST_RECORDS:
                    echo('  F163:%s  %s' % (xml_id, new_record.name), end='  ')
                    print('||', '||'.join('%s -> %r' % (k, v) for k, v in changes.items()), '||', end='')
                    echo()
                if not DRYRUN:
                    res_partner.write(xml_id, new_record.id, changes)
        if not relevant_changes:
            print('...no relevant changes...')
        #
        # add new companies
        #
        if added_company_records:
            print('adding company records', border='flag')
        for key, company in added_company_records.items():
            if not DRYRUN:
                # double-check that record doesn't already exist
                company_id = res_partner.search(domain=[('xml_id','=',key),('module','=','F163')])
                if company_id:
                    [company_id] = company_id
                    ids[key] = company_id
                    res_partner.error('FIS ID F163:%s (%s) already exists in OpenERP' % (key, company.name))
                    continue
            added_count += 1
            logger.info(
                    'F163:%s -- adding -- %s',
                    key,
                    (', '.join(['%s=%r' % (k, v) for k, v in company.items()]))
                    )
            if LIST_RECORDS:
                echo('  F163:%s  %s' % (key, company.name), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in company.items()), '||', end='')
                echo()
            if not DRYRUN:
                company_id = res_partner.create(key, company)
                if company_id:
                    company.id = company_id
                    ids[key] = company_id
        #
        # process contact changes
        #
        if old_changed_contact_records:
            print('processing contact changes', border='flag')
        assert set(old_changed_contact_records.keys()) == set(new_changed_contact_records.keys()),\
                "old/new contact records mismatch"
        changed_contact_xml_ids = sorted(old_changed_contact_records.keys())
        relevant_changes = False
        for xml_id in changed_contact_xml_ids:
            #
            # TODO: check actual values in OpenERP and remove "changes" that are already set
            #
            # figure out the changes
            #
            old_record = old_changed_contact_records[xml_id]
            new_record = new_changed_contact_records[xml_id]
            assert set(old_record.keys()) == set(new_record.keys()),\
                    ('old/new keys mismatch\nold:%s\n%s\nnew:%s\n%s' %
                        ('|'.join(sorted(old_record.keys())), box(str(old_record)),
                         '|'.join(sorted(new_record.keys())), box(str(new_record))))
            # check for user-updated-address and specials
            user_updates = old_record.fis_updated_by_user or ''
            if 'A' in user_updates:
                # drop all the address fields
                del old_record.use_parent_address
                del old_record.street, old_record.street2
                del old_record.city, old_record.state_id, old_record.zip, old_record.country_id
                del new_record.use_parent_address
                del new_record.street, new_record.street2
                del new_record.city, new_record.state_id, new_record.zip, new_record.country_id
            if 'N' in user_updates:
                del old_record.name
                del new_record.name
            changes = get_updated_values(old_record, new_record)
            if changes:
                relevant_changes = True
                changed_count += 1
                if LIST_RECORDS:
                    echo('  F163:%s  %s' % (xml_id, new_record.name), end='  ')
                    print('||', '||'.join('%s -> %r' % (k, v) for k, v in changes.items()), '||', end='')
                    echo()
                if not DRYRUN:
                    res_partner.write(xml_id, new_record.id, changes)
        if not relevant_changes:
            print('...no relevant changes...')
        #
        # add new contacts
        #
        if added_contact_records:
            print('adding contact records', border='flag')
        for key, contact in added_contact_records.items():
            if not DRYRUN:
                # double-check that record doesn't already exist
                contact_id = res_partner.search(domain=[('xml_id','=',key),('module','=','F163')])
                if contact_id:
                    [contact_id] = contact_id
                    ids[key] = contact_id
                    res_partner.error('FIS ID F163:%s (%s) already exists in OpenERP' % (key, contact.name))
                    continue
            added_count += 1
            logger.info(
                    'F163:%s -- adding -- %s',
                    contact.name,
                    (', '.join(['%s=%r' % (k, v) for k, v in contact.items()]))
                    )
            if LIST_RECORDS:
                echo('  F163:%s  %s' % (key, contact.name), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in contact.items()), '||', end='')
                echo()
            if not DRYRUN:
                contact_id = res_partner.create(key, contact)
                if contact_id:
                    contact.id = contact_id
                    ids[key] = contact_id
        #
        # deleted/deactivate suppliers
        #
        if deleted_records:
            # toss any records that don't already exist in OpenERP
            for key, rec in sorted(deleted_records.items()):
                if key not in ids:
                    deleted_records.pop(key)
                elif not all_oe_records[key].active:
                    deleted_records.pop(key)
                elif LIST_RECORDS:
                    echo('  F163:%s  %s' % (key, rec.name))
            deleted_count = len(deleted_records)
            if deleted_count:
                verb = 'deleting' if DELETE else 'deactivating'
                print('%s records' % verb, border='flag')
                logger.info(
                        'F163 -- %s -- %s',
                        verb,
                        ', '.join(sorted(deleted_records.keys()))
                        )
                if not DRYRUN:
                    oe_ids = res_partner.search(domain=[('xml_id','in',deleted_records.keys())])
                    if DELETE:
                        res_partner.delete(oe_ids, context=context)
                    else:
                        res_partner.write('...', oe_ids, {'active': False}, context=context)
        #
        # update ir.model.data mappings
        #
        oe_records = dict(
                (r.id, r.xml_id)
                for r in get_records(
                    oe, 'res.partner',
                    domain=[('module','=','F163')],
                    fields=['xml_id'],
                    context=context,
                    ))
        update_ir_model_data('res.partner', 163, oe_records)
        #
        print('%d suppliers changed\n%d suppliers added\n%d suppliers %s'
                % (changed_count, added_count, deleted_count, ('deactivated','deleted')[DELETE]),
                border='box',
                )

def get_customer_aging(aging_file):
    aging_data = {}
    with open(config.network.fis_data_local_path/'customer_aging.txt') as af:
        lines = [line for line in af.read().split('\n') if line.strip()]
    try:
        for line in lines:
            # isolate FIS code
            key, rest = line.split(None, 1)
            # lines with filenames are invalid
            if key.endswith(':'):
                continue
            # isolate other info, ignoring company name
            limit, salesrep, total, d0, d10, d20, d30 = line.rsplit(None, 8)[-7:]
            aging_data[key] = CustomerAging(key, limit, d0, d10, d20, d30, total)
        return aging_data
    except Exception as exc:
        echo(exc, border='box')
        return {}

def get_product_descriptions():
    descriptions = {}
    with open(config.network.fis_data_local_path/'product_descriptions.txt') as f:
        lines = f.read().split('\n')
    for line in lines:
        match = re.match('(.{40})  \((\d{6})\)  (.*)$', line)
        if match:
            fis_desc, item_code, full_desc = match.groups()
            descriptions[item_code] = full_desc or fis_desc or None
    return descriptions

def get_product_forecast():
    # parse the daily-updated file with the product forecasts
    forecast = {}
    with open(config.network.fis_data_local_path/'product_forecast.txt') as f:
        lines = f.read().split('\n')
    for i, line in enumerate(lines):
        if not line.strip() or '-' not in line:
            continue
        try:
            text = line.split(' - ')[1]
        except IndexError:
            # product.error('problem with forecast line #%d: %r' % (i, line))
            continue
        if 'ERROR' in text:
            continue
        try:
            item_code, _10_day, _21_day = text.split(':')
        except ValueError:
            # product.error('problem with forecast line #%d: %r' % (i, line))
            continue
        prod_in, purch, prod_out, sold = _10_day.split()[2:6]
        prod_in = float(prod_in)
        purch = float(purch)
        prod_out = -(float(prod_out))
        sold = -(float(sold))
        _10_day = ForecastDetail(prod_in, purch, prod_out, sold)
        prod_in, purch, prod_out, sold = _21_day.split()[2:6]
        prod_in = float(prod_in)
        purch = float(purch)
        prod_out = -(float(prod_out))
        sold = -(float(sold))
        _21_day = ForecastDetail(prod_in, purch, prod_out, sold)
        forecast[item_code] = Forecast(item_code, _10_day, _21_day)
    return forecast

_raise_lookup = object()
class Specials(str, Enum):
    _order_ = 'neither catalog specials both default'
    neither   = 'N'
    catalog   = 'C'
    specials  = 'S'
    both      = 'B'
    default   = 'D'
    company   = default
    @classmethod
    def get_member(cls, text, default=_raise_lookup):
        for member in cls:
            if member.value == text:
                return member
        else:
            if default is not _raise_lookup:
                return default
        raise LookupError('%r not found in %s' % (text, cls.__name__))

# def is_invalid_posm_record(rec):
#     if rec is None:
#         return True
#     xml_id = rec[F163.code]
#     name = rec[F163.name]
#     vendor_xml_id = rec[F163.vendor]
#     vendor_rec = vnms.get(vendor_xml_id)
#     if (
#             len(xml_id) == 6
#             and xml_id.isdigit()
#             and name
#             and len(vendor_xml_id) == 6
#             and vendor_xml_id.isdigit()
#             and vendor_rec is not None
#         ):
#         # valid record, record vendor mapping
#         ven2sup[vendor_xml_id] = xml_id
#         return False
#     # invalid record
#     return True

def is_contact(obj):
    "obj must be either a string or have an xml_id key"
    if not isinstance(obj, basestring):
        obj = obj.get('xml_id')
    return obj.startswith('cntct_')

def sanitize_ean13(ean13):
    """
    Creates and returns a valid ean13 from an invalid one
    """
    if not ean13:
        return "0000000000000"
    ean13 = re.sub("[A-Za-z]", "0", ean13);
    ean13 = re.sub("[^0-9]", "", ean13);
    ean13 = ean13[:13]
    if len(ean13) < 13:
        ean13 = ean13 + '0' * (13-len(ean13))
    return ean13[:-1] + str(ean_checksum(ean13))

def ean_checksum(eancode):
    """
    returns the checksum of an ean string of length 13, returns -1 if the string has the wrong length
    """
    if len(eancode) != 13:
        return -1
    oddsum=0
    evensum=0
    total=0
    eanvalue=eancode
    reversevalue = eanvalue[::-1]
    finalean=reversevalue[1:]
    for i in range(len(finalean)):
        if i % 2 == 0:
            oddsum += int(finalean[i])
        else:
            evensum += int(finalean[i])
    total=(oddsum * 3) + evensum
    check = int(10 - math.ceil(total % 10.0)) % 10
    return check

def numeric(number):
    try:
        return int(number)
    except ValueError:
        try:
            return float(number)
        except ValueError:
            pass
    return False

def get_updated_values(old_record, new_record):
    changes = AttrDict()
    for key in old_record:
        old_value = old_record[key]
        new_value = new_record[key]
        if (old_value or new_value) and old_value != new_value:
            changes[key] = new_value
    return changes

class CustomerAging(NamedTuple):
    _order_ = "xml_id limit current d10 d20 d30 total"
    xml_id = 'customer key'
    limit = 'credit limit'
    current = 'charges within 10 days'
    d10 = 'charges between 11 and 20 days old'
    d20 = 'charges between 21 and 30 days old'
    d30 = 'charges over 30 days old'
    total = 'total outstanding balance'

    def __new__(cls, *values):
        new_values = [values[0]]
        for value in values[1:]:
            value = value.replace(',','')
            if value[-1:] == '-':
                value = '-' + value[:-1]
            new_values.append(float(value))
        return NamedTuple.__new__(CustomerAging, *new_values)


class ForecastDetail(NamedTuple):
    produced = 0, None, 0.0
    purchased = 1, None, 0.0
    consumed = 2, None, 0.0
    sold = 3, None, 0.0


class Forecast(NamedTuple):
    item = 0, None, ''
    day_10 = 1, None, ForecastDetail()
    day_21 = 2, None, ForecastDetail()


class Partner(XmlLink):
    """
    create singleton object for a partner, allow fields to be set only once
    """


class Product(XmlLink):
    """
    create singleton object for a product, allow fields to be set only once
    """


class ProductCategory(XmlLink):
    """
    create singleton object for a product category, allow fields to be set only once
    """


class ProductLocation(XmlLink):
    """
    create singleton object for a product location, allow fields to be set only once
    """

class Transmitter(XmlLink):
    """
    create singleton object for a transmitter id, allow fields to be set only once
    """

def update_ir_model_data(model, table_number, oe_records):
    # oe_records = {id: key, ...}
    ir_model_data = oe.get_model('ir.model.data')
    imd_by_id = dict()
    imd_by_name = dict()
    for rec in ir_model_data.read(
            [('module','=','fis'), ('model','=',model)],
            fields=['name','res_id'],
        ):
        imd_by_id[rec.res_id] = rec
        imd_by_name[rec.name] = rec
    # remove missing ids first
    dead_ids = list(set([imd_rec.id for imd_rec in imd_by_id.values() if imd_rec.res_id not in oe_records]))
    if dead_ids:
        ir_model_data.unlink(dead_ids)
    for id, key in oe_records.items():
        imd_name = "F%03d_%s_%s" % (table_number, key, model.replace('.','_'))
        by_id = imd_by_id.get(id)
        by_name = imd_by_name.get(imd_name)
        if by_id and by_id == by_name:
            # we have records and they match
            continue
        elif not (by_id or by_name):
            # no records, so create one
            new_rec = AttrDict({
                    'module':'fis',
                    'model':model,
                    'res_id':id,
                    'name':imd_name,
                    })
            new_rec.id = ir_model_data.create(new_rec)
            imd_by_id[new_rec.res_id] = new_rec
            imd_by_name[imd_name] = new_rec
        else:
            error('error with name %r:\n  oe record id: %d\n  ir.model.data res_id: %r\n  ir.model.data name: %r'
                    % (imd_name, id, by_id, by_name))

# old code
# def handle_sales_reps():
#     context = {'fis-updates': True}
#     res = AttrDict()
#     res.partner = oe.get_model('res.partner')
#     cnvzz = fisData(47)
#     if method == 'quick':
#         cnvz_old = fisData(47, data_path=config.network.fis_data_local_old_path)
#     failed_match = set()
#     def is_invalid_cnvz(sales_rec):
#         sales_id = rec[F47.salesperson_id].upper()
#         sales_name = rec[F47.salesperson_name]
#         company_id = rec[F47.company_id]
#         if company_id != '10':
#             return True
#         if '-' in sales_name:
#             sales_name, extra = sales_name.split('-')
#             if not extra.strip().isdigit() and sales_id != 'BAD':
#                 return True
#         return False
#     #
#     # saving below for later
#     #
#         sales_full_name = sales_name.lower()
#         names = sales_full_name.split()
#         if len(names) > 1:
#             sales_name = ' '.join([names[0], names[-1]])
#         else:
#             sales_name = sales_name.lower()
#         if sales_name in failed_match:
#             # this name already failed to match
#             continue
#         if var(potential_sales_people.get(sales_name)) is not None and len(var()) == 1:
#             # full-name match
#             sales_people[sales_id] = var()[0]
#         # elif len(names) == 1:
#         #     # if it didn't match before, it's not going to match now
#         #     pass
#         #     # potential_sales_people[sales_id] = None
#         #     # failed_match.add(sales_name)
#         elif var(potential_sales_people.get(names[-1])) and len(var()) == 1:
#             # last name match
#             sales_people[sales_id] = var()[0]
#         elif var(potential_sales_people.get(names[0])) and len(var()) == 1:
#             # first name match
#             sales_people[sales_id] = var()[0]
#         else:
#             # no match at all
#             # look for user matches and previously created dummy user accounts
#             all_users = res_users.browse(cr, uid, context=inactive_too)
#             all_users.sort(key=lambda r: not r.active)
#             if len(names) > 1:
#                 # try to match sales name with beginning of user name
#                 # e.g. "billy bob" with "billy bob joe"
#                 user = [u for u in all_users if u.name.lower().startswith(sales_name)]
#                 if user:
#                     if len(user) == 1:
#                         sales_people[sales_id] = user[0].id
#                         continue
#                     else:
#                         _logger.warning('unable to match %s (%s): too many possibles', sales_name, sales_id)
#                         failed_match.add(sales_name)
#                         continue
#
#                 login = names[0][0] + names[1]
#             else:
#                 login = names[0]
#             # try to match against login
#             # e.g. "billy bob" with "bbob"
#             for user in all_users:
#                 if login == user.login:
#                     sales_people[sales_id] = user.id
#                     break
#             else:
#                 # if we make it this far, no matches -- so let's create a new (inactive)
#                 # user so we can properly categorize customers
#                 _logger.warning('unable to match %s: creating dummy user', sales_name)
#                 id = res_users.create(
#                         cr, uid,
#                         {
#                             'name': NameCase(sales_name),
#                             'login': login,
#                             'active': False,
#                             'tz': 'America/Los_Angeles',
#                             },
#                         context=context)
#                 sales_people[sales_id] = id
#                 all_users.append(res_users.browse(cr, uid, id, context=inactive_too))
#             # continue
#             # failed_match.add(sales_name)

# main
Main()
