#!/usr/local/sbin/suid-python --virtualenv

# imports
from __future__ import print_function

from scription import *
from aenum import Enum, NamedTuple
from collections import defaultdict
from fis_schema import F8, F11, F27, F33, F65, F74, F97, F163
    # from fis_scheam import F47
from fis_schema import get_changed_records as get_changed_fis_records, combine_by_value
from openerplib import AttrDict, get_connection, get_records, Many2One, DEFAULT_SERVER_DATE_FORMAT
    # from traceback import format_exception
from pandaemonium import PidLockFile
from VSS.address import cszk, normalize_address, Rise, Sift, AddrCase, NameCase, BsnsCase, NameCaseReversed, PostalCode
from VSS.BBxXlate.fisData import fisData
from VSS.utils import fix_phone, fix_date, Date, grouped
import re
import os
import sys

C = Color
grey = C.Dim | C.FG_White
white = C.Normal | C.FG_White
same = C.Normal | C.FG_White
oldv = C.Normal | C.FG_Red
newv = C.Normal | C.FG_Green

SALEABLE_CATEGORY_XMLID = 'product_category_1'
SALEABLE_CATEGORY_ID = None
ETC_CATEGORY_ID = None
CLEANING_CATEGORY_XMLID = 'pd_cleaning'


# API
@Script(
        dryrun=('do not make changes, only show what changes would be made', FLAG),
        list_records=Spec('list added/changed records', FLAG),
        )
def main(dryrun, list_records):
    # make sure we are the only one running
    global config, oe, errors, DRYRUN, LIST_RECORDS, script_verbosity
    DRYRUN = LIST_RECORDS = False
    config = OrmFile('%s/config/fnx.ini' % os.environ['VIRTUAL_ENV'])
    oe = config.openerp
    oe = get_connection(hostname=oe.host, database=oe.db, login=oe.user, password=oe.pw)
    errors = defaultdict(list)
    if dryrun:
        DRYRUN = True
        if not script_verbosity:
            script_verbosity = 1
    LIST_RECORDS = list_records

@Command(
        files=Spec('changed FIS files', MULTIREQ, type=lambda f: f.lower()),
        method=Spec(
            'perform quick or full comparison [quick: compare against old FIS files;'
            ' full: compare against OpenERP records',
            OPTION,
            choices=['quick', 'full'],
            default='quick',
            type=lambda m: m.lower(),
            ),
        delete=Spec('delete records [default: send email]', FLAG,),
        )
def fis_integration(files, method, delete):
    # make sure we are the only one running
    global state_recs, country_recs, customer_terms_recs
    global skipped_suppliers, vendor_suppliers, ven2sup, vendor_codes
    global models, DELETE
    DELETE = delete
    with PidLockFile('/var/run/fis_update.pid'):
        ven2sup = {}
        state_recs = dict([
            (r.name, (r.id, r.code, r.country_id))
            for r in get_records(oe, 'res.country.state')
            ])
        country_recs = dict([
            (r.name, r.id)
            for r in get_records(oe, 'res.country')
            ])
        for name, rec_id in country_recs.items():
            country_recs[rec_id] = name
        customer_terms_recs = dict([
            (r.xml_id, r.id)
            for r in get_records(oe, 'fis.account.customer_terms')
            ])
        skipped_suppliers = set()
        vendor_suppliers = {}
        vendor_codes = set()
        if 'cnvz' in files:
            # handle_sales_reps(method)
            handle_carrier(method)
            handle_customer_terms()
            handle_product_category()
            handle_product_location()
        if 'emp1' in files:
            handle_emp1(method)
        if 'posm' in files or 'vnms' in files:
            handle_supplier(method)
        if 'csms' in files:
            handle_csms(method)
        if 'nvty' in files:
            handle_nvty(method)
        for m, problems in sorted(Model.errors.items()):
            error(m,'\n============')
            for p in problems:
                error('  ', p)
            error()

# helpers
def handle_nvty(method):
    global CLEANING_CATEGORY
    print('processing NVTY', border=('flag', '#'))
    context = {'fis-updates': True, 'active_test': False}
    product = AttrDict()
    product.product = Model(oe.get_model('product.product'), 'nvty', 'F135', context)
    # these are for tracking original old/new records
    new_product_records = {}
    old_product_records = {}
    # these are for tracking old/new versions of changed records
    old_changed_product_records = {}
    new_changed_product_records = {}
    # these are for added/deleted records
    added_product_records = {}
    deleted_records = {}
    # and the counts
    changed_count = 0
    added_count = 0
    deleted_count = 0
    ids = {}
    #
    # get the "old" data from:
    # - quick -> old fis file
    # - full -> current OpenERP data
    #
    # get dependent data
    ir = AttrDict()
    ir.model = AttrDict()
    ir.model.data = Model(oe.get_model('ir.model.data'), 'imd', '', context)
    # - cleaning category
    CLEANING_CATEGORY = ir_model_data.get_object_reference(cr, uid, 'fnx_pd', 'pd_cleaning')[1]
    nvty = fisData(135, keymatch='%s101000    101**')
    print(nvty.filename, verbose=2)
    print('gathering data', border='flag')
    if method == 'quick':
        #
        # for a quick compare we can use the fis records as-is
        #
        nvty_old = fisData(135, keymatch='10%s', data_path=config.network.fis_data_local_old_path)
        print(nvty_old.filename, verbose=2)
        print('collecting changed records')
        changes, added, deleted = get_changed_fis_records(
                nvty_old.values(),
                nvty.values(),
                enum_schema=[
                    F135.available_key, F135.sales_category, F135.trademarked,
                    F135.catalog_location, F135.description, F135.size, F135.upc_no, F135.primary_location,
                    F135.supplier_id, F135.new_retail, F135.new_wholesale
                    ],
                )
        #
        # now convert just the changed records, then look for commonalities
        #
        changes = [convert_nvty_rec(r) for r in changes]
        changed_map = combine_by_value(changes, allowed_combinations=...)

        #
        # we now have the subset of records that have changed, just need to separate them
        # into old and new
        #
        print('sorting changed records')

            old_company, old_contact = convert_csms_rec(res.partner, old)
            old_company_records[old_company.xml_id] = old_company
            new_company, new_contact = convert_csms_rec(res.partner, new)
            new_company_records[new_company.xml_id] = new_company
            # changes at the FIS level don't always translate to changes at the OpenERP level
            if old_company != new_company:
                old_changed_company_records[old_company.xml_id] = old_company
                new_changed_company_records[new_company.xml_id] = new_company
            # determine if contacts are added, deleted, or changed
            if old_contact is not None:
                old_contact_records[old_contact.xml_id] = old_contact
            if new_contact is not None:
                new_contact_records[new_contact.xml_id] = new_contact
            if old_contact == new_contact:
                pass
            elif old_contact is None:
                added_contact_records[new_contact.xml_id] = new_contact
            elif new_contact is None:
                deleted_records[old_contact.xml_id] = old_contact
            else:
                old_changed_contact_records[old_contact.xml_id] = old_contact
                new_changed_contact_records[new_contact.xml_id] = new_contact
            assert set(old_changed_company_records.keys()) == set(new_changed_company_records.keys()),\
                    "old and new company records mismatch"
            assert set(old_changed_contact_records.keys()) == set(new_changed_contact_records.keys()),\
                    "old and new contact records mismatch"
        #
        # and convert the new and deleted records
        #
    nvty_old = fisData(135, keymatch='10%s', data_path=config.network.fis_data_local_old_path)
    nvty_old
    # changed_records = 0
    # added_records = 0
    # changes, added, deleted = get_changed_fis_records(
    #         nvty_old.values(),
    #         nvty.values(),
    #         enum_schema=[
    #             F33.name, F33.salesrep, F33.catalog_category, F33.this_year_sales,
    #             F33.last_year_sales, F33.tele, F33.contact,
    #             ],
    #         address_fields=[
    #             F33.addr1, F33.addr2, F33.addr3,
    #             ],
    #         )
    # changed_map = combine_by_value(F33, changes)
    # print('--== PROCESSING CHANGES --==')
    # for changed_fields, records in sorted(changed_map.items()):
    combine_by_value
    grouped


def handle_csms(method):
    print('processing CSMS', border=('flag', '#'))
    context = {'fis-updates': True, 'active_test': False}
    res = AttrDict()
    res.partner = Model(oe.get_model('res.partner'), 'csms', 'F33', context)
    # these are for tracking original old/new records
    new_company_records = {}
    new_contact_records = {}
    old_company_records = {}
    old_contact_records = {}
    # these are for tracking old/new versions of changed records
    old_changed_company_records = {}
    old_changed_contact_records = {}
    new_changed_company_records = {}
    new_changed_contact_records = {}
    # these are for added/deleted records
    added_company_records = {}
    added_contact_records = {}
    deleted_records = {}
    # and the counts
    changed_count = 0
    added_count = 0
    deleted_count = 0
    ids = {}
    #
    # get the "old" data from:
    # - quick -> old fis file
    # - full -> current OpenERP data
    #
    csms = fisData(33, keymatch='10%s ')
    print(csms.filename, verbose=2)
    print('gathering data', border='flag')
    if method == 'quick':
        #
        # for a quick compare we can use the fis records as-is
        #
        csms_old = fisData(33, keymatch='10%s', data_path=config.network.fis_data_local_old_path)
        print(csms_old.filename, verbose=2)
        print('collecting changed records')
        changes, added, deleted = get_changed_fis_records(
                csms_old.values(),
                csms.values(),
                enum_schema=[
                    F33.name, F33.salesrep, F33.catalog_category, F33.this_year_sales,
                    F33.last_year_sales, F33.tele, F33.contact,
                    ],
                address_fields=[
                    F33.addr1, F33.addr2, F33.addr3,
                    ],
                )
        #
        # we now have the subset of records that have changed, just need to separate them
        # into old and new
        #
        print('sorting changed records')
        for old, new, diffs in changes:
            old_company, old_contact = convert_csms_rec(res.partner, old)
            old_company_records[old_company.xml_id] = old_company
            new_company, new_contact = convert_csms_rec(res.partner, new)
            new_company_records[new_company.xml_id] = new_company
            # changes at the FIS level don't always translate to changes at the OpenERP level
            if old_company != new_company:
                old_changed_company_records[old_company.xml_id] = old_company
                new_changed_company_records[new_company.xml_id] = new_company
            # determine if contacts are added, deleted, or changed
            if old_contact is not None:
                old_contact_records[old_contact.xml_id] = old_contact
            if new_contact is not None:
                new_contact_records[new_contact.xml_id] = new_contact
            if old_contact == new_contact:
                pass
            elif old_contact is None:
                added_contact_records[new_contact.xml_id] = new_contact
            elif new_contact is None:
                deleted_records[old_contact.xml_id] = old_contact
            else:
                old_changed_contact_records[old_contact.xml_id] = old_contact
                new_changed_contact_records[new_contact.xml_id] = new_contact
            assert set(old_changed_company_records.keys()) == set(new_changed_company_records.keys()),\
                    "old and new company records mismatch"
            assert set(old_changed_contact_records.keys()) == set(new_changed_contact_records.keys()),\
                    "old and new contact records mismatch"
        #
        # and convert the new and deleted records
        #
        print('sorting new and deleted records')
        for fis_rec in added:
            company, contact = convert_csms_rec(res.partner, fis_rec)
            new_company_records[company.xml_id] = company
            added_company_records[company.xml_id] = company
            if contact is not None:
                new_contact_records[contact.xml_id] = contact
                added_contact_records[contact.xml_id] = contact
        for fis_rec in deleted:
            company, contact = convert_csms_rec(res.partner, fis_rec)
            old_company_records[company.xml_id] = company
            deleted_records[company.xml_id] = company
            if contact is not None:
                old_contact_records[contact.xml_id] = contact
                deleted_records[contact.xml_id] = contact
    elif method == 'full':
        #
        # get the aging data (kept in a different format) -- only used in "full"
        #
        print('getting aging data')
        aging_data = get_customer_aging('%s/customer_aging.txt' % config.network.fis_data_local_path)
        #
        # when doing a full compare, we have to convert every single fis record before we can
        # check for changes
        #
        all_fis_records = AttrDict()
        for fis_rec in csms.values():
            company, contact = convert_csms_rec(res.partner, fis_rec, aging_data)
            all_fis_records[company.xml_id] = company
            # process contact, if any
            if contact is not None:
                all_fis_records[contact.xml_id] = contact
        #
        # retrieve the OpenERP records that match the CSMS module, and divvy them up into company
        # and contact records
        #
        print('retrieving OpenERP records')
        all_oe_records = dict([
                (r.xml_id, r)
                for r in get_records(
                    oe, 'res.partner',
                    domain=[('module','=','F33')],
                    fields=[
                        'id', 'module', 'xml_id', 'fis_csms_terms', 'fis_price_list',
                        'name', 'street', 'street2', 'city', 'state_id', 'zip', 'country_id',
                        'fis_valid', 'specials_notification', 'phone', 'is_company', 'customer',
                        'fis_updated_by_user', 'active', 'use_parent_address', 'fis_credit_limit',
                        'fis_credit_10_days', 'fis_credit_20_days', 'fis_credit_30_days',
                        'fis_credit_current', 'fis_credit_total',
                        ],
                    context=context,
                    )
                ])
        print('sorting company and contact records')
        for xml_id, datom in all_oe_records.items():
            ids[xml_id] = datom.id
            if xml_id.startswith('cntct_'):
                # do not update address from here -- it's either the default of "use parent's"
                # or it's been changed by the user (same with specials_notification)
                del datom.use_parent_address
                del datom.phone, datom.street, datom.street2
                del datom.city, datom.state_id, datom.zip, datom.country_id
                del datom.specials_notification, datom.fis_csms_terms, datom.fis_credit_current,
                del datom.fis_price_list, datom.fis_credit_limit, datom.fis_credit_total
                del datom.fis_credit_10_days, datom.fis_credit_20_days, datom.fis_credit_30_days
                old_contact_records[xml_id] = datom
            else:
                old_company_records[xml_id] = datom
        #
        # now we can separate into new, changed, and deleted buckets
        #
        print('sorting changed, new, and deleted company/contact records')
        all_keys = set(all_fis_records.keys() + old_company_records.keys() + old_contact_records.keys())
        for key in all_keys:
            old_rec = all_oe_records.get(key)
            new_rec = all_fis_records.get(key)
            if old_rec is new_rec is None:
                continue
            if old_rec is None:
                if is_contact(new_rec):
                    added_contact_records[key] = new_rec
                else:
                    added_company_records[key] = new_rec
                continue
            if new_rec is None:
                deleted_records[key] = old_rec
                continue
            # copy missing fields for proper equality testing
            new_rec.id = old_rec.id
            new_rec.fis_updated_by_user = old_rec.fis_updated_by_user
            if new_rec == old_rec:
                continue
            #
            # we have changes, save the records for later comparison
            #
            if key.startswith('cntct_'):
                # we don't use the "use_parent_address" nor "specials_notification" for changes
                del new_rec.use_parent_address, new_rec.specials_notification
                old_changed_contact_records[key] = old_rec
                new_changed_contact_records[key] = new_rec
            else:
                old_changed_company_records[key] = old_rec
                new_changed_company_records[key] = new_rec

        assert set(old_changed_company_records.keys()) == set(new_changed_company_records.keys()),\
                "old and new company records mismatch"
        assert set(old_changed_contact_records.keys()) == set(new_changed_contact_records.keys()),\
                "old and new contact records mismatch"
    else:
        abort('unknown METHOD: %r' % (method, ))
    #
    # at this point, all records are in AttrDict format, divided by company/contact
    # and deleted, added, changed
    #
    # process changes
    #
    if old_changed_company_records:
        print('processing company changes', border='flag')
    assert set(old_changed_company_records.keys()) == set(new_changed_company_records.keys()),\
            "old/new company records mismatch"
    changed_company_xml_ids = sorted(old_changed_company_records.keys())
    relevant_changes = False
    for xml_id in changed_company_xml_ids:
        #
        # TODO: check actual values in OpenERP and remove "changes" that are already set
        #
        # figure out the changes
        #
        old_record = old_changed_company_records[xml_id]
        new_record = new_changed_company_records[xml_id]
        assert old_record.keys() == new_record.keys(),\
                ('old/new keys mismatch\nold:%s\n%s\nnew:%s\n%s' %
                    ('|'.join(sorted(old_record.keys())), box(str(old_record)),
                     '|'.join(sorted(new_record.keys())), box(str(new_record))))
        if method == 'full':
            assert 'id' in old_record, box('id field missing for %r' % (xml_id, ))
            # check for user-updated-address and specials
            user_updates = old_record.fis_updated_by_user or ''
            if 'A' in user_updates:
                # drop all the address fields
                del old_record.use_parent_address
                del old_record.street, old_record.street2
                del old_record.city, old_record.state_id, old_record.zip, old_record.country_id
                del new_record.use_parent_address
                del new_record.street, new_record.street2
                del new_record.city, new_record.state_id, new_record.zip, new_record.country_id
            if 'S' in user_updates:
                del old_record.specials_notification
                del new_record.specials_notification
            if 'N' in user_updates:
                del old_record.name
                del new_record.name
        elif xml_id in ids:
            # maybe this xml_id has already been seen?
            new_record.id = old_record.id = ids[xml_id]
        else:
            # otherwise, we'll look it up when we check for changes against OpenERP
            pass
        changes = AttrDict()
        for key in old_record:
            if old_record[key] != new_record[key]:
                changes[key] = new_record[key]
        #
        # if this is a "full" update, we already have ids, and the changes are accurate
        # otherwise, we need to get the ids, and see if the "changes" have already been
        # put in place on the OpenERP side, as well as checking for user-updates that
        # should not be overridden
        #
        if method == 'quick':
            fields_to_check = changes.keys() + ['fis_updated_by_user']
            matches = res.partner.read(
                    domain=[('xml_id','=',xml_id),('module','=','F33')],
                    fields=fields_to_check+['fis_updated_by_user'],
                    )
            if not matches:
                res.partner.error('changed company F33:%s not found in OpenERP' % xml_id)
            [match] = matches
            new_record.id = old_record.id = match.id
            ids[xml_id] = match.id
            for field in changes:
                if match[field] == changes[field]:
                    del changes[field]
            user_updates = match.fis_updated_by_user or ''
            if 'N' in user_updates:
                changes.pop('name', None)
            if 'S' in user_updates:
                changes.pop('specials_notification', None)
            if 'A' in user_updates:
                for f in ('street', 'street2', 'city', 'state_id', 'zip', 'country_id'):
                    changes.pop(f, None)
        # quick and full from here
        if changes:
            relevant_changes = True
            changed_count += 1
            if LIST_RECORDS:
                echo('  F33:%s  %s' % (xml_id, new_record.name), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in changes.items()), '||', end='')
                echo()
            if not DRYRUN:
                res.partner.write(xml_id, new_record.id, changes)
    if not relevant_changes:
        print('...no relevant changes...')
    if old_changed_contact_records:
        print('processing contact changes', border='flag')
    assert set(old_changed_contact_records.keys()) == set(new_changed_contact_records.keys()),\
            "old/new contact records mismatch"
    changed_contact_xml_ids = sorted(old_changed_contact_records.keys())
    relevant_changes = False
    for xml_id in changed_contact_xml_ids:
        #
        # TODO: check actual values in OpenERP and remove "changes" that are already set
        #
        # figure out the changes
        #
        old_record = old_changed_contact_records[xml_id]
        new_record = new_changed_contact_records[xml_id]
        assert old_record.keys() == new_record.keys(),\
                ('old/new keys mismatch\nold:%s\n%s\nnew:%s\n%s' %
                    ('|'.join(sorted(old_record.keys())), box(str(old_record)),
                     '|'.join(sorted(new_record.keys())), box(str(new_record))))
        if 'id' in old_record:
            # old record is OpenERP's so it has the ID field already
            new_record.id = old_record.id
        elif xml_id in ids:
            # maybe this xml_id has already been seen?
            new_record.id = old_record.id = ids[xml_id]
        else:
            # otherwise, we'll look it up when we check for changes against OpenERP
            pass
        changes = AttrDict()
        for key in old_record:
            if old_record[key] != new_record[key]:
                changes[key] = new_record[key]
        #
        # if this is a "full" update, we already have ids, and the changes are accurate
        # otherwise, we need to get the ids, and see if the "changes" have already been
        #   put in place on the OpenERP side
        #
        if method == 'quick':
            fields_to_check = changes.keys()
            matches = res.partner.read(
                    domain=[('xml_id','=',xml_id),('module','=','F33')],
                    fields=fields_to_check+['fis_updated_by_user'],
                    )
            if not matches:
                res.partner.error('changed contact F33:%s not found in OpenERP' % xml_id)
            [match] = matches
            new_record.id = old_record.id = match.id
            for field in changes:
                if match[field] == changes[field]:
                    del changes[field]
            user_updates = match.fis_updated_by_user or ''
            if 'N' in user_updates:
                changes.pop('name', None)
            if 'S' in user_updates:
                changes.pop('specials_notification', None)
            if 'A' in user_updates:
                for f in ('street', 'street2', 'city', 'state_id', 'zip', 'country_id'):
                    changes.pop(f, None)
        # quick and full from here
        if changes:
            relevant_changes = True
            changed_count += 1
            if LIST_RECORDS:
                echo('  F33:%s  %s' % (xml_id, new_record.name), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in changes.items()), '||', end='')
                echo()
            if not DRYRUN:
                res.partner.write(xml_id, new_record.id, changes)
    if not relevant_changes:
        print('...no relevant changes...')
    #
    # add new customers
    #
    if added_company_records:
        print('adding company records', border='flag')
    for key, company in added_company_records.items():
        if not DRYRUN:
            # double-check that record doesn't already exist
            customer_id = res.partner.search(domain=[('xml_id','=',key),('module','=','F33')])
            if customer_id:
                [customer_id] = customer_id
                ids[key] = customer_id
                res.partner.error('FIS ID F33:%s (%s) already exists in OpenERP' % (key, company.name))
                continue
        added_count += 1
        if LIST_RECORDS:
            echo('  F33:%s  %s' % (key, company.name), end='  ')
            print('||', '||'.join('%s -> %r' % (k, v) for k, v in company.items()), '||', end='')
            echo()
        if not DRYRUN:
            customer_id = res.partner.create(key, company)
            if customer_id:
                company.id = customer_id
                ids[key] = customer_id
    #
    # add new contacts
    #
    if added_contact_records:
        print('adding contact records', border='flag')
    for key, contact in added_contact_records.items():
        if not DRYRUN:
            # double-check that record doesn't already exist
            parent_key = key[6:]
            contact_id = res.partner.search(domain=[('xml_id','=',key),('module','=','F33')])
            if contact_id:
                [contact_id] = contact_id
                ids[key] = contact_id
                res.partner.error('FIS ID F33:%s (%s) already exists in OpenERP' % (key, contact.name))
                continue
            else:
                # look for parent and get id
                contact.parent_id = ids.get(parent_key)
                if contact.parent_id is None:
                    print('  looking up parent id in OpenERP')
                    parent_id = res.partner.search(domain=[('xml_id','=',parent_key),('module','=','F33')])
                    if parent_id:
                        contact.parent_id = parent_id[0]
                        ids[parent_key] = parent_id
                    else:
                        print('  unable to find parent for %r' % key)
                        res.partner.error('unable to find parent for %r (%r)' % (key, parent_key, ))
                        continue
        added_count += 1
        if LIST_RECORDS:
            echo('  F33:%s  %s' % (key, contact.name), end='  ')
            print('||', '||'.join('%s -> %r' % (k, v) for k, v in contact.items()), '||', end='')
            echo()
        if not DRYRUN:
            contact_id = res.partner.create(key, contact)
            if contact_id:
                ids[key] = contact_id
                contact.id = contact_id
    #
    # delete/deactivate customers
    #
    if deleted_records:
        if not DELETE:
            print('deactivating customers', border='flag')
        else:
            print('deleting customers', border='flag')
        if LIST_RECORDS:
            for key, rec in sorted(deleted_records.items()):
                echo('  F163:%s  %s' % (key, rec.name))
        deleted_count = len(deleted_records)
        if not DRYRUN:
            ids = [ids[xml_id] for xml_id in deleted_records]
            if DELETE:
                res.partner.delete(ids, context=context)
            else:
                res.partner.write('...', ids, {'active': False}, context=context)
    #
    print('%d customers changed\n%d customers added\n%d customers %s'
            % (changed_count, added_count, deleted_count, ('deactivated','deleted')[DELETE]),
            border='box',
            )

def handle_customer_terms():
    print('processing CNVZd0', border=('flag', '#'))
    context = {'fis-updates': True, 'active_test': False}
    fis = AttrDict()
    fis.account = AttrDict()
    fis.account.customer_terms = Model(oe.get_model('fis.account.customer_terms'), 'cnvzd0', 'F8', context)
    # these  are for tracking old/new versions of changed records
    old_changed_terms_records = {}
    new_changed_terms_records = {}
    # these are for added/deleted records
    added_terms_records = {}
    deleted_records = {}
    # and the counts
    changed_count = 0
    added_count = 0
    deleted_count = 0
    ids = {}
    #
    # get the "old" data from:
    # - current OpenERP data
    #
    cnvzd0 = fisData(8, keymatch='D010%s')
    print(cnvzd0.filename, verbose=2)
    print('gathering data', border='flag')
    #
    # when doing a full compare, we have to convert every single fis record before we can
    # check for changes
    #
    all_fis_records = AttrDict()
    for fis_rec in cnvzd0.values():
        terms = convert_customer_terms_rec(fis_rec)
        all_fis_records[terms.xml_id] = terms
    #
    # retrieve the OpenERP records that match the CNVZsv module
    #
    print('retrieving OpenERP records')
    all_oe_records = dict([
            (r.xml_id, r)
            for r in get_records(
                oe, 'fis.account.customer_terms',
                domain=[('module','=','F8')],
                fields=[
                    'id', 'module', 'xml_id', 'description',
                    ],
                context=context,
                )
            ])
    #
    # now we can separate into new, changed, and deleted buckets
    #
    print('sorting changed, new, and deleted customer terms records')
    all_keys = set(all_fis_records.keys() + all_oe_records.keys())
    for key in all_keys:
        old_rec = all_oe_records.get(key)
        new_rec = all_fis_records.get(key)
        if old_rec is new_rec is None:
            continue
        if old_rec is None:
            added_terms_records[key] = new_rec
            continue
        if new_rec is None:
            deleted_records[key] = old_rec
            continue
        # copy missing fields for proper equality testing
        new_rec.id = old_rec.id
        if new_rec == old_rec:
            continue
        #
        # we have changes, save the records for later comparison
        #
        old_changed_terms_records[key] = old_rec
        new_changed_terms_records[key] = new_rec
    assert set(old_changed_terms_records.keys()) == set(new_changed_terms_records.keys()),\
            "old and new terms records mismatch"
    #
    # at this point, all records are in AttrDict format, divided by deleted, added, and changed
    #
    # process changes
    #
    if old_changed_terms_records:
        print('processing customer terms changes', border='flag')
    assert set(old_changed_terms_records.keys()) == set(new_changed_terms_records.keys()),\
            "old/new customer terms records mismatch"
    changed_terms_xml_ids = sorted(old_changed_terms_records.keys())
    for xml_id in changed_terms_xml_ids:
        #
        # figure out the changes
        #
        old_record = old_changed_terms_records[xml_id]
        new_record = new_changed_terms_records[xml_id]
        assert old_record.keys() == new_record.keys(),\
                ('old/new keys mismatch\nold:%s\n%s\nnew:%s\n%s' %
                    ('|'.join(sorted(old_record.keys())), box(str(old_record)),
                     '|'.join(sorted(new_record.keys())), box(str(new_record))))
        changes = AttrDict()
        for key in old_record:
            if old_record[key] != new_record[key]:
                changes[key] = new_record[key]
        if changes:
            changed_count += 1
            if LIST_RECORDS:
                echo('  F8:%s  %s' % (xml_id, new_record.description), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in changes.items()), '||', end='')
                echo()
            if not DRYRUN:
                fis.account.customer_terms.write(xml_id, new_record.id, changes)
    #
    # now add new customer terms
    #
    if added_terms_records:
        print('adding customer terms', border='flag')
    for key, terms in added_terms_records.items():
        echo(terms, border='box', verbose=2)
        # double-check that record doesn't already exist
        terms_id = fis.account.customer_terms.search(domain=[('xml_id','=',key),('module','=','F8')])
        if terms_id:
            [terms_id] = terms_id
            ids[key] = terms_id
            fis.account.customer_terms.error('FIS ID F8:%s (%s) already exists in OpenERP' % (key, terms.description))
        else:
            added_count += 1
            if LIST_RECORDS:
                echo('  F8:%s  %s' % (key, terms.description), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in terms.items()), '||', end='')
                echo()
            if not DRYRUN:
                terms_id = fis.account.customer_terms.create(key, terms)
                if terms_id:
                    terms.id = terms_id
                    ids[key] = terms_id
                    customer_terms_recs[terms.xml_id] = terms_id
    #
    # delete/deactivate customer terms
    #
    if deleted_records:
        if not DELETE:
            print('deactivating customer terms', border='flag')
        else:
            print('deleting customer terms', border='flag')
        if LIST_RECORDS:
            for key, rec in sorted(deleted_records.items()):
                echo('  F163:%s  %s' % (key, rec.description))
        deleted_count = len(deleted_records)
        if not DRYRUN:
            ids = [ids[xml_id] for xml_id in deleted_records]
            if DELETE:
                fis.account.customer_terms.delete(ids, context=context)
            else:
                fis.account.customer_terms.write('...', ids, {'active': False}, context=context)
    #
    print('%d customer terms changed\n%d customer terms added\n%d customer terms %s'
            % (changed_count, added_count, deleted_count, ('deactivated','deleted')[DELETE]),
            border='box',
            )

def handle_carrier(method):
    print('processing CNVZsv', border=('flag', '#'))
    context = {'fis-updates': True, 'active_test': False}
    res = AttrDict()
    res.partner = Model(oe.get_model('res.partner'), 'cnvzsv', 'F27', context)
    # these are for tracking original old/new records
    new_company_records = {}
    old_company_records = {}
    # these  are for tracking old/new versions of changed records
    old_changed_company_records = {}
    new_changed_company_records = {}
    # these are for added/deleted records
    added_company_records = {}
    deleted_records = {}
    # and the counts
    changed_count = 0
    added_count = 0
    deleted_count = 0
    ids = {}
    #
    # get the "old" data from:
    # - quick -> old fis file
    # - full -> current OpenERP data
    #
    cnvzsv = fisData(27, keymatch='SV10%s')
    print(cnvzsv.filename, verbose=2)
    print('gathering data', border='flag')
    if method == 'quick':
        #
        # for a quick compare we can use the fis records as-is
        #
        cnvzsv_old = fisData(27, keymatch='SV10%s', data_path=config.network.fis_data_local_old_path)
        print(cnvzsv_old.filename, verbose=2)
        print('collecting changed records')
        changes, added, deleted = get_changed_fis_records(
                cnvzsv_old.values(),
                cnvzsv.values(),
                enum_schema=[
                    F27.name, F27.tele, F27.fuel_surcharge,
                    ],
                address_fields=[
                    F27.addr1, F27.addr2, F27.addr3,
                    ],
                )
        #
        # we now have the subset of records that have changed, just need to separate them
        # into old and new
        #
        print('sorting changed records')
        for old, new, diffs in changes:
            old_company = convert_carrier_rec(old)
            old_company_records[old_company.xml_id] = old_company
            new_company = convert_carrier_rec(new)
            new_company_records[new_company.xml_id] = new_company
            # changes at the FIS level don't always translate to changes at the OpenERP level
            if old_company != new_company:
                old_changed_company_records[old_company.xml_id] = old_company
                new_changed_company_records[new_company.xml_id] = new_company
            assert set(old_changed_company_records.keys()) == set(new_changed_company_records.keys()),\
                    "old and new company records mismatch"
        #
        # and convert the new and deleted records
        #
        print('sorting new and deleted records')
        for fis_rec in added:
            company = convert_carrier_rec(fis_rec)
            new_company_records[company.xml_id] = company
            added_company_records[company.xml_id] = company
        for fis_rec in deleted:
            company = convert_carrier_rec(fis_rec)
            old_company_records[company.xml_id] = company
            deleted_records[company.xml_id] = company
    elif method == 'full':
        #
        # when doing a full compare, we have to convert every single fis record before we can
        # check for changes
        #
        all_fis_records = AttrDict()
        for fis_rec in cnvzsv.values():
            company = convert_carrier_rec(fis_rec)
            all_fis_records[company.xml_id] = company
        #
        # retrieve the OpenERP records that match the CNVZsv module
        #
        print('retrieving OpenERP records')
        all_oe_records = dict([
                (r.xml_id, r)
                for r in get_records(
                    oe, 'res.partner',
                    domain=[('module','=','F27')],
                    fields=[
                        'id', 'module', 'xml_id', 'is_carrier', 'is_company', 'use_parent_address',
                        'name', 'street', 'street2', 'city', 'state_id', 'zip', 'country_id',
                        'phone', 'fuel_surcharge', 'fis_updated_by_user',
                        ],
                    context=context,
                    )
                ])
        #
        # now we can separate into new, changed, and deleted buckets
        #
        print('sorting changed, new, and deleted carrier records')
        all_keys = set(all_fis_records.keys() + all_oe_records.keys())
        for key in all_keys:
            old_rec = all_oe_records.get(key)
            new_rec = all_fis_records.get(key)
            if old_rec is new_rec is None:
                continue
            if old_rec is None:
                added_company_records[key] = new_rec
                continue
            if new_rec is None:
                deleted_records[key] = old_rec
                continue
            # copy missing fields for proper equality testing
            new_rec.id = old_rec.id
            new_rec.fis_updated_by_user = old_rec.fis_updated_by_user
            if new_rec == old_rec:
                continue
            #
            # we have changes, save the records for later comparison
            #
            old_changed_company_records[key] = old_rec
            new_changed_company_records[key] = new_rec
        assert set(old_changed_company_records.keys()) == set(new_changed_company_records.keys()),\
                "old and new company records mismatch"
    else:
        abort('unknown METHOD: %r' % (method, ))
    #
    # at this point, all records are in AttrDict format, divided by deleted, added, and changed
    #
    # process changes
    #
    if old_changed_company_records:
        print('processing carrier changes', border='flag')
    assert set(old_changed_company_records.keys()) == set(new_changed_company_records.keys()),\
            "old/new carrier records mismatch"
    changed_company_xml_ids = sorted(old_changed_company_records.keys())
    relevant_changes = False
    for xml_id in changed_company_xml_ids:
        #
        # figure out the changes
        #
        old_record = old_changed_company_records[xml_id]
        new_record = new_changed_company_records[xml_id]
        assert old_record.keys() == new_record.keys(),\
                ('old/new keys mismatch\nold:%s\n%s\nnew:%s\n%s' %
                    ('|'.join(sorted(old_record.keys())), box(str(old_record)),
                     '|'.join(sorted(new_record.keys())), box(str(new_record))))
        if method == 'full':
            assert 'id' in old_record, box('id field missing for %r' % (xml_id, ))
            # check for user-updated-address and specials
            user_updates = old_record.fis_updated_by_user or ''
            if 'A' in user_updates:
                # drop all the address fields
                del old_record.use_parent_address
                del old_record.street, old_record.street2
                del old_record.city, old_record.state_id, old_record.zip, old_record.country_id
                del new_record.use_parent_address
                del new_record.street, new_record.street2
                del new_record.city, new_record.state_id, new_record.zip, new_record.country_id
            if 'N' in user_updates:
                del old_record.name
                del new_record.name
            if 'S' in user_updates:
                del old_record.specials_notification
                del new_record.specials_notification
        elif xml_id in ids:
            # maybe this xml_id has already been seen?
            new_record.id = old_record.id = ids[xml_id]
        else:
            # otherwise, we'll look it up when we check for changes against OpenERP
            pass
        changes = AttrDict()
        for key in old_record:
            if old_record[key] != new_record[key]:
                changes[key] = new_record[key]
        #
        # if this is a "full" update, we already have ids, and the changes are accurate
        # otherwise, we need to get the ids, and see if the "changes" have already been
        #   put in place on the OpenERP side
        #
        if method == 'quick':
            fields_to_check = changes.keys()
            matches = res.partner.read(
                    domain=[('xml_id','=',xml_id),('module','=','F27')],
                    fields=fields_to_check,
                    )
            if not matches:
                res.partner.error('changed company F27:%s not found in OpenERP' % xml_id)
            [match] = matches
            new_record.id = old_record.id = match.id
            ids[xml_id] = match.id
            for field in changes:
                if match[field] == changes[field]:
                    del changes[field]
            user_updates = match.fis_updated_by_user or ''
            if 'N' in user_updates:
                changes.pop('name', None)
            if 'S' in user_updates:
                changes.pop('specials_notification', None)
            if 'A' in user_updates:
                for f in ('street', 'street2', 'city', 'state_id', 'zip', 'country_id'):
                    changes.pop(f, None)
        # quick and full from here
        if changes:
            relevant_changes = True
            changed_count += 1
            if LIST_RECORDS:
                echo('  F27:%s  %s' % (xml_id, new_record.name), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in changes.items()), '||', end='')
                echo()
            if not DRYRUN:
                res.partner.write(xml_id, new_record.id, changes)
    if not relevant_changes:
        print('...no relevant changes...')
    #
    # now add new carriers
    #
    if added_company_records:
        print('adding carriers', border='flag')
    for key, company in added_company_records.items():
        if not DRYRUN:
            # double-check that record doesn't already exist
            customer_id = res.partner.search(domain=[('xml_id','=',key),('module','=','F27')])
            if customer_id:
                [customer_id] = customer_id
                ids[key] = customer_id
                res.partner.error('FIS ID F27:%s (%s) already exists in OpenERP' % (key, company.name))
                continue
        added_count += 1
        if LIST_RECORDS:
            echo('  F27:%s  %s' % (key, company.name), end='  ')
            print('||', '||'.join('%s -> %r' % (k, v) for k, v in company.items()), '||', end='')
            echo()
        if not DRYRUN:
            customer_id = res.partner.create(key, company)
            if customer_id:
                company.id = customer_id
                ids[key] = customer_id
    #
    # delete/deactivate carriers
    #
    if deleted_records:
        if not DELETE:
            print('deactivating carriers', border='flag')
        else:
            print('deleting carriers', border='flag')
        if LIST_RECORDS:
            for key, rec in sorted(deleted_records.items()):
                echo('  F163:%s  %s' % (key, rec.name))
        deleted_count = len(deleted_records)
        if not DRYRUN:
            ids = [ids[xml_id] for xml_id in deleted_records]
            if DELETE:
                res.partner.delete(ids, context=context)
            else:
                res.partner.write('...', ids, {'active': False}, context=context)
    #
    print('%d carriers changed\n%d carriers added\n%d carriers %s'
            % (changed_count, added_count, deleted_count, ('deactivated','deleted')[DELETE]),
            border='box',
            )

def handle_emp1(method):
    print('processing EMP1', border='#')
    context = {'hr_welcome': False, 'fis-updates': True, 'active_test': False}
    # today = Date.today()
    hr = AttrDict()
    hr.employee = Model(oe.get_model('hr.employee'), 'emp1', 'F74-emp', context)
    res = AttrDict()
    res.partner = Model(oe.get_model('res.partner'), 'emp1', 'F74', context)
    # these are for tracking original old/new records
    new_employee_records = {}
    old_employee_records = {}
    # these  are for tracking old/new versions of changed records
    old_changed_employee_records = {}
    new_changed_employee_records = {}
    # these are for added/deleted records
    added_employee_records = {}
    deleted_records = {}
    # and counts and tests
    changed_count = 0
    added_count = 0
    deleted_count = 0
    ids = {}
    active_test_needed = set()
    # birthday_test_needed = set()
    #
    # get the "old" data from:
    # - quick -> old fis file
    # - full -> current OpenERP data
    #
    emp1 = fisData(74, keymatch='10%s')
    print(emp1.filename, verbose=2)
    print('gathering data', border='lined')
    if method == 'quick':
        #
        # for a quick compare we can use the fis records as-is
        #
        emp1_old = fisData(74, keymatch='10%s', data_path=config.network.fis_data_local_old_path)
        print(emp1_old.filename, verbose=2)
        print('collecting changed records')
        changes, added, deleted = get_changed_fis_records(
                emp1_old.values(),
                emp1.values(),
                enum_schema=[
                    F74.name, F74.ssn, F74.tele, F74.date_hired, F74.date_terminated,
                    F74.birth_date, F74.last_raise, F74.status_flag, F74.pay_type,
                    F74.marital_status, F74.pension_status, F74.gender, F74.emergency_contact,
                    F74.emergency_phone, F74.exempt_fed, F74.exempt_state, F74.hourly_rate,
                    ],
                address_fields=[
                    F74.addr1, F74.addr2, F74.addr3,
                    ],
                ignore=lambda r: int(r[F74.emp_num]) >= 9000,
                )
        #
        # we now have the subset of records that have changed, just need to separate them
        # into old and new
        #
        print('sorting changed records')
        for old, new, diffs in changes:
            old_employee = convert_emp1_rec(old)
            old_employee_records[old_employee.xml_id] = old_employee
            new_employee = convert_emp1_rec(new)
            new_employee_records[new_employee.xml_id] = new_employee
            # changes at the FIS level don't always translate to changes at the OpenERP level
            if old_employee != new_employee:
                old_changed_employee_records[old_employee.xml_id] = old_employee
                new_changed_employee_records[new_employee.xml_id] = new_employee
            assert set(old_changed_employee_records.keys()) == set(new_changed_employee_records.keys()),\
                    "old and new employee records mismatch"
        #
        # and convert the new and deleted records
        #
        print('sorting new and deleted records')
        for fis_rec in added:
            employee = convert_emp1_rec(fis_rec)
            new_employee_records[employee.xml_id] = employee
            added_employee_records[employee.xml_id] = employee
        for fis_rec in deleted:
            employee = convert_emp1_rec(fis_rec)
            old_employee_records[employee.xml_id] = employee
            deleted_records[employee.xml_id] = employee
    elif method == 'full':
        #
        # when doing a full compare, we have to convert every single fis record before we can
        # check for changes
        #
        all_fis_records = AttrDict()
        print('retrieving FIS records')
        for fis_rec in emp1.values():
            employee = convert_emp1_rec(fis_rec)
            if employee is None:
                # print('skipping %r' % (fis_rec[F74.emp_num], ))
                continue
            all_fis_records[employee.xml_id] = employee
        #
        # retrieve the OpenERP records that match the CNVZsv module
        #
        print('retrieving OpenERP records')
        all_oe_records = dict([
                (r.xml_id, r)
                for r in get_records(
                    oe, 'hr.employee',
                    domain=[('module','=','F74-emp')],
                    fields=[
                        'id', 'module', 'xml_id', 'name', 'employment_type', 'ssnid', 'home_phone',
                        'home_street', 'home_street2', 'home_city', 'home_state_id', 'home_zip', 'home_country_id',
                        'hire_date', 'fire_date', 'active', 'status_flag', 'pension_plan',
                        'pay_type', 'hourly_rate', 'last_raise', 'marital', 'gender', 'identification_id',
                        'emergency_contact', 'emergency_number', 'state_exemptions', 'federal_exemptions',
                        ],
                    context=context,
                    )
                ])
        #
        # now we can separate into new, changed, and deleted buckets
        #
        print('sorting changed, new, and deleted emp1 records')
        all_keys = set(all_fis_records.keys() + all_oe_records.keys())
        for key in all_keys:
            old_rec = all_oe_records.get(key)
            new_rec = all_fis_records.get(key)
            if old_rec is new_rec is None:
                continue
            if old_rec is None:
                added_employee_records[key] = new_rec
                continue
            if new_rec is None:
                deleted_records[key] = old_rec
                continue
            # copy missing fields for proper equality testing
            new_rec.id = old_rec.id
            if new_rec == old_rec:
                continue
            #
            # we have changes, save the records for later comparison
            #
            old_changed_employee_records[key] = old_rec
            new_changed_employee_records[key] = new_rec
        assert set(old_changed_employee_records.keys()) == set(new_changed_employee_records.keys()),\
                "old and new employee records mismatch"
    else:
        abort('unknown METHOD: %r' % (method, ))
    #
    # at this point, all records are in AttrDict format, divided by deleted, added, and changed
    #
    # process changes
    #
    if old_changed_employee_records:
        print('processing emp1 changes', border='lined')
    assert set(old_changed_employee_records.keys()) == set(new_changed_employee_records.keys()),\
            "old/new emp1 records mismatch"
    changed_employee_xml_ids = sorted(old_changed_employee_records.keys())
    relevant_changes = False
    for xml_id in changed_employee_xml_ids:
        #
        # figure out the changes
        #
        old_record = old_changed_employee_records[xml_id]
        new_record = new_changed_employee_records[xml_id]
        assert old_record.keys() == new_record.keys(),\
                ('old/new keys mismatch\nold:%s\n%s\nnew:%s\n%s' %
                    ('|'.join(sorted(old_record.keys())), box(str(old_record)),
                     '|'.join(sorted(new_record.keys())), box(str(new_record))))
        if method == 'full':
            assert 'id' in old_record, box('id field missing for %r' % (xml_id, ))
        elif xml_id in ids:
            # maybe this xml_id has already been seen?
            new_record.id = old_record.id = ids[xml_id]
        else:
            # otherwise, we'll look it up when we check for changes against OpenERP
            pass
        changes = AttrDict()
        for key in old_record:
            if old_record[key] != new_record[key]:
                changes[key] = new_record[key]
        #
        # if this is a "full" update, we already have ids, and the changes are accurate
        # otherwise, we need to get the ids, and see if the "changes" have already been
        #   put in place on the OpenERP side
        #
        if method == 'quick':
            fields_to_check = changes.keys()
            matches = hr.employee.read(
                    domain=[('xml_id','=',xml_id),('module','=','F74-emp')],
                    fields=fields_to_check,
                    )
            if not matches:
                hr.employee.error('changed employee F74-emp:%s not found in OpenERP' % xml_id)
                continue
            print(matches, border='box')
            [match] = matches
            new_record.id = old_record.id = match.id
            ids[xml_id] = match.id
            for field in changes:
                if match[field] == changes[field]:
                    del changes[field]
        # quick and full from here
        if changes:
            relevant_changes = True
            changed_count += 1
            if LIST_RECORDS:
                echo('  F74-emp:%s  %s' % (xml_id, new_record.name), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in changes.items()), '||', end='')
                echo()
            if not DRYRUN:
                hr.employee.write(xml_id, new_record.id, changes)
    if not relevant_changes:
        print('...no relevant changes...')
    #
    # now add new employees
    #
    if added_employee_records:
        print('adding records', border='lined')
    for key, employee in added_employee_records.items():
        if not DRYRUN:
            # double-check that record doesn't already exist
            employee_id = hr.employee.search(domain=[('xml_id','=',key),('module','=','F74-emp')])
            if employee_id:
                [employee_id] = employee_id
                ids[key] = employee_id
                hr.employee.error('FIS ID F74-emp:%s (%s) already exists in OpenERP' % (key, employee.name))
                continue
        added_count += 1
        if LIST_RECORDS:
            echo('  F74-emp:%s  %s' % (key, employee.name), end='  ')
            print('||', '||'.join('%s -> %r' % (k, v) for k, v in employee.items()), '||', end='')
            echo()
        if not DRYRUN:
            employee_id = hr.employee.create(key, employee)
            if not employee_id:
                continue
            employee.id = employee_id
            ids[key] = employee_id
            # check for existing res.partner record, and use it if it exists
            emp_num = employee.xml_id
            emp_name = employee.name
            rp_id = hr.employee.search(domain=[('module','=','F74'),('xml_id','=',emp_num)])
            if rp_id:
                # update res.partner record with employee link
                rp_id = rp_id[0]
                res.partner.write(emp_num, rp_id, {'employee_id': employee_id})
            else:
                # otherwise, try to create it, leaving it at False (0) on failure
                rp_id = res.partner.create(
                        emp_num,
                        {'name': emp_name, 'xml_id': emp_num, 'module': 'F74', 'employee_id': employee_id},
                        )
    #
    # deactivate employees  --  DO NOT DELETE
    #
    if deleted_records:
        print('deactivating employees', border='flag')
        if LIST_RECORDS:
            header_needed = True
            for emp_num, rec in sorted(deleted_records.items()):
                if not rec.active:
                    deleted_records.pop(emp_num)
                else:
                    if header_needed:
                        echo('%6s  %-11s  %-11s  %s' % ('Emp. #', 'Start Date', 'End Date', 'Employee Name'))
                        header_needed = False
                    name = NameCaseReversed(rec.name)
                    date_hired = rec.hire_date or ''
                    date_terminated = rec.fire_date or ''
                    echo("%6s  %-11s  %-11s  %s" % (emp_num, date_hired, date_terminated, name))
        deleted_count = len(deleted_records)
        if not DRYRUN:
            ids = [ids[xml_id] for xml_id in deleted_records]
            res.partner.write('...', ids, {'active': False}, context=context)
    #
    #
    # check for suspect birthdates
    #
    # if birthday_test_needed:
    #     underage = today.replace(delta_year=-18).strftime(DEFAULT_SERVER_DATE_FORMAT)
    #     overage = today.replace(delta_year=+65).strftime(DEFAULT_SERVER_DATE_FORMAT)
    #     bad_birthdays = hr.employee.read(
    #             domain=[('id','in',list(birthday_test_needed)),'|',('birthday','<',underage),('birthday','>',overage)],
    #             fields=['id', 'birthday', 'name', 'xml_id'],
    #             )
    #     if bad_birthdays:
    #         employee_list = []
    #         for rec in bad_birthdays:
    #             rec.name = NameCaseReversed(rec.name)
    #             rec.birthday = Date.strptime(rec.birthday, DEFAULT_SERVER_DATE_FORMAT)#.strftime('%d-%b-%Y')
    #         for rec in sorted(bad_birthdays, key=lambda r: r.name):
    #             employee_list.append("%5s:  %s - %s" % (rec.xml_id, rec.birthday, rec.name))
    #         mail(message=
    #                 "From: FIS Integration Continuous Update <noreply@sunridgefarms.com>\n"
    #                 # "To: Ron Giannini <rgiannini@sunridgefarms.com>\n"
    #                 # "Cc: Emile van Sebille <emile@sunridgefarms.com>\n"
    #                 # "Cc: Alyssa Corinne <alyssa@sunridgefarms.com>\n"
    #                 "Cc: Ethan Furman <ethan@stoneleaf.us>\n"
    #                 "Subject: employees with suspect birthdates in FIS [emp1, 74]\n"
    #                 "\n"
    #                 + '\n'.join(employee_list),
    #                 )
    #
    # check for (in)active records
    #
    if active_test_needed:
        active_test = hr.employee.read(
                domain=[('id','in',list(active_test_needed))],
                fields=['id', 'hire_date', 'fire_date','xml_id'],
                )
        active = []
        active_keys = []
        inactive = []
        inactive_keys = []
        for rec in active_test:
            if not rec.fire_date:
                active.append(rec.id)
                active_keys.append(rec.xml_id)
            elif rec.fire_date < rec.hire_date:
                active.append(rec.id)
                active_keys.append(rec.xml_id)
            else:
                inactive.append(rec.id)
                inactive_keys.append(rec.xml_id)
        if active:
            print('setting %d records active' % len(active_keys))
            if not DRYRUN:
                hr.employee.write(active_keys, active, {'active': True})
        if inactive:
            print('setting %d records inactive' % len(inactive_keys))
            if not DRYRUN:
                hr.employee.write(inactive_keys, inactive, {'active': False})
    print(
            '%d records changed\n%d records added\n%d records (maybe) deleted'
                % (changed_count, added_count, deleted_count),
            border='box',
            )

def handle_product_category():
    #
    # always use "full" method
    #
    print('processing CNVZas', border=('box','#'))
    global SALEABLE_CATEGORY_ID, ETC_CATEGORY_ID, category_ids
    cnvzas = fisData(11, keymatch='as10%s')
    print(cnvzas.filename, verbose=2)
    context = {'fis-updates': True, 'active_test': False}
    # these  are for tracking old/new versions of changed records
    old_changed_category_records = {}
    new_changed_category_records = {}
    # these are for added/deleted records
    added_category_records = {}
    deleted_records = {}
    # and the counts
    changed_count = 0
    added_count = 0
    deleted_count = 0
    product = AttrDict()
    product.category = Model(oe.get_model('product.category'), 'cnvzas', 'F11', context)
    ir = AttrDict()
    ir.model = AttrDict()
    ir.model.data = Model(oe.get_model('ir.model.data'), 'imd', '', context)
    _, SALEABLE_CATEGORY_ID = ir.model.data.get_object_reference('product', SALEABLE_CATEGORY_XMLID)
    #
    # get the "old" data from:
    # - full -> current OpenERP data
    #
    print('gathering data', border='flag')
    #
    # retrieve the OpenERP records that match the CNVZsv module
    #
    print('retrieving OpenERP records')
    all_oe_records = dict([
            (r.xml_id, r)
            for r in get_records(
                oe, 'product.category',
                domain=[('module','=','F11')],
                fields=[
                    'id', 'module', 'xml_id', 'name', 'parent_id',
                    ],
                context=context,
                )
            ])
    # and update category_ids
    category_ids = ids = dict([
        (r.xml_id, r.id)
        for r in all_oe_records.values()
        ])
    ETC_CATEGORY_ID = ids.get('9')
    #
    # when doing a full compare, we have to convert every single fis record before we can
    # check for changes
    #
    print('retrieving and converting FIS records')
    all_fis_records = AttrDict()
    for fis_rec in cnvzas.values():
        category = convert_product_category_rec(fis_rec)
        all_fis_records[category.xml_id] = category
    #
    # now we can separate into new, changed, and deleted buckets
    #
    print('sorting changed, new, and deleted customer category records')
    all_keys = set(all_fis_records.keys() + all_oe_records.keys())
    for key in all_keys:
        old_rec = all_oe_records.get(key)
        new_rec = all_fis_records.get(key)
        if old_rec is new_rec is None:
            continue
        if old_rec is None:
            added_category_records[key] = new_rec
            continue
        if new_rec is None:
            deleted_records[key] = old_rec
            continue
        # copy missing fields for proper equality testing
        new_rec.id = old_rec.id
        if new_rec == old_rec:
            continue
        #
        # we have changes, save the records for later comparison
        #
        old_changed_category_records[key] = old_rec
        new_changed_category_records[key] = new_rec
    #
    # at this point, all records are in AttrDict format, divided by deleted, added, and changed
    #
    # add new categories
    #
    if added_category_records:
        print('adding category records', border='flag')
    for key, category in sorted(added_category_records.items()):
        # replace parent_id?
        if not isinstance(category.parent_id, (int, long)):
            # must be a parent xml_id
            category.parent_id = ids[category.parent_id]
        # double-check that record doesn't already exist
        if not DRYRUN:
            category_id = product.category.search(domain=[('xml_id','=',key),('module','=','F11')])
            if category_id:
                [category_id] = category_id
                ids[key] = category_id
                product.category.error('FIS ID F11:%s (%s) already exists in OpenERP' % (key, category.name))
                continue
        added_count += 1
        if LIST_RECORDS:
            echo('  F11:%s  %s' % (key, category.name), end='  ')
            print('||', '||'.join('%s -> %r' % (k, v) for k, v in category.items()), '||', end='')
            echo()
        if not DRYRUN:
            category_id = product.category.create(key, category)
            if category_id:
                category.id = category_id
                ids[key] = category_id
        else:
            # fake an id for the dryrun if parent category
            if len(key) == 1:
                ids[key] = 9999999
        if ETC_CATEGORY_ID is None and key == '9':
            ETC_CATEGORY_ID = ids[key]
    #
    # process changes
    #
    if old_changed_category_records:
        print('processing category changes', border='flag')
    assert set(old_changed_category_records.keys()) == set(new_changed_category_records.keys()),\
            "old and new category records mismatch"
    changed_category_xml_ids = sorted(old_changed_category_records.keys())
    relevant_changes = False
    for xml_id in changed_category_xml_ids:
        #
        # figure out the changes
        #
        old_record = old_changed_category_records[xml_id]
        new_record = new_changed_category_records[xml_id]
        assert old_record.keys() == new_record.keys(),\
                ('old/new keys mismatch\nold:%s\n%s\nnew:%s\n%s' %
                    ('|'.join(sorted(old_record.keys())), box(str(old_record)),
                     '|'.join(sorted(new_record.keys())), box(str(new_record))))
        assert 'id' in old_record, box('id field missing for %r' % (xml_id, ))
        if not isinstance(new_record.parent_id, (int, long)):
            # must be a parent xml_id
            assert isinstance(new_record.parent_id, basestring), (
                    'new_record.parent_id should be a string, but is %r (%r)'
                    % (new_record.parent_id, type(new_record.parent_id))
                    )
            new_record.parent_id = ids.get(new_record.parent_id) or ids.get('9')
        assert isinstance(new_record.parent_id, (int, long)) and new_record.parent_id > 0, 'new_record.parent_id should be a positive integer, not %r\n' % (new_record.parent_id, ) + box(str(new_record))
        # check for user-updated-address and specials
        changes = AttrDict()
        for key in old_record:
            if old_record[key] != new_record[key]:
                changes[key] = new_record[key]
        if changes:
            relevant_changes = True
            changed_count += 1
            if LIST_RECORDS:
                echo('  F11:%s  %s' % (xml_id, new_record.name), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in changes.items()), '||', end='')
                echo()
            if not DRYRUN:
                product.category.write(xml_id, new_record.id, changes)
    if not relevant_changes:
        print('...no relevant changes...')
    #
    # deleted/deactivate categories
    #
    if deleted_records:
        # toss any records that don't already exist in OpenERP
        for key, rec in sorted(deleted_records.items()):
            if key not in ids:
                deleted_records.pop(key)
            elif not all_oe_records[key].active:
                deleted_records.pop(key)
            elif LIST_RECORDS:
                echo('  F11:%s  %s' % (key, rec.name))
        deleted_count = len(deleted_records)
        if deleted_count:
            if not DELETE:
                print('deactivating records', border='flag')
            else:
                print('deleting records', border='flag')
            if not DRYRUN:
                ids = [ids[xml_id] for xml_id in deleted_records]
                if DELETE:
                    product.category.delete(ids, context=context)
                else:
                    product.category.write('...', ids, {'active': False}, context=context)
    #
    print('%d categories changed\n%d categories added\n%d categories %s'
            % (changed_count, added_count, deleted_count, ('deactivated','deleted')[DELETE]),
            border='box',
            )

def handle_product_location():
    #
    # always use "full" method
    #
    print('processing CNVZaa', border=('box','#'))
    cnvzaa = fisData(97, keymatch='aa10%s')
    print(cnvzaa.filename, verbose=2)
    context = {'fis-updates': True, 'active_test': False}
    # these  are for tracking old/new versions of changed records
    old_changed_location_records = {}
    new_changed_location_records = {}
    # these are for added/deleted records
    added_location_records = {}
    deleted_records = {}
    # and the counts
    changed_count = 0
    added_count = 0
    deleted_count = 0
    product = AttrDict()
    product.location = Model(oe.get_model('product.available_at'), 'cnvzaa', 'F11', context)
    #
    # get the "old" data from:
    # - full -> current OpenERP data
    #
    print('gathering data', border='flag')
    #
    # retrieve the OpenERP records that match the CNVZsv module
    #
    print('retrieving OpenERP records')
    all_oe_records = dict([
            (r.xml_id, r)
            for r in get_records(
                oe, 'product.available_at',
                domain=[('module','=','F97')],
                fields=[
                    'id', 'module', 'xml_id', 'name', 'availability',
                    ],
                context=context,
                )
            ])
    # and update ids
    ids = dict([
        (r.xml_id, r.id)
        for r in all_oe_records.values()
        ])
    #
    # when doing a full compare, we have to convert every single fis record before we can
    # check for changes
    #
    print('retrieving and converting FIS records')
    all_fis_records = AttrDict()
    for fis_rec in cnvzaa.values():
        location = convert_product_location_rec(fis_rec)
        all_fis_records[location.xml_id] = location
    #
    # now we can separate into new, changed, and deleted buckets
    #
    print('sorting changed, new, and deleted customer category records')
    all_keys = set(all_fis_records.keys() + all_oe_records.keys())
    for key in all_keys:
        old_rec = all_oe_records.get(key)
        new_rec = all_fis_records.get(key)
        if old_rec is new_rec is None:
            continue
        if old_rec is None:
            added_location_records[key] = new_rec
            continue
        if new_rec is None:
            deleted_records[key] = old_rec
            continue
        # copy missing fields for proper equality testing
        new_rec.id = old_rec.id
        if new_rec == old_rec:
            continue
        #
        # we have changes, save the records for later comparison
        #
        old_changed_location_records[key] = old_rec
        new_changed_location_records[key] = new_rec
    #
    # at this point, all records are in AttrDict format, divided by deleted, added, and changed
    #
    # add new locations
    #
    if added_location_records:
        print('adding location records', border='flag')
    for key, location in sorted(added_location_records.items()):
        if not DRYRUN:
            # double-check that record doesn't already exist
            location_id = product.location.search(domain=[('xml_id','=',key),('module','=','F97')])
            if location_id:
                [location_id] = location_id
                ids[key] = location_id
                product.location.error('FIS ID F97:%s (%s) already exists in OpenERP' % (key, location.name))
                continue
        added_count += 1
        if LIST_RECORDS:
            echo('  F97:%s  %s' % (key, location.name), end='  ')
            print('||', '||'.join('%s -> %r' % (k, v) for k, v in location.items()), '||', end='')
            echo()
        if not DRYRUN:
            location_id = product.location.create(key, location)
            if location_id:
                location.id = location_id
                ids[key] = location_id
    #
    # process changes
    #
    if old_changed_location_records:
        print('processing location changes', border='flag')
    assert set(old_changed_location_records.keys()) == set(new_changed_location_records.keys()),\
            "old and new location records mismatch"
    changed_location_xml_ids = sorted(old_changed_location_records.keys())
    relevant_changes = False
    for xml_id in changed_location_xml_ids:
        #
        # figure out the changes
        #
        old_record = old_changed_location_records[xml_id]
        new_record = new_changed_location_records[xml_id]
        assert old_record.keys() == new_record.keys(),\
                ('old/new keys mismatch\nold:%s\n%s\nnew:%s\n%s' %
                    ('|'.join(sorted(old_record.keys())), box(str(old_record)),
                     '|'.join(sorted(new_record.keys())), box(str(new_record))))
        assert 'id' in old_record, box('id field missing for %r' % (xml_id, ))
        # check for user-updated-address and specials
        changes = AttrDict()
        for key in old_record:
            if old_record[key] != new_record[key]:
                changes[key] = new_record[key]
        if changes:
            relevant_changes = True
            changed_count += 1
            if LIST_RECORDS:
                echo('  F97:%s  %s' % (xml_id, new_record.name), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in changes.items()), '||', end='')
                echo()
            if not DRYRUN:
                product.location.write(xml_id, new_record.id, changes)
    if not relevant_changes:
        print('...no relevant changes...')
    #
    # deleted/deactivate locations
    #
    if deleted_records:
        # toss any records that don't already exist in OpenERP
        for key, rec in sorted(deleted_records.items()):
            if key not in ids:
                deleted_records.pop(key)
            elif LIST_RECORDS:
                echo('  F97:%s  %s' % (key, rec.name))
        deleted_count = len(deleted_records)
        if deleted_count:
            if not DELETE:
                print('deactivating records', border='flag')
            else:
                print('deleting records', border='flag')
            if not DRYRUN:
                ids = [ids[xml_id] for xml_id in deleted_records]
                if DELETE:
                    product.location.delete(ids, context=context)
    #
    print('%d locations changed\n%d locations added\n%d locations %s'
            % (changed_count, added_count, deleted_count, ('deactivated','deleted')[DELETE]),
            border='box',
            )



def handle_supplier(method):
    #
    # combine the posm and vnms tables to create supplier records;
    # majority of data comes from the posm table, with contact name,
    # phone, and fax numbers coming from vnms
    #
    # always use "full" method
    #
    global posm, vnms
    print('processing POSM/VNMS', border=('box','#'))
    vnms = fisData(65, keymatch='10%s')
    posm = fisData(163, keymatch='10%s')
    print(posm.filename, verbose=2)
    print(vnms.filename, verbose=2)
    context = {'fis-updates': True, 'active_test': False}
    res = AttrDict()
    # on the OpenERP side, supplier records use F163 as the FIS module
    res.partner = Model(oe.get_model('res.partner'), 'posm/vnms', 'F163', context)
    # these are for tracking original old/new records
    new_company_records = {}
    old_company_records = {}
    new_contact_records = {}
    old_contact_records = {}
    # these  are for tracking old/new versions of changed records
    old_changed_company_records = {}
    new_changed_company_records = {}
    old_changed_contact_records = {}
    new_changed_contact_records = {}
    # these are for added/deleted records
    added_company_records = {}
    added_contact_records = {}
    deleted_records = {}
    # and the counts
    changed_count = 0
    added_count = 0
    deleted_count = 0
    ids = {}
    #
    # get the "old" data from:
    # - full -> current OpenERP data
    #
    print('gathering data', border='flag')
    #
    # when doing a full compare, we have to convert every single fis record before we can
    # check for changes
    #
    print('retrieving and converting FIS records')
    all_keys = set(posm.keys() + vnms.keys())
    all_fis_records = AttrDict()
    for code in sorted(posm.keys()):
        key = code[2:]
        company, contact = convert_supplier_rec(key)
        # if company/contact are invalid, just put them in the deleted category
        all_fis_records[company.xml_id] = company
        if '**NO LONGER HERE**' in company.name or '**OLDER/N.L.H. EMPLOYEE**' in company.name:
            deleted_records[company.xml_id] = company
        else:
            new_company_records[company.xml_id] = company
        if contact is not None:
            all_fis_records[contact.xml_id] = contact
            if '**NO LONGER HERE**' in contact.name or '**OLDER/N.L.H. EMPLOYEE**' in contact.name:
                deleted_records[contact.xml_id] = contact
            else:
                new_contact_records[contact.xml_id] = contact
    for code in sorted(vnms.keys()):
        key = code[2:]
        if key in vendor_codes:
            continue
        company, contact = convert_supplier_rec(key)
        # if company/contact are invalid, just put them in the deleted category
        all_fis_records[company.xml_id] = company
        if '**NO LONGER HERE**' in company.name or '**OLDER/N.L.H. EMPLOYEE**' in company.name:
            deleted_records[company.xml_id] = company
        else:
            new_company_records[company.xml_id] = company
        if contact is not None:
            all_fis_records[contact.xml_id] = contact
            if '**NO LONGER HERE**' in contact.name or '**OLDER/N.L.H. EMPLOYEE**' in contact.name:
                deleted_records[contact.xml_id] = contact
            else:
                new_contact_records[contact.xml_id] = contact
    #
    # retrieve the OpenERP records that match the POSM/VNMS module, and divvy them up into company
    # and contact records
    #
    print('retrieving OpenERP records')
    all_oe_records = dict([
            (r.xml_id, r)
            for r in get_records(
                oe, 'res.partner',
                domain=[('module','=','F163')],
                fields=[
                    'id', 'module', 'xml_id', 'active', 'phone', 'fax',
                    'name', 'street', 'street2', 'city', 'state_id', 'zip', 'country_id',
                    'fis_valid', 'phone', 'is_company', 'customer', 'supplier',
                    'fis_updated_by_user', 'use_parent_address',
                    'fis_org_cert_file', 'fis_non_gmo', 'fis_kosher', 'fis_org_exp',
                    'fis_gmo_exp', 'fis_kosher_exp',
                    ],
                context=context,
                )
            ])
    print('sorting company and contact records')
    for xml_id, datom in all_oe_records.items():
        ids[xml_id] = datom.id
        if xml_id.startswith('cntct_'):
            # do not update address from here -- it's either the default of "use parent's"
            # or it's been changed by the user (same with specials_notification)
            del datom.use_parent_address
            del datom.street, datom.street2
            del datom.city, datom.state_id, datom.zip, datom.country_id
            del datom.fis_org_cert_file, datom.fis_non_gmo, datom.fis_kosher
            del datom.fis_org_exp, datom.fis_gmo_exp, datom.fis_kosher_exp
            old_contact_records[xml_id] = datom
        else:
            old_company_records[xml_id] = datom
    #
    # now we can separate into new, changed, and deleted buckets
    #
    print('sorting company records into changed, new, and deleted')
    all_keys = set(new_company_records.keys() + old_company_records.keys())
    for key in all_keys:
        old_rec = all_oe_records.get(key)
        new_rec = all_fis_records.get(key)
        if old_rec is new_rec is None:
            assert False, "a key is missing from both old and new records???"
        if old_rec is None:
            if new_rec.active:
                added_company_records[key] = new_rec
            continue
        if new_rec is None:
            deleted_records[key] = old_rec
            continue
        if not new_rec.active:
            deleted_records[key] = old_rec
            continue
        # copy missing fields for proper equality testing / remove unused-for-comparison fields
        new_rec.id = old_rec.id
        new_rec.fis_updated_by_user = old_rec.fis_updated_by_user
        # for now, we don't want the FIS active status overwriting the OpenERP active status
        del new_rec.active, old_rec.active
        assert new_rec.keys() == old_rec.keys(), box(
                "keys mismatch\n---\nold record:\n%s\n---\nnew record:\n%s"
                % (old_rec.keys(), new_rec.keys())
                )
        if new_rec == old_rec:
            continue
        #
        # we have changes, save the records for later comparison
        #
        old_changed_company_records[key] = old_rec
        new_changed_company_records[key] = new_rec
    assert set(old_changed_company_records.keys()) == set(new_changed_company_records.keys()),\
            "old and new company records mismatch"
    #
    print('sorting contact records into changed, new, and deleted')
    all_keys = set(new_contact_records.keys() + old_contact_records.keys())
    for key in all_keys:
        parent_key = key[6:]
        old_rec = all_oe_records.get(key)
        new_rec = all_fis_records.get(key)
        if old_rec is new_rec is None:
            assert False, "a key is missing from both old and new records???"
        if old_rec is None:
            if new_rec.active:
                added_contact_records[key] = new_rec
            continue
        if new_rec is None:
            deleted_records[key] = old_rec
            continue
        if not new_rec.active:
            deleted_records[key] = old_rec
            continue
        if parent_key in deleted_records:
            deleted_records[key] = old_rec
            continue
        # copy missing fields for proper equality testing / remove unused-for-comparison fields
        new_rec.id = old_rec.id
        new_rec.fis_updated_by_user = old_rec.fis_updated_by_user
        del new_rec.use_parent_address
        # for now, we don't want the FIS active status overwriting the OpenERP active status
        del new_rec.active, old_rec.active
        assert new_rec.keys() == old_rec.keys(), '\n'+box(
                "keys mismatch\n---\nold record:\n%s\n---\nnew record:\n%s"
                % ('\n'.join(old_rec.keys()), '\n'.join(new_rec.keys()))
                )
        if new_rec == old_rec:
            continue
        #
        # we have changes, save the records for later comparison
        #
        old_changed_contact_records[key] = old_rec
        new_changed_contact_records[key] = new_rec
    assert set(old_changed_contact_records.keys()) == set(new_changed_contact_records.keys()),\
            "old and new contact records mismatch"
    #
    # at this point, all records are in AttrDict format, divided by deleted, added, changed
    #
    # process company changes
    #
    if old_changed_company_records:
        print('processing company changes', border='flag')
    assert set(old_changed_company_records.keys()) == set(new_changed_company_records.keys()),\
            "old/new company records mismatch"
    changed_company_xml_ids = sorted(old_changed_company_records.keys())
    relevant_changes = False
    for xml_id in changed_company_xml_ids:
        #
        # TODO: check actual values in OpenERP and remove "changes" that are already set
        #
        # figure out the changes
        #
        old_record = old_changed_company_records[xml_id]
        new_record = new_changed_company_records[xml_id]
        assert old_record.keys() == new_record.keys(),\
                ('old/new keys mismatch\nold:%s\n%s\nnew:%s\n%s' %
                    ('|'.join(sorted(old_record.keys())), box(str(old_record)),
                     '|'.join(sorted(new_record.keys())), box(str(new_record))))
        # check for user-updated-address and specials
        user_updates = old_record.fis_updated_by_user or ''
        if 'A' in user_updates:
            # drop all the address fields
            del old_record.use_parent_address
            del old_record.street, old_record.street2
            del old_record.city, old_record.state_id, old_record.zip, old_record.country_id
            del new_record.use_parent_address
            del new_record.street, new_record.street2
            del new_record.city, new_record.state_id, new_record.zip, new_record.country_id
        if 'N' in user_updates:
            del old_record.name
            del new_record.name
        changes = AttrDict()
        for key in old_record:
            if old_record[key] != new_record[key]:
                changes[key] = new_record[key]
        if changes:
            relevant_changes = True
            changed_count += 1
            if LIST_RECORDS:
                echo('  F163:%s  %s' % (xml_id, new_record.name), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in changes.items()), '||', end='')
                echo()
            if not DRYRUN:
                res.partner.write(xml_id, new_record.id, changes)
    if not relevant_changes:
        print('...no relevant changes...')
    #
    # add new companies
    #
    if added_company_records:
        print('adding company records', border='flag')
    for key, company in added_company_records.items():
        if not DRYRUN:
            # double-check that record doesn't already exist
            company_id = res.partner.search(domain=[('xml_id','=',key),('module','=','F163')])
            if company_id:
                [company_id] = company_id
                ids[key] = company_id
                res.partner.error('FIS ID F163:%s (%s) already exists in OpenERP' % (key, company.name))
                continue
        added_count += 1
        if LIST_RECORDS:
            echo('  F163:%s  %s' % (key, company.name), end='  ')
            print('||', '||'.join('%s -> %r' % (k, v) for k, v in company.items()), '||', end='')
            echo()
        if not DRYRUN:
            company_id = res.partner.create(key, company)
            if company_id:
                company.id = company_id
                ids[key] = company_id
    #
    # process contact changes
    #
    if old_changed_contact_records:
        print('processing contact changes', border='flag')
    assert set(old_changed_contact_records.keys()) == set(new_changed_contact_records.keys()),\
            "old/new contact records mismatch"
    changed_contact_xml_ids = sorted(old_changed_contact_records.keys())
    relevant_changes = False
    for xml_id in changed_contact_xml_ids:
        #
        # TODO: check actual values in OpenERP and remove "changes" that are already set
        #
        # figure out the changes
        #
        old_record = old_changed_contact_records[xml_id]
        new_record = new_changed_contact_records[xml_id]
        assert old_record.keys() == new_record.keys(),\
                ('old/new keys mismatch\nold:%s\n%s\nnew:%s\n%s' %
                    ('|'.join(sorted(old_record.keys())), box(str(old_record)),
                     '|'.join(sorted(new_record.keys())), box(str(new_record))))
        # check for user-updated-address and specials
        user_updates = old_record.fis_updated_by_user or ''
        if 'A' in user_updates:
            # drop all the address fields
            del old_record.use_parent_address
            del old_record.street, old_record.street2
            del old_record.city, old_record.state_id, old_record.zip, old_record.country_id
            del new_record.use_parent_address
            del new_record.street, new_record.street2
            del new_record.city, new_record.state_id, new_record.zip, new_record.country_id
        if 'N' in user_updates:
            del old_record.name
            del new_record.name
        changes = AttrDict()
        for key in old_record:
            if old_record[key] != new_record[key]:
                changes[key] = new_record[key]
        if changes:
            relevant_changes = True
            changed_count += 1
            if LIST_RECORDS:
                echo('  F163:%s  %s' % (xml_id, new_record.name), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in changes.items()), '||', end='')
                echo()
            if not DRYRUN:
                res.partner.write(xml_id, new_record.id, changes)
    if not relevant_changes:
        print('...no relevant changes...')
    #
    # add new contacts
    #
    if added_contact_records:
        print('adding contact records', border='flag')
    for key, contact in added_contact_records.items():
        if not DRYRUN:
            # double-check that record doesn't already exist
            contact_id = res.partner.search(domain=[('xml_id','=',key),('module','=','F163')])
            if contact_id:
                [contact_id] = contact_id
                ids[key] = contact_id
                res.partner.error('FIS ID F163:%s (%s) already exists in OpenERP' % (key, contact.name))
                continue
        added_count += 1
        if LIST_RECORDS:
            echo('  F163:%s  %s' % (key, contact.name), end='  ')
            print('||', '||'.join('%s -> %r' % (k, v) for k, v in contact.items()), '||', end='')
            echo()
        if not DRYRUN:
            contact_id = res.partner.create(key, contact)
            if contact_id:
                contact.id = contact_id
                ids[key] = contact_id
    #
    # deleted/deactivate suppliers
    #
    if deleted_records:
        # toss any records that don't already exist in OpenERP
        for key, rec in sorted(deleted_records.items()):
            if key not in ids:
                deleted_records.pop(key)
            elif not all_oe_records[key].active:
                deleted_records.pop(key)
            elif LIST_RECORDS:
                echo('  F163:%s  %s' % (key, rec.name))
        deleted_count = len(deleted_records)
        if deleted_count:
            if not DELETE:
                print('deactivating records', border='flag')
            else:
                print('deleting records', border='flag')
            if not DRYRUN:
                ids = [ids[xml_id] for xml_id in deleted_records]
                if DELETE:
                    res.partner.delete(ids, context=context)
                else:
                    res.partner.write('...', ids, {'active': False}, context=context)
    #
    print('%d suppliers changed\n%d suppliers added\n%d suppliers %s'
            % (changed_count, added_count, deleted_count, ('deactivated','deleted')[DELETE]),
            border='box',
            )


def convert_nvty_rec(fis_rec):
    # some fields come from non-FIS locations or are only update once per day -- those fields will not
    # be evaluated here:
    # - name -> get_product_descriptions()
    # - fis_qty: _produced, _consumed, _purchased, _sold, _available
    # - fis_10_day: _produced, _consumed, _purchased, _sold, _available
    # - fis_21_day: _produced, _cosnumed, _purchased, _sold, _available

    item = AttrDict()
    item.xml_id =  fis_rec[F135.item_id]
    item.module = 'F135'
    item.active = True
    item.fis_available_id = product_available_at.get(fis_rec[F135.available_key], False)
    item.sale_ok = # ... something here mapping available status from fis_available_id
    item.categ_id = # ... something here mapping to category using fis_rec[F135.catalog_location]
    item.list_price = fis_rec[F135.new_wholesale
    item.trademarks = fis_rec[F135.trademarked]
    item.ean13 = sanitize_ean13(fis_rec[F135.upc_no])
    item.fis_location = fis_rec[F135.primary_location]
    #
    shipping_size = fis_nvty_rec[F135.ship_size].strip()
    if shipping_size.lower() in ('each','1 each','1/each'):
        shipping_size = '1 each'
    elif shipping_size:
        first, last = [], []
        letters = False
        for char in shipping_size:
            if letters or char.isalpha():
                last.append(char)
                letters = True
            else:
                first.append(char)
        if last == 'z':
            last = 'oz'
        shipping_size = ('%s %s' % (''.join(first).strip(), ''.join(last).strip())).strip()
    item.fis_shipping_size = shipping_size
    #
    shelf_life = float(fis_nvty_rec[F135.shelf_life_mos] or 0.0)
    if not shelf_life and sales_category_rec:
        # item.categ_id
        shelf_life = float(sales_category_rec[F11.shelf_life] or 0.0) # FIXME
    item.warranty = shelf_life
    #



    return item

def convert_product_category_rec(fis_rec):
    assert SALEABLE_CATEGORY_ID is not None, "SALEABLE_CATEGORY_ID has not been set"
    category = AttrDict()
    category.xml_id = key = fis_rec[F11.sales_category_id].strip()
    category.module = 'F11'
    name = re.sub('sunridge', 'SunRidge', fis_rec[F11.desc].title(), flags=re.I)
    if len(key) == 1:
        name = key + ' - ' + name.strip('- ')
        category.parent_id = SALEABLE_CATEGORY_ID
    else:
        parent_key = key[0]
        category.parent_id = category_ids.get(parent_key, parent_key)
    category.name = name
    if not category.parent_id:
        raw_input('problems!!')
    return category

def convert_product_location_rec(fis_rec):
    location = AttrDict()
    location.xml_id = fis_rec[F97.availability_id].strip()
    location.module = 'F97'
    location.name = re.sub('sunridge', 'SunRidge', fis_rec[F97.desc].title(), flags=re.I)
    avail= fis_rec[F97.availability].upper()
    if avail not in 'YN':
        avail = False
    location.availability = avail
    return location


def convert_emp1_rec(fis_rec):
    employee = AttrDict()
    employee.name = re.sub('sunridge', 'SunRidge', NameCase(fis_rec[F74.name]), flags=re.I)
    employee.xml_id = employee.identification_id = emp_num = fis_rec[F74.emp_num].strip()
    employee.module = 'F74-emp'
    try:
        if int(emp_num) >= 9000:
            return None
    except (ValueError, TypeError):
        return None
    employee.employment_type = 'standard'
    employee.update(process_address(F74, fis_rec, key=fis_rec[F74.emp_num], module='emp1', home=True))
    employee.home_phone = fix_phone(fis_rec[F74.tele])
    ssn = fis_rec[F74.ssn]
    if len(ssn) == 9:
        ssn = '%s-%s-%s' % (ssn[:3], ssn[3:5], ssn[5:])
    employee.ssnid = ssn
    hired = fix_date(fis_rec[F74.date_hired])
    employee.hire_date = hired and hired.strftime('%Y-%m-%d') or False
    fired = fix_date(fis_rec[F74.date_terminated])
    employee.fire_date = fired and fired.strftime('%Y-%m-%d') or False
    employee.active = (not fired or hired > fired)
    # emp_birthday = fix_date(fis_rec[F74.birth_date])
    # employee.birthday = emp_birthday and emp_birthday.strftime('%Y-%m-%d') or False
    employee.status_flag = fis_rec[F74.status_flag]
    employee.pension_plan = fis_rec[F74.pension_status].upper() == 'Y'
    employee.pay_type = ('salary', 'hourly')[fis_rec[F74.pay_type].upper() == 'H']
    employee.hourly_rate = fis_rec[F74.hourly_rate]
    last_raise = fix_date(fis_rec[F74.last_raise])
    employee.last_raise = last_raise and last_raise.strftime('%Y-%m-%d') or False
    employee.marital = ('single', 'married')[fis_rec[F74.marital_status].upper() == 'M']
    employee.gender = ('male', 'female')[fis_rec[F74.gender].upper() == 'F']
    employee.emergency_contact = NameCase(fis_rec[F74.emergency_contact])
    employee.emergency_number = fix_phone(fis_rec[F74.emergency_phone])
    employee.federal_exemptions = int(fis_rec[F74.exempt_fed] or 0)
    employee.state_exemptions = int(fis_rec[F74.exempt_state] or 0)
    return employee

def convert_carrier_rec(fis_rec):
    company = AttrDict()
    company.name = re.sub('sunridge', 'SunRidge', BsnsCase(fis_rec[F27.name]), flags=re.I)
    company.xml_id = key = fis_rec[F27.code].strip()
    company.module = 'F27'
    company.is_company = True
    company.is_carrier = True
    company.use_parent_address = False
    if key == '99':
        company.name = '____________'
    company.update(process_address(F27, fis_rec, key=key, module='cnvzsv'))
    company.phone = fis_rec[F27.tele]
    company.fuel_surcharge = fis_rec[F27.fuel_surcharge].upper() == 'Y'
    return company

def convert_customer_terms_rec(fis_rec):
    terms = AttrDict()
    terms.xml_id = fis_rec[F8.code]
    terms.module = 'F8'
    terms.description = ' / '.join([t.strip() for t in fis_rec[F8.description].split('/')])
    return terms

def convert_csms_rec(model, fis_rec, aging=None):
    #
    # creates an AttrDict with the following fields
    # - 'module', 'xml_id',
    # - 'name', 'street', 'street2', 'city', 'state_id', 'zip', 'country_id',
    # - 'fis_valid', 'specials_notification', 'phone', 'is_company', 'customer',
    # - 'use_parent_address', 'active'
    #
    # fields coming from OpenERP that are missing/invalid on the FIS side
    # - 'id', 'fis_updated_by_user'
    # - address fields (for contact)
    #
    # fis records use the following fields to detect changes
    #
    # enum_schema=[
    #     F33.name, F33.salesrep, F33.catalog_category, F33.this_year_sales,
    #     F33.last_year_sales, F33.tele, F33.contact,
    #     ],
    # address_fields=[
    #     F33.addr1, F33.addr2, F33.addr3,
    #     ],
    #
    company = AttrDict()
    # TODO: get salesrep working
    # rep = cus_rec[F33.salesrep]
    # rep = sales_people.get(rep, False)
    company.module = 'F33'
    company.xml_id = key = fis_rec[F33.code]
    company.name = re.sub('sunridge', 'SunRidge', BsnsCase(fis_rec[F33.name]), flags=re.I)
    company.is_company = True
    company.customer = True
    company.use_parent_address = False
    # valid customer code? active account?
    company.fis_valid = len(key) == 5
    company.active = False
    if (
            fis_rec[F33.this_year_sales]
         or fis_rec[F33.last_year_sales]
        ):
        company.active = True
    else:
        # TODO check for open orders
        pass
    notify_by = Specials.get_member(fis_rec[F33.catalog_category].upper(), Specials.neither)
    company.specials_notification = notify_by.value
    company.update(process_address(F33, fis_rec, key=fis_rec[F33.code], module='csms'))
    company.phone = fix_phone(fis_rec[F33.tele])
    company.fis_csms_terms = customer_terms_recs.get(fis_rec[F33.payment_terms_id], False)
    company.fis_price_list = fis_rec[F33.price_list_id].upper() or False
    if not company.fis_csms_terms:
        model.error('Terms code %r does not exist' % (fis_rec[F33.payment_terms_id], ))
    if aging is not None and key in aging:
        account = aging[key]
        company.fis_credit_limit = account.limit
        company.fis_credit_current = account.current
        company.fis_credit_10_days = account.d10
        company.fis_credit_20_days = account.d20
        company.fis_credit_30_days = account.d30
        company.fis_credit_total = account.total
    else:
        company.fis_credit_limit = 0
        company.fis_credit_current = 0
        company.fis_credit_10_days = 0
        company.fis_credit_20_days = 0
        company.fis_credit_30_days = 0
        company.fis_credit_total = 0
    contact = None
    if fis_rec[F33.contact] and fis_rec[F33.contact] != fis_rec[F33.name]:
        contact = AttrDict()
        contact.name = NameCase(fis_rec[F33.contact])
        contact.xml_id = 'cntct_' + key
        contact.module = 'F33'
        contact.is_company = False
        contact.customer = True
        contact.use_parent_address = True
        contact.specials_notification = Specials.company
        contact.fis_valid = company.fis_valid
        contact.active = company.active
    return company, contact

def convert_supplier_rec(key):
    #
    # creates a company AttrDict with the following fields
    # - 'module', 'xml_id', 'active',
    # - 'name', 'street', 'street2', 'city', 'state_id', 'zip', 'country_id',
    # - 'fis_valid', 'phone', 'fax', 'is_company', 'customer', 'fis_org_cert_file',
    # - 'fis_non_gmo', 'fis_kosher', 'fis_org_exp', 'fis_gmo_exp', 'fis_kosher_exp',
    #
    # creates a contact AttrDict with the following fields
    # - 'module', 'xml_id', 'active', 'name', 'phone', 'fax',
    # - 'is_company', 'customer', 'supplier', 'fis_valid',
    #
    # fields coming from OpenERP that are missing/invalid on the FIS side
    # - 'id', 'fis_updated_by_user'
    # - address fields (for contact)
    #
    posm_rec = posm.get(key)
    vendor_codes.add(key)
    if posm_rec is not None:
        contact_key = posm_rec[F163.vendor]
        if contact_key:
            vendor_codes.add(contact_key)
            vnms_rec = vnms.get(contact_key)
        else:
            vnms_rec = None
    else:
        vnms_rec = vnms.get(key)
    company = AttrDict()
    company.module = 'F163'
    company.xml_id = key
    company.is_company = True
    company.customer = False
    company.supplier = True
    company.use_parent_address = False
    company.fis_valid = len(key) == 6 and key.isdigit()
    company.active = company.fis_valid
    if posm_rec is not None:
        company.name = re.sub('sunridge', 'SunRidge', BsnsCase(posm_rec[F163.name]), flags=re.I)
        company.update(process_address(F163, posm_rec, key=posm_rec[F163.code], module='posm'))
        company.phone = fix_phone(posm_rec[F163.tele]) or False
        company.fax = fix_phone(posm_rec[F163.fax]) or False
        company.fis_org_cert_file = posm_rec[F163.org_cert_file].upper() in 'YO'
        fis_org_exp = fix_date(posm_rec[F163.cert_exp])
        company.fis_org_exp = fis_org_exp and fis_org_exp.strftime('%Y-%m-%d') or False
        company.fis_non_gmo = posm_rec[F163.non_gmo].upper() in 'Y'
        company.fis_kosher = posm_rec[F163.kosher].upper() in 'Y'
        fis_gmo_exp = fix_date(posm_rec[F163.gmo_exp])
        company.fis_gmo_exp = fis_gmo_exp and fis_gmo_exp.strftime('%Y-%m-%d') or False
        fis_kosher_exp = fix_date(posm_rec[F163.kosher_exp])
        company.fis_kosher_exp = fis_kosher_exp and fis_kosher_exp.strftime('%Y-%m-%d') or False
    elif vnms_rec is not None:
        company.name = re.sub('sunridge', 'SunRidge', BsnsCase(vnms_rec[F65.name]), flags=re.I)
        company.update(process_address(F65, vnms_rec, key=vnms_rec[F65.code], module='posm'))
        company.phone = fix_phone(vnms_rec[F65.tele]) or False
        company.fax = fix_phone(vnms_rec[F65.fax]) or False
        company.fis_org_cert_file = vnms_rec[F65.org_cert_file].upper() in 'YO'
        fis_org_exp = fix_date(vnms_rec[F65.cert_exp])
        company.fis_org_exp = fis_org_exp and fis_org_exp.strftime('%Y-%m-%d') or False
        company.fis_non_gmo = False
        company.fis_kosher = False
        company.fis_gmo_exp = False
        company.fis_kosher_exp = False
    else:
        assert False, "invalid xml_id: %r" % (key, )
    #
    contact = None
    if vnms_rec is not None and vnms_rec[F65.contact]:
        name = NameCase(vnms_rec[F65.contact])
        contact = AttrDict()
        contact.module = 'F163'
        contact.xml_id = 'cntct_' + key
        contact.active = company.active
        contact.name = name
        contact.fis_valid = company.fis_valid
        contact.is_company = False
        contact.customer = False
        contact.supplier = True
        contact.use_parent_address = True
        contact.phone = fix_phone(vnms_rec[F65.tele]) or False
        contact.fax = fix_phone(vnms_rec[F65.fax]) or False
    if contact is not None:
        if not re.match('\w{2,}', name):
            contact.active = False
    if not company.name:
        company.active = False
    return company, contact

def get_customer_aging(aging_file):
    res = {}
    with open(aging_file) as af:
        lines = [line for line in af.read().split('\n') if line.strip()]
    for line in lines:
        key, rest = line.split(None, 1)
        limit, salesrep, total, d0, d10, d20, d30 = line.rsplit(None, 8)[-7:]
        res[key] = CustomerAging(key, limit, d0, d10, d20, d30, total)
    return res

def get_product_descriptions():
    res = {}
    job = Execute(
            'sudo ssh %(host)s cat %(file)s' % {
                'host': config.openerp.full_description_host,
                'file': config.openerp.full_description_path,
                },
            pty=True,
            password=config.openerp.pw,
            )
    text = job.stdout.split('\n')
    for line in text:
        match = re.match('(.{40})  \((\d{6})\)  (.*)$', line)
        if match is None:
            continue
        fis_desc, item_code, full_desc = match.groups()
        res[item_code] = full_desc
    return res

_raise_lookup = object()
class Specials(str, Enum):
    _order_ = 'neither catalog specials both default'
    neither   = 'N'
    catalog   = 'C'
    specials  = 'S'
    both      = 'B'
    default   = 'D'
    company   = default
    @classmethod
    def get_member(cls, text, default=_raise_lookup):
        for member in cls:
            if member.value == text:
                return member
        else:
            if default is not _raise_lookup:
                return default
        raise LookupError('%r not found in %s' % (text, cls.__name__))

def pfm(values):
    "prepare values dict for marshalling"
    result = {}
    for k, v in values.items():
        if v is None:
            result[k] = False
        elif isinstance(v, Date):
            result[k] = v.strftime(DEFAULT_SERVER_DATE_FORMAT)
        elif isinstance(v, Many2One):
            result[k] = v.id
        elif isinstance(v, PostalCode):
            result[k] = v.code
        elif isinstance(v, Enum):
            result[k] = v.value
        else:
            result[k] = v
    return result

def process_address(schema, fis_rec, key=None, module=None, home=False):
    if module is not None and key is None:
        raise ValueError('module specified but key was not')
    result = {}
    addr1, addr2, addr3 = Sift(fis_rec[schema.addr1], fis_rec[schema.addr2], fis_rec[schema.addr3])
    addr2, city, state, postal, country = cszk(addr2, addr3)
    addr3 = ''
    addr1 = normalize_address(addr1)
    addr2 = normalize_address(addr2)
    addr1, addr2 = AddrCase(Rise(addr1, addr2))
    city = NameCase(city)
    state, country = NameCase(state), NameCase(country)
    valid_address = True
    if (
            not (addr1 or addr2)
            or not (city or state or country)
        ):
        # just use the FIS data without processing
        addr1, addr2, city = Rise(fis_rec[schema.addr1], fis_rec[schema.addr2], fis_rec[schema.addr3])
        state = country = ''
        postal = PostalCode('', '')
        valid_address = False
    if home:
        sf = 'home_street'
        s2f = 'home_street2'
        cf = 'home_city'
        sidf = 'home_state_id'
        zf = 'home_zip'
        kidf = 'home_country_id'
    else:
        sf = 'street'
        s2f = 'street2'
        cf = 'city'
        sidf = 'state_id'
        zf = 'zip'
        kidf = 'country_id'
    result[sf] = addr1
    result[s2f] = addr2
    result[cf] = city
    result[zf] = postal
    result[sidf] = False
    result[kidf] = False
    if valid_address:
        if state:
            result[sidf] = state_recs[state][0]
            result[kidf] = country = state_recs[state][2]
        elif country:
            country_id = country_recs.get(country, False)
            if country_id is False:
                if module is not None:
                    Model.errors[module].append("%s record %s has invalid country <%r>" % (module, key, country))
            else:
                result[kidf] = country_id
    return result

def is_invalid_posm_record(rec):
    if rec is None:
        return True
    xml_id = rec[F163.code]
    name = rec[F163.name]
    vendor_xml_id = rec[F163.vendor]
    vendor_rec = vnms.get(vendor_xml_id)
    if (
            len(xml_id) == 6
            and xml_id.isdigit()
            and name
            and len(vendor_xml_id) == 6
            and vendor_xml_id.isdigit()
            and vendor_rec is not None
        ):
        # valid record, record vendor mapping
        ven2sup[vendor_xml_id] = xml_id
        return False
    # invalid record
    return True

def is_contact(obj):
    "obj must be either a string or have an xml_id key"
    if not isinstance(obj, basestring):
        obj = obj.get('xml_id')
    return obj.startswith('cntct_')

def combine_by_value(key, records):
    # records with field changes in addr1, addr2, addr3, and postal cannot be combined
    print 'combine by value key: ', key
    changed_map = defaultdict(list)
    for old_rec, new_rec, diffs in records:
        rec_key = []
        for fis_field, old_value, new_value in diffs:
            if fis_field in key:
                rec_key.append(fis_field)
                rec_key.append(new_value)
        if rec_key:
            changed_map[tuple(rec_key)].append(new_rec)
    return changed_map

def sanitize_ean13(ean13):
    """
    Creates and returns a valid ean13 from an invalid one
    """
    if not ean13:
        return "0000000000000"
    ean13 = re.sub("[A-Za-z]", "0", ean13);
    ean13 = re.sub("[^0-9]", "", ean13);
    ean13 = ean13[:13]
    if len(ean13) < 13:
        ean13 = ean13 + '0' * (13-len(ean13))
    return ean13[:-1] + str(ean_checksum(ean13))

def ean_checksum(eancode):
    """
    returns the checksum of an ean string of length 13, returns -1 if the string has the wrong length
    """
    if len(eancode) <> 13:
        return -1
    oddsum=0
    evensum=0
    total=0
    eanvalue=eancode
    reversevalue = eanvalue[::-1]
    finalean=reversevalue[1:]
    for i in range(len(finalean)):
        if i % 2 == 0:
            oddsum += int(finalean[i])
        else:
            evensum += int(finalean[i])
    total=(oddsum * 3) + evensum
    check = int(10 - math.ceil(total % 10.0)) % 10
    return check

class Model(object):

    models = []
    errors = defaultdict(list)

    def __init__(self, table, abbr, module, context):
        self.models.append(self)
        self.table = table
        self.abbr = abbr
        self.module = module
        self.context = context

    def __getattr__(self, name):
        return getattr(self.table, name)

    def error(self, msg):
        self.errors[self.abbr].append(msg)

    def create(self, key, values, context=None):
        if context is None:
            context = self.context
        try:
            return self.table.create(pfm(values), context=context)
        except:
            cls, exc, tb = sys.exc_info()
            self.errors[self.abbr].append('FIS ID %s:%s create caused exception %r' % (self.module, key, exc))
            # error(''.join(format_exception(cls, exc, tb)))
            return False

    def delete(self, ids, context=None):
        if context is None:
            context = self.context
        try:
            return self.table.unlink(ids)
        except:
            cls, exc, tb = sys.exc_info()
            self.errors[self.abbr].append('%s: deleting ID(s) %s caused exception %r' % (self.module, ', '.join([str(n) for n in ids]), exc))
            # error(''.join(format_exception(cls, exc, tb)))
            return False

    def read(self, **kwds):
        if 'context' not in kwds:
            kwds['context'] = self.context
        return get_records(self.table, **kwds)

    def search(self, domain, context=None):
        if context is None:
            context = self.context
        return self.table.search(domain, context=context)

    def write(self, key, ids, values, context=None):
        if context is None:
            context = self.context
        try:
            print('writing to %s using %s\n and %s' % (ids, pfm(values), context), border='box', verbose=2)
            print(str(self.table.write(ids, pfm(values), context=context)), border='box', verbose=2)
            return True
        except:
            cls, exc, tb = sys.exc_info()
            self.errors[self.abbr].append('FIS ID %s:%s write caused exception %r' % (self.module, key, exc))
            # error(format_exception(cls, exc, tb))
            return False


class CustomerAging(NamedTuple):
    _order_ = "xml_id limit current d10 d20 d30 total"
    xml_id = 'customer key'
    limit = 'credit limit'
    current = 'charges within 10 days'
    d10 = 'charges between 11 and 20 days old'
    d20 = 'charges between 21 and 30 days old'
    d30 = 'charges over 30 days old'
    total = 'total outstanding balance'

    def __new__(cls, *values):
        new_values = [values[0]]
        for value in values[1:]:
            value = value.replace(',','')
            if value[-1:] == '-':
                value = '-' + value[:-1]
            new_values.append(float(value))
        return NamedTuple.__new__(CustomerAging, *new_values)

# old code
# def handle_sales_reps():
#     context = {'fis-updates': True}
#     res = AttrDict()
#     res.partner = oe.get_model('res.partner')
#     cnvzz = fisData(47)
#     if method == 'quick':
#         cnvz_old = fisData(47, data_path=config.network.fis_data_local_old_path)
#     failed_match = set()
#     def is_invalid_cnvz(sales_rec):
#         sales_id = rec[F47.salesperson_id].upper()
#         sales_name = rec[F47.salesperson_name]
#         company_id = rec[F47.company_id]
#         if company_id != '10':
#             return True
#         if '-' in sales_name:
#             sales_name, extra = sales_name.split('-')
#             if not extra.strip().isdigit() and sales_id != 'BAD':
#                 return True
#         return False
#     #
#     # saving below for later
#     #
#         sales_full_name = sales_name.lower()
#         names = sales_full_name.split()
#         if len(names) > 1:
#             sales_name = ' '.join([names[0], names[-1]])
#         else:
#             sales_name = sales_name.lower()
#         if sales_name in failed_match:
#             # this name already failed to match
#             continue
#         if var(potential_sales_people.get(sales_name)) is not None and len(var()) == 1:
#             # full-name match
#             sales_people[sales_id] = var()[0]
#         # elif len(names) == 1:
#         #     # if it didn't match before, it's not going to match now
#         #     pass
#         #     # potential_sales_people[sales_id] = None
#         #     # failed_match.add(sales_name)
#         elif var(potential_sales_people.get(names[-1])) and len(var()) == 1:
#             # last name match
#             sales_people[sales_id] = var()[0]
#         elif var(potential_sales_people.get(names[0])) and len(var()) == 1:
#             # first name match
#             sales_people[sales_id] = var()[0]
#         else:
#             # no match at all
#             # look for user matches and previously created dummy user accounts
#             all_users = res_users.browse(cr, uid, context=inactive_too)
#             all_users.sort(key=lambda r: not r.active)
#             if len(names) > 1:
#                 # try to match sales name with beginning of user name
#                 # e.g. "billy bob" with "billy bob joe"
#                 user = [u for u in all_users if u.name.lower().startswith(sales_name)]
#                 if user:
#                     if len(user) == 1:
#                         sales_people[sales_id] = user[0].id
#                         continue
#                     else:
#                         _logger.warning('unable to match %s (%s): too many possibles', sales_name, sales_id)
#                         failed_match.add(sales_name)
#                         continue
#
#                 login = names[0][0] + names[1]
#             else:
#                 login = names[0]
#             # try to match against login
#             # e.g. "billy bob" with "bbob"
#             for user in all_users:
#                 if login == user.login:
#                     sales_people[sales_id] = user.id
#                     break
#             else:
#                 # if we make it this far, no matches -- so let's create a new (inactive)
#                 # user so we can properly categorize customers
#                 _logger.warning('unable to match %s: creating dummy user', sales_name)
#                 id = res_users.create(
#                         cr, uid,
#                         {
#                             'name': NameCase(sales_name),
#                             'login': login,
#                             'active': False,
#                             'tz': 'America/Los_Angeles',
#                             },
#                         context=context)
#                 sales_people[sales_id] = id
#                 all_users.append(res_users.browse(cr, uid, id, context=inactive_too))
#             # continue
#             # failed_match.add(sales_name)

# main
Main()
