#!/usr/local/sbin/suid-python --virtualenv

# imports
from __future__ import print_function

from scription import *
from aenum import Enum, NamedTuple
from antipathy import Path
from collections import defaultdict
from dbf import Date
from fis_schema import F8, F11, F27, F33, F34, F47, F65, F74, F97, F135, F163, F192, F262, F341
from logging import INFO, getLogger, Formatter, handlers
from openerplib import AttrDict, get_connection, get_records, IDEquality, PropertyNames, SetOnce, Many2One
    # from traceback import format_exception
from pandaemonium import PidLockFile
from tools import close_enough, combine_by_value, Model, compare_fis_records as get_changed_fis_records
from tools import ProductLabelDescription
from VSS.address import cszk, normalize_address, Rise, Sift, AddrCase, NameCase, BsnsCase, NameCaseReversed, PostalCode
from VSS.BBxXlate.fisData import fisData
from VSS.utils import fix_phone, fix_date
from warnings import warn
import errno
import math
import re
import os
import socket
import traceback

virtualenv = os.environ['VIRTUAL_ENV']
logger = getLogger()
logger.setLevel(INFO)
_handler = handlers.TimedRotatingFileHandler(
        '%s/var/log/openerp/continuous_sync_records.log' % virtualenv,
        when='midnight',
        backupCount=30,
        )
_formatter = Formatter('%(asctime)s %(funcName)-25s %(message)s')
_handler.setFormatter(_formatter)
logger.addHandler(_handler)
del _handler, _formatter

C = Color
grey = C.Dim | C.FG_White
white = C.Normal | C.FG_White
same = C.Normal | C.FG_White
oldv = C.Normal | C.FG_Red
newv = C.Normal | C.FG_Green

ONE_YEAR_AGO = Date.today().replace(delta_year=-1)

SALEABLE_CATEGORY_XMLID = 'product_category_1'
SALEABLE_CATEGORY_ID = None
ETC_CATEGORY_ID = None

# TODO: implement EXTRA handling for
#       - EMP1
#       - POSM/VNMS
#       - CSMS
#       - NVTY          --> done
#       - CNVZd0
#       - CNVZz
#       - CNVZsv
#       - CNVZas
#       - CNVZaa

# API
@Script(
        dryrun=Spec('do not make changes, only show what changes would be made', FLAG),
        list_records=Spec('list added/changed records', FLAG),
        raise_on_exception=Spec('do not ignore exceptions', FLAG, abbrev=('r', 'raise')),
        )
def main(dryrun, list_records, raise_on_exception):
    global config, oe, errors, DRYRUN, LIST_RECORDS, RAISE_ON_EXCEPTION, VIEW_TYPE, BORDER, script_verbosity
    DRYRUN = LIST_RECORDS = False
    config = OrmFile('%s/config/fnx.ini' % virtualenv, types={'_path': Path})
    oe = config.openerp
    oe = get_connection(hostname=oe.host, database=oe.db, login=oe.user, password=oe.pw)
    errors = defaultdict(list)
    if dryrun:
        DRYRUN = True
        if not script_verbosity:
            script_verbosity = 1
    LIST_RECORDS = list_records
    RAISE_ON_EXCEPTION = raise_on_exception
    VIEW_TYPE = 'none' if LIST_RECORDS else 'percent'
    BORDER = 'box' if LIST_RECORDS and script_verbosity > 1 else None
    global logger
    logger = getLogger('orders')

@Command(
        files=Spec('changed FIS files', type=lambda f: f.lower()),
        method=Spec(
            'perform quick or full comparison [quick: compare against old FIS files;'
            ' full: compare against OpenERP records',
            OPTION,
            choices=['quick', 'full'],
            type=lambda m: m.lower(),
            ),
        delete=Spec('delete records [default: send email]', FLAG,),
        extra=Spec('misc key-value pairs', OPTION),
        )
def fis_integration(method, delete, *files, **extra):
    global state_recs, country_recs, customer_terms_recs
    global skipped_suppliers, vendor_suppliers, ven2sup, vendor_codes
    global models, DELETE, EXTRA
    DELETE = delete
    EXTRA = extra
    try:
        # make sure we are the only one running
        with PidLockFile('/var/run/fis_update.pid'):
            ven2sup = {}
            state_recs = dict([
                (r.name, (r.id, r.code, r.country_id))
                for r in get_records(oe, 'res.country.state')
                ])
            country_recs = dict([
                (r.name, r.id)
                for r in get_records(oe, 'res.country')
                ])
            for name, rec_id in country_recs.items():
                country_recs[rec_id] = name
            customer_terms_recs = dict([
                (r.xml_id, r.id)
                for r in get_records(oe, 'fis.account.customer_terms')
                ])
            skipped_suppliers = set()
            vendor_suppliers = {}
            vendor_codes = set()
            if 'cnvz' in files:
                handle_carrier(method)
                handle_customer_terms()
                handle_product_category()
                handle_product_location()
                handle_sales_reps()
                handle_transmitter()
                handle_production_lines()
            if 'emp1' in files:
                handle_emp1(method)
            if 'posm' in files or 'vnms' in files:
                handle_supplier(method)
            if 'csms' in files:
                handle_csms(method)
                handle_csmss(method)
            if 'arci' in files:
                handle_arci(method)
            if 'nvty' in files:
                handle_nvty(method)
    except socket.error, s_error:
        if s_error.errno in (
                errno.ECONNREFUSED,
                errno.EHOSTDOWN,
            ):
            raise SystemExit(Exit.Unavailable)
        else:
            raise SystemExit(Exit.IoError)
    except Exception:
        traceback.print_exc()
        raise SystemExit(Exit.Software)
    finally:
        for m, problems in sorted(Model.errors.items()):
            error()
            error(m, border=('lined', '='), sep='')
            for p in problems:
                error('  ', p)
            error()

@Command()
def aging():
    aging_data = get_customer_aging('%s/customer_aging.txt' % config.network.fis_data_local_path)
    res_partner = oe.get_model('res.partner')
    customers = dict([
            (r.xml_id, r.id)
            for r in get_records(
                oe, 'res.partner',
                domain=[('customer','=',True),('xml_id','!=',False)],
                fields=['id','xml_id'],
                )])
    not_found = []
    for xml_id, aging in aging_data.items():
        try:
            id = customers[xml_id]
        except KeyError:
            not_found.append(xml_id)
            continue
        res_partner.write(
                id,
                {
                    'fis_credit_limit':   aging.limit,
                    'fis_credit_current': aging.current,
                    'fis_credit_10_days': aging.d10,
                    'fis_credit_20_days': aging.d20,
                    'fis_credit_30_days': aging.d30,
                    'fis_credit_total':   aging.total,
                    },
                )
    error('unable to find OpenERP records matching: %r' % ', '.join(not_found))

# helpers
#
# For those helpers that treat 'quick' and 'full' diferently, there are two ways to calculate changes
# in 'quick' mode after using get_changed_fis_records() to isolate the potential changes:
#
# - convert the new records into OpenERP records and retrieve the existing OpenERP
#   records for comparison
#
# - partially convert the records (in case a full conversion is too messy), then complete
#   the conversion later when it is determined the records are actually needed
#

def handle_arci(method):
    print('processing ARCI...')
    context = {'fis-updates': True, 'active_test': False}
    arci_mapping = Model(
            oe.get_model('fis_integration.customer_product_cross_reference'),
            'arci', 'F262',
            context,
            RAISE_ON_EXCEPTION,
            )
    all_oe_records = {}
    # these are for tracking old/new versions of changed records
    new_changed_records = {}
    old_changed_records = {}
    # these are for added/deleted records
    added_records = {}
    deleted_records = {}
    # the counts
    changed_count = 0
    added_count = 0
    deleted_count = 0
    #
    # get the "old" data from:
    # - quick -> old fis file
    # - full -> current OpenERP data
    #
    arci = fisData(262, rematch=r'10 HE447......')
    print(arci.filename, verbose=2)
    print('gathering data')
    if method == 'quick':
        #
        # for a quick compare we can use the fis records as-is when looking for changes
        #
        arci_old = fisData(262, rematch=r'10 HE447......', data_path=config.network.fis_data_local_old_path)
        print(arci_old.filename, verbose=2)
        print('collecting changed records')
        changes, added, deleted = get_changed_fis_records(
                arci_old.values(),
                arci.values(),
                enum_schema=[
                    F262.cust_no, F262.our_item_id, F262.cust_item_id,
                    ],
                address_fields=[],
                )
        #
        # we now have the subset of records that have changed, just need to separate them
        # into old and new
        #
        print('sorting %d changed records' % (len(changes), ))
        needed_partners = list()
        needed_products = list()
        for old, new, diffs in changes:
            old_cross_ref = convert_arci_rec(old)
            old_changed_records[old_cross_ref.key] = old_cross_ref
            new_cross_ref = convert_arci_rec(new)
            new_changed_records[new_cross_ref.key] = new_cross_ref
            # changes at the FIS level don't always translate to changes at the OpenERP level
            if old_cross_ref != new_cross_ref:
                old_changed_records[old_cross_ref.key] = old_cross_ref
                new_changed_records[new_cross_ref.key] = new_cross_ref
                if old_cross_ref.partner_id not in needed_partners:
                    needed_partners.append(old_cross_ref.partner_id)
                if new_cross_ref.partner_id not in needed_partners:
                    needed_partners.append(new_cross_ref.partner_id)
                if old_cross_ref.fis_product_id not in needed_products:
                    needed_products.append(old_cross_ref.fis_product_id)
                if new_cross_ref.fis_product_id not in needed_products:
                    needed_products.append(new_cross_ref.fis_product_id)
            assert set(old_changed_records.keys()) == set(new_changed_records.keys()),\
                    "old and new company records mismatch"
        print('sorting %d new and %d deleted records' % (len(added), len(deleted)))
        for fis_rec in added:
            new_cross_ref = convert_arci_rec(fis_rec)
            added_records[new_cross_ref.key] = new_cross_ref
            if new_cross_ref.partner_id not in needed_partners:
                needed_partners.add(new_cross_ref.partner_id)
            if new_cross_ref.fis_product_id not in needed_products:
                needed_products.append(new_cross_ref.fis_product_id)
        for fis_rec in deleted:
            old_cross_ref = convert_arci_rec(fis_rec)
            deleted_records[old_cross_ref.key] = old_cross_ref
        #
        # now get the necessary OpenERP records
        #
        print('retrieving OpenERP records')
        oe_products = dict([
            (r.xml_id, r.id)
            for r in get_records(
                oe, 'product.product',
                domain=[('xml_id','in',[p.xml_id for p in needed_products])],
                fields=['id','xml_id'],
                context=context,
                )])
        oe_partners = dict([
            (r.xml_id, r.id)
            for r in get_records(
                oe, 'res.partner',
                domain=[('xml_id','in',[p.xml_id for p in needed_partners])],
                fields=['id','xml_id'],
                context=context,
                )])
        record_keys = [
                r.key
                for r in
                    old_changed_records.keys() + new_changed_records.keys() + deleted_records.keys()
                    ]
        all_oe_records = dict([
                (r.key, r)
                for r in get_records(
                    oe, 'fis_integration.customer_product_cross_reference',
                    domain=[('key','in',record_keys)],
                    fields=[
                        'id','key','list_code','fis_code',
                        'partner_id','fis_product_id','customer_product_code',
                        'source',
                        ],
                    context=context,
                    )
                ])
        #
        # and update the product and partner attributes with the OpenERP ids,
        # and the main record with its OpenERP id
        #
        for partner in needed_partners:
            partner.id = oe_partners[partner.xml_id]
        for product in needed_products:
            product.id = oe_products[product.xml_id]
        for key, cross_ref in old_changed_records.items():
            cross_ref.id = all_oe_records[key].id
        for key, cross_ref in new_changed_records.items():
            cross_ref.id = all_oe_records[key].id
        for key, cross_ref in deleted_records.items():
            cross_ref.id = all_oe_records[key].id
    elif method == 'full':
        #
        # when doing a full compare, we have to convert every single fis record
        # before we can check for changes
        #
        all_fis_records = AttrDict()
        needed_partners = list()
        needed_products = list()
        invalid_partners = set()
        invalid_products = set()
        for fis_key, fis_rec in ProgressView(
                iterable=arci.items(),
                view_type='bar',
                message = 'converting $total FIS records',
            ):
            new_cross_ref = convert_arci_rec(fis_rec)
            if ' ' in new_cross_ref.partner_id.xml_id:
                invalid_partners.add(new_cross_ref.partner_id.xml_id)
                continue
            if new_cross_ref.partner_id not in needed_partners:
                needed_partners.append(new_cross_ref.partner_id)
            if new_cross_ref.fis_product_id not in needed_products:
                needed_products.append(new_cross_ref.fis_product_id)
            all_fis_records[new_cross_ref.key] = new_cross_ref
        #
        # now get the necessary OpenERP records for partner and product
        #
        print('retrieving OpenERP records')
        oe_products = dict([
            (r.xml_id, r.id)
            for r in get_records(
                oe, 'product.product',
                domain=[('xml_id','in',[p.xml_id for p in needed_products])],
                fields=['id','xml_id'],
                context=context,
                )])
        oe_partners = dict([
            (r.xml_id, r.id)
            for r in get_records(
                oe, 'res.partner',
                domain=[('xml_id','in',[p.xml_id for p in needed_partners])],
                fields=['id','xml_id'],
                context=context,
                )])
        #
        # retrieve the OpenERP records that match the ARCI module and are
        # maintained by FIS
        #
        all_oe_records = dict([
                (r.key, r)
                for r in get_records(
                    oe, 'fis_integration.customer_product_cross_reference',
                    domain=[('source','=','fis')],
                    fields=[
                        'id','key','list_code','fis_code',
                        'partner_id','fis_product_id','customer_product_code',
                        'source',
                        ],
                    context=context,
                    )
                ])
        #
        # and update the product and partner attributes with the OpenERP ids
        # and the main record with its OpenERP id
        #
        for partner in needed_partners:
            id = oe_partners.get(partner.xml_id)
            if id is None:
                invalid_partners.add(partner.xml_id)
                continue
            partner.id = id
        for product in needed_products:
            id = oe_products.get(product.xml_id)
            if id is None:
                invalid_products.add(product.xml_id)
                continue
            product.id = id
        for key, cross_ref in list(all_fis_records.items()):
            if not (cross_ref.partner_id and cross_ref.fis_product_id):
                print('removing', cross_ref.key, verbose=2)
                all_fis_records.pop(key)
                continue
            oe_rec = all_oe_records.get(key)
            if oe_rec is not None:
                cross_ref.id = oe_rec.id
        #
        # now we can separate into new, changed, and deleted buckets
        #
        print('sorting changed, new, and deleted customer product cross-reference records')
        all_keys = set(all_fis_records.keys() + all_oe_records.keys())
        for key in all_keys:
            old_rec = all_oe_records.get(key)
            new_rec = all_fis_records.get(key)
            print(old_rec, '---', new_rec, border='lined', sep='\n', verbose=3)
            if old_rec is new_rec is None:
                continue
            if old_rec is None:
                # only save if partner_id and fis_product_id are valid
                if new_rec.partner_id and new_rec.fis_product_id:
                    added_records[key] = new_rec
                continue
            if new_rec is None:
                # only save if partner_id and fis_product_id are valid
                if old_rec.partner_id and old_rec.fis_product_id:
                    deleted_records[key] = old_rec
                continue
            # only save if partner_id and fis_product_id are valid
            if new_rec == old_rec or not (
                    new_rec.partner_id and new_rec.fis_product_id
                    and old_rec.partner_id and old_rec.fis_product_id
                    and old_rec.customer_product_code
                ):
                continue
            #
            # we have changes, save the records for later comparison
            #
            old_changed_records[key] = old_rec
            new_changed_records[key] = new_rec
    else:
        abort('unknown METHOD: %r' % (method, ))
    #
    # at this point, all records are in AttrDict format, divided by deleted, added, and changed
    #
    # process changes
    #
    if old_changed_records:
        print('processing customer/product cross-reference changes', border='lined')
    assert set(old_changed_records.keys()) == set(new_changed_records.keys()),\
            "old/new customer/product cross-reference records mismatch"
    changed_key_ids = sorted(old_changed_records.keys())
    if changed_key_ids:
        for key_id in ProgressView(
                iterable=changed_key_ids,
                view_type='bar',
                message='modifying $total records',
            ):
            #
            # figure out the changes
            #
            old_record = old_changed_records[key_id]
            new_record = new_changed_records[key_id]
            assert set(old_record.keys()) == set(new_record.keys()),\
                    ('old/new keys mismatch\nold:%s\n%s\nnew:%s\n%s' %
                        ('|'.join(sorted(old_record.keys())), box(str(old_record)),
                         '|'.join(sorted(new_record.keys())), box(str(new_record))))
            assert 'id' in old_record, box('id field missing for %r' % (key_id, ))
            changes = get_updated_values(old_record, new_record)
            if changes:
                changed_count += 1
                logger.info(
                        'F262: changing -- %s  -->  %s',
                        key_id,
                        ', '.join("%s=%r" % (k, v) for k, v in changes.items())
                        )
                if LIST_RECORDS:
                    echo('  F262:%s  %s' % (key_id, new_record.key), end='  ')
                    print('||', '||'.join('%s -> %r' % (k, v) for k, v in changes.items()), '||', end='')
                    echo()
                if not DRYRUN:
                    arci_mapping.write(key_id, new_record.id, changes)
    #
    # now add new cross-reference mappings
    #
    if added_records:
        for key, cross_ref in ProgressView(
                iterable=added_records.items(),
                view_type='bar',
                message='adding $total records',
            ):
            if not DRYRUN:
                # double-check that record doesn't already exist
                cross_ref_id = arci_mapping.search(domain=[('key','=',key)])
                if cross_ref_id:
                    [cross_ref_id] = cross_ref_id
                    arci_mapping.error('FIS ID F262:%s (%s) already exists in OpenERP' % (key, cross_ref.key))
                    continue
            added_count += 1
            logger.info(
                    'F262:%s -- adding -- %s',
                    key,
                    (', '.join(['%s=%r' % (k, v) for k, v in cross_ref.items()]))
                    )
            if LIST_RECORDS:
                echo('  F262:%s  %s' % (key, cross_ref.key), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in cross_ref.items()), '||', end='')
                echo()
            if not DRYRUN:
                print('cross_ref: %r' % (cross_ref, ), verbose=3)
                cross_ref_id = arci_mapping.create(key, cross_ref)
                if not cross_ref_id:
                    added_count -= 1
                    warn('unable to create cross-reference for %r' % (cross_ref, ), UserWarning)
                    continue
                cross_ref.id = cross_ref_id
                all_oe_records[key] = cross_ref
    #
    # delete mappings
    #
    if deleted_records:
        # toss any records that don't already exist in OpenERP
        for key, rec in sorted(deleted_records.items()):
            all_oe_records.pop(key, None)
            if LIST_RECORDS:
                echo('  F262:%s  %s' % (rec.id, rec.key))
        delete_ids = [r.id for r in deleted_records.values()]
        deleted_count = len(delete_ids)
        if delete_ids:
            print('deleting records', border='flag')
            logger.info(
                    'F262 -- removing -- %s',
                    ', '.join(sorted(deleted_records.keys()))
                    )
            if not DRYRUN:
                arci_mapping.delete(delete_ids, context=context)
    #
    # update ir.model.data mappings
    #
    oe_records = dict(
            (r.id, r)
            for r in get_records(
                oe,
                'fis_integration.customer_product_cross_reference',
                domain=[('source','=','fis')],
                fields=['key'],
                ))
    update_ir_model_data(
            'fis_integration.customer_product_cross_reference',
            262,
            oe_records,
            )
    #
    print('%d mappings changed\n%d mappings added\n%d mappings %s'
            % (changed_count, added_count, deleted_count, 'deleted'),
            border='box',
            )

def handle_nvty(method):
    global product_available_at, product_sales_category, product
    print('processing NVTY', border=('flag', '#'))
    examine = EXTRA.get('NVTY')
    context = {'fis-updates': True, 'active_test': False}
    product = Model(oe.get_model('product.product'), 'nvty', 'F135', context, RAISE_ON_EXCEPTION)
    all_oe_records = {}
    # these are for tracking original old/new records
    new_item_records = {}
    old_item_records = {}
    # these  are for tracking old/new versions of changed records
    old_changed_item_records = {}
    new_changed_item_records = {}
    # these are for added/deleted records
    added_item_records = {}
    deleted_records = {}
    # the counts
    changed_count = 0
    added_count = 0
    deleted_count = 0
    # get dependent data
    product_available_at = dict([
        (r.xml_id, r)
        for r in get_records(
            oe,
            'product.available_at',
            fields=['id','xml_id','available'],
            context=context,
            )
        ])
    product_sales_category = dict([
        (r.xml_id, r)
        for r in get_records(
            oe,
            'product.category',
            fields=['id','xml_id','fis_shelf_life'],
            context=context,
            )
        ])
    #
    # get the "old" data from:
    # - quick -> old fis file
    # - full -> current OpenERP data
    #
    nvty = fisData(135, rematch=r"......101000    101\*\*")
    print(nvty.filename, verbose=2)
    print('gathering data')
    if method == 'quick':
        #
        # for a quick compare we can use the fis records as-is when looking for changes
        #
        nvty_old = fisData(135, rematch=r"......101000    101\*\*", data_path=config.network.fis_data_local_old_path)
        print(nvty_old.filename, verbose=2)
        print('collecting changed records')
        changes, added, deleted = get_changed_fis_records(
                nvty_old.values(),
                nvty.values(),
                enum_schema=[
                    F135.item_id,
                    F135.available_key, F135.sales_cat, F135.trademarkd,
                    F135.catalog_location, F135.desc, F135.size, F135.upc_no, F135.primary_location,
                    F135.supplier_id, F135.new_retail, F135.new_whlsl,
                    F135.net_un_wt, F135.grs_un_wt,
                    ],
                address_fields=[],
                )
        #
        # we now have the subset of records that have changed, now fetch the OpenERP records
        # to see if any meaningful changes
        #
        all_xml_ids = [t[0][F135.item_id] for t in changes]
        all_xml_ids.extend([f[F135.item_id] for f in added])
        all_xml_ids.extend([f[F135.item_id] for f in deleted])
        all_oe_records = dict([
            (r.xml_id, r)
            for r in product.read(
                domain=[('module','=','F135'),('xml_id','in',all_xml_ids)],
                fields=[
                    'id', 'module', 'xml_id', 'active', 'name', 'fis_name', 'fis_qty_on_hand',
                    'fis_availability_code', 'sale_ok', 'list_price', 'trademarks', 'ean13',
                    'fis_location', 'fis_shipping_size', 'categ_id', 'warranty',
                    'default_code', 'weight', 'weight_net', 'list_price',
                    ],
                )
            ])
        for old, new, diffs in ProgressView(
                iterable=changes,
                message='sorting changed records',
                view_type=VIEW_TYPE,
            ):
            xml_id = old[F135.item_id]
            old_item = all_oe_records[xml_id]
            old_item_records[xml_id] = old_item
            new_item = convert_nvty_rec(new)
            # normalize fields
            new_item.id = old_item.id
            new_item_records[new_item.xml_id] = new_item
            # changes at the FIS level don't always translate to changes at the OpenERP level
            if old_item != new_item:
                old_changed_item_records[old_item.xml_id] = old_item
                new_changed_item_records[new_item.xml_id] = new_item
            assert set(old_changed_item_records.keys()) == set(new_changed_item_records.keys()),\
                    "old and new item records mismatch"
        #
        # and convert the new and deleted records
        #
        for fis_rec in added:
            rec = convert_nvty_rec(fis_rec)
            rec.name = rec.fis_name
            added_item_records[rec.xml_id] = rec
        # XXX: disable for now in hopes of removing false inactive designations
        # for fis_rec in deleted:
        #     rec = convert_nvty_rec(fis_rec)
        #     deleted_records[rec.xml_id] = rec
    elif method == 'full':
        #
        # get the forecast and description data -- only used in "full"
        #
        print('getting forecast data')
        forecast_data = get_product_forecast()
        print('getting description data')
        description_data = get_product_descriptions()
        #
        # when doing a full compare, we have to convert every single fis record before we can
        # check for changes
        #
        all_fis_records = dict([
            (r.xml_id, r)
            for r in
                [convert_nvty_rec(f) for f in nvty.values()]
            ])
        if examine:
            echo(examine, all_fis_records.get(examine), sep='\n---\n', border='box')
        # and update with forecasts and descriptions
        for xml_id, rec in all_fis_records.items():
            #
            label_data = ProductLabelDescription(xml_id)
            rec.fis_web_ingredients = label_data.ingredients_text
            rec.fis_web_prep_instructions = label_data.recipe_text
            #
            desc = description_data.get(xml_id)
            rec.name = desc or rec.fis_name or False
            if rec.name is False:
                del rec.name
            #
            forecast = forecast_data.get(xml_id)
            if xml_id == examine:
                echo('forecast', forecast, sep='\n---\n', border='box')
            rec.fis_qty_produced = 0
            rec.fis_qty_consumed = 0
            rec.fis_qty_purchased = 0
            rec.fis_qty_sold = 0
            rec.fis_qty_available = 0
            rec.fis_10_day_produced = 0
            rec.fis_10_day_consumed = 0
            rec.fis_10_day_purchased = 0
            rec.fis_10_day_sold = 0
            rec.fis_10_day_available = 0
            rec.fis_21_day_produced = 0
            rec.fis_21_day_consumed = 0
            rec.fis_21_day_purchased = 0
            rec.fis_21_day_sold = 0
            rec.fis_21_day_available = 0
            if forecast is not None:
                # the first four of the above values do not change
                _, _10_day, _21_day = forecast
                rec.fis_qty_available = rec.fis_qty_on_hand
                rec.fis_10_day_produced = _10_day.produced
                rec.fis_10_day_consumed = _10_day.consumed
                rec.fis_10_day_purchased = _10_day.purchased
                rec.fis_10_day_sold = _10_day.sold
                rec.fis_10_day_available = rec.fis_qty_on_hand + sum(_10_day)
                rec.fis_21_day_produced = _21_day.produced
                rec.fis_21_day_consumed = _21_day.consumed
                rec.fis_21_day_purchased = _21_day.purchased
                rec.fis_21_day_sold = _21_day.sold
                rec.fis_21_day_available = rec.fis_qty_on_hand + sum(_21_day)
        #
        # retrieve the OpenERP records that match the NVTY module
        #
        print('retrieving OpenERP records')
        all_oe_records = dict([
                (r.xml_id, r)
                for r in get_records(
                    oe, 'product.product',
                    domain=[('module','=','F135')],
                    fields=[
                        'id', 'module', 'xml_id', 'active', 'name', 'fis_name', 'fis_qty_on_hand',
                        'fis_availability_code', 'sale_ok', 'list_price', 'trademarks', 'ean13',
                        'fis_location', 'fis_shipping_size', 'categ_id', 'warranty',
                        'fis_qty_produced', 'fis_10_day_produced', 'fis_21_day_produced',
                        'fis_qty_consumed', 'fis_10_day_consumed', 'fis_21_day_consumed',
                        'fis_qty_purchased', 'fis_10_day_purchased', 'fis_21_day_purchased',
                        'fis_qty_sold', 'fis_10_day_sold', 'fis_21_day_sold',
                        'fis_qty_available', 'fis_10_day_available', 'fis_21_day_available',
                        'default_code', 'weight', 'weight_net',
                        'fis_web_ingredients', 'fis_web_prep_instructions',
                        ],
                    context=context,
                    )
                ])
        if examine:
            echo(examine, all_oe_records.get(examine), sep='\n---\n', border='box')
        # print('sorting changed, new, and deleted product records')
        all_keys = set(all_fis_records.keys() + all_oe_records.keys())
        for key in ProgressView(
                iterable=sorted(all_keys),
                message='sorting product records',
                view_type=VIEW_TYPE,
            ):
            old_rec = all_oe_records.get(key)
            new_rec = all_fis_records.get(key)
            if old_rec is new_rec is None:
                continue
            if old_rec is None:
                added_item_records[key] = new_rec
                continue
            if new_rec is None:
                deleted_records[key] = old_rec
                continue
            # copy missing fields for proper equality testing
            new_rec.id = old_rec.id
            for field in old_rec.keys():
                if field not in new_rec:
                    new_rec[field] = old_rec[field]
                    product.error(
                            "%s: field %r missing from new record; using old value of %r"
                                % (key, field, old_rec[field])
                            )
            if old_rec == new_rec or close_enough(old_rec, new_rec):
                continue
            #
            # we have changes, save the records for later comparison
            #
            old_changed_item_records[key] = old_rec
            new_changed_item_records[key] = new_rec
            if key == examine:
                echo(key, old_rec, new_rec, sep='\n---\n', box='border')
        assert set(old_changed_item_records.keys()) == set(new_changed_item_records.keys()),\
                "old and new item records mismatch"
    else:
        abort('unknown METHOD: %r' % (method, ))
    #
    # at this point, all records are in AttrDict format, divided by deleted, added, and changed
    # new records are from FIS files, old records are from OpenERP
    #
    # add new products
    #
    for xml_id, item in ProgressView(
            iterable=sorted(added_item_records.items()),
            message='adding new records',
            view_type=VIEW_TYPE,
        ):
        name = item.fis_name
        if xml_id in all_oe_records:
            product.error('FIS ID F135:%s (%s) already exists in OpenERP' % (xml_id, name))
            continue
        added_count += 1
        logger.info(
                'F135:%s -- adding -- %s',
                xml_id,
                (', '.join(['%s=%r' % (k, v) for k, v in item.items()]))
                )
        if LIST_RECORDS:
            echo('  F135:%s  %s' % (item.xml_id, name), end='  ')
            print('||', '||'.join('%s -> %r' % (k, v) for k, v in item.items()), '||', end='')
            echo()
        if not DRYRUN:
            product_id = product.create(xml_id, item)
            if product_id:
                item.id = product_id
                all_oe_records[xml_id] = item
    #
    # process changes
    #
    changed_map = combine_by_value(old_changed_item_records, new_changed_item_records)
    echo('%d items' % len(old_changed_item_records))
    for changes, records in ProgressView(
            iterable=sorted(changed_map.items()),
            message='processing changed records',
            view_type=VIEW_TYPE,
        ):
        values = dict(changes)
        xml_ids = [r.xml_id for r in records]
        oe_ids = product.search([('module','=','F135'),('xml_id','in',xml_ids)])
        changed_count += len(oe_ids)
        logger.info(
                'F135: changing -- %s  -->  %s',
                xml_ids,
                ', '.join("%s=%r" % (k, v) for k, v in sorted(changes))
                )
        if LIST_RECORDS:
            body = []
            for rec in records:
                body.append(('  F135:%s  %s' % (rec.xml_id, rec.fis_name)))
            if script_verbosity > 1:
                body.append('---')
                body.append(str(AttrDict(changes)))
            echo('\n'.join(body), border='box' if script_verbosity > 1 else None)
        if examine in xml_ids:
            echo(
                    'changing %s to' % examine,
                    '\n'.join(['%s = %r' % (k, v) for k, v in sorted(values.items())]),
                    sep='\n---\n',
                    border='box',
                    )
        if not DRYRUN:
            product.write('|'.join(xml_ids), oe_ids, values, context={})
    #
    # deleted/deactivate products
    #
    if not DELETE:
        delete_message = 'deactivating old records'
    else:
        delete_message = 'deleting old records'
    for _ in ProgressView(
            iterable=(True, ),
            message=delete_message,
            view_type=VIEW_TYPE,
        ):
        # get the ids of actually existing records
        xml_ids = deleted_records.keys()
        if examine in xml_ids:
            echo('deleting', examine, border='box')
        if DELETE:
            ids = [rec.id for key, rec in all_oe_records.items() if key in xml_ids]
        else:
            ids = [rec.id for key, rec in all_oe_records.items() if key in xml_ids and rec.active]
        if ids:
            deleted_count = len(ids)
            if deleted_count:
                logger.info(
                        'F135 -- removing -- %s',
                        ', '.join(sorted(deleted_records.keys()))
                        )
                if LIST_RECORDS:
                    for xml_id, rec in sorted(deleted_records.items()):
                        echo('  F135:%s  %s' % (rec.xml_id, rec.fis_name))
                if not DRYRUN:
                    if DELETE:
                        product.delete(ids, context=context)
                    else:
                        product.write('...', ids, {'active': False})
    #
    # update ir.model.data mappings
    #
    oe_records = dict(
            (r.id, r.xml_id)
            for r in get_records(
                oe,
                'product.product',
                domain=[('module','=','F135')],
                fields=['xml_id'],
                ))
    update_ir_model_data('product.product', 135, oe_records)
    #
    print('%d products changed\n%d products added\n%d products %s'
            % (changed_count, added_count, deleted_count, ('deactivated','deleted')[DELETE]),
            border='box',
            )

def handle_csms(method):
    global sales_person_recs, transmitter_codes
    print('processing CSMS', border=('flag', '#'))
    context = {'fis-updates': True, 'active_test': False}
    res_partner = Model(oe.get_model('res.partner'), 'csms', 'F33', context, RAISE_ON_EXCEPTION)
    transmitter_codes = dict([
        ('%s-%s' % (r.partner_xml_id, r.ship_to_code or 'default'), r)
        for r in get_records(oe, 'fis.transmitter_code')
        ])
    # these are for tracking original old/new records
    new_company_records = {}
    new_contact_records = {}
    old_company_records = {}
    old_contact_records = {}
    # these are for tracking old/new versions of changed records
    old_changed_company_records = {}
    old_changed_contact_records = {}
    new_changed_company_records = {}
    new_changed_contact_records = {}
    # these are for added/deleted records
    added_company_records = {}
    added_contact_records = {}
    deleted_records = {}
    # and the counts
    changed_count = 0
    added_count = 0
    deleted_count = 0
    ids = {}
    #
    # get the "old" data from:
    # - quick -> old fis file
    # - full -> current OpenERP data
    #
    csms = fisData(33, rematch=r"10...... ")
    print(csms.filename, verbose=2)
    print('gathering data', border='flag')
    sales_person_recs = dict([
        (r.xml_id, r)
        for r in get_records(oe, 'fis.account.salesperson')
        ])
    if method == 'quick':
        #
        # for a quick compare we can use the fis records as-is
        #
        csms_old = fisData(33, rematch=r"10...... ", data_path=config.network.fis_data_local_old_path)
        print(csms_old.filename, verbose=2)
        print('collecting changed records')
        changes, added, deleted = get_changed_fis_records(
                csms_old.values(),
                csms.values(),
                enum_schema=[
                    F33.name, F33.salesrep, F33.catalog_category, F33.this_year_sales,
                    F33.last_year_sales, F33.tele, F33.contact,
                    ],
                address_fields=[
                    F33.addr1, F33.addr2, F33.addr3,
                    ],
                )
        #
        # we now have the subset of records that have changed, just need to separate them
        # into old and new
        #
        print('sorting changed records')
        for old, new, diffs in changes:
            old_company, old_contact = convert_csms_rec(res_partner, old)
            old_company_records[old_company.xml_id] = old_company
            new_company, new_contact = convert_csms_rec(res_partner, new)
            new_company_records[new_company.xml_id] = new_company
            # changes at the FIS level don't always translate to changes at the OpenERP level
            if old_company != new_company:
                old_changed_company_records[old_company.xml_id] = old_company
                new_changed_company_records[new_company.xml_id] = new_company
            # determine if contacts are added, deleted, or changed
            if old_contact is not None:
                old_contact_records[old_contact.xml_id] = old_contact
            if new_contact is not None:
                new_contact_records[new_contact.xml_id] = new_contact
            if old_contact == new_contact:
                pass
            elif old_contact is None:
                added_contact_records[new_contact.xml_id] = new_contact
            elif new_contact is None:
                deleted_records[old_contact.xml_id] = old_contact
            else:
                old_changed_contact_records[old_contact.xml_id] = old_contact
                new_changed_contact_records[new_contact.xml_id] = new_contact
            assert set(old_changed_company_records.keys()) == set(new_changed_company_records.keys()),\
                    "old and new company records mismatch"
            assert set(old_changed_contact_records.keys()) == set(new_changed_contact_records.keys()),\
                    "old and new contact records mismatch"
        #
        # and convert the new and deleted records
        #
        print('sorting new and deleted records')
        for fis_rec in added:
            company, contact = convert_csms_rec(res_partner, fis_rec)
            new_company_records[company.xml_id] = company
            added_company_records[company.xml_id] = company
            if contact is not None:
                new_contact_records[contact.xml_id] = contact
                added_contact_records[contact.xml_id] = contact
        for fis_rec in deleted:
            company, contact = convert_csms_rec(res_partner, fis_rec)
            old_company_records[company.xml_id] = company
            deleted_records[company.xml_id] = company
            if contact is not None:
                old_contact_records[contact.xml_id] = contact
                deleted_records[contact.xml_id] = contact
    elif method == 'full':
        #
        # get the aging data (kept in a different format) -- only used in "full"
        #
        print('getting aging data')
        aging_data = get_customer_aging('%s/customer_aging.txt' % config.network.fis_data_local_path)
        #
        # when doing a full compare, we have to convert every single fis record before we can
        # check for changes
        #
        all_fis_records = AttrDict()
        for fis_rec in csms.values():
            company, contact = convert_csms_rec(res_partner, fis_rec, aging_data)
            all_fis_records[company.xml_id] = company
            # process contact, if any
            if contact is not None:
                all_fis_records[contact.xml_id] = contact
        #
        # retrieve the OpenERP records that match the CSMS module, and divvy them up into company
        # and contact records
        #
        print('retrieving OpenERP records')
        all_oe_records = dict([
                (r.xml_id, r)
                for r in get_records(
                    oe, 'res.partner',
                    domain=[('module','=','F33')],
                    fields=[
                        'id', 'module', 'xml_id', 'fis_csms_terms', 'fis_price_list',
                        'name', 'street', 'street2', 'city', 'state_id', 'zip', 'country_id',
                        'fis_valid', 'specials_notification', 'phone', 'is_company', 'customer',
                        'fis_updated_by_user', 'active', 'use_parent_address', 'fis_credit_limit',
                        'fis_credit_10_days', 'fis_credit_20_days', 'fis_credit_30_days',
                        'fis_credit_current', 'fis_credit_total', 'user_id', 'fis_transmitter_id',
                        ],
                    context=context,
                    )
                ])
        print('sorting company and contact records')
        for xml_id, datom in all_oe_records.items():
            ids[xml_id] = datom.id
            if xml_id.startswith('cntct_'):
                # do not update address from here -- it's either the default of "use parent's"
                # or it's been changed by the user (same with specials_notification)
                del datom.use_parent_address
                del datom.phone, datom.street, datom.street2
                del datom.city, datom.state_id, datom.zip, datom.country_id
                del datom.specials_notification, datom.fis_csms_terms, datom.fis_credit_current,
                del datom.fis_price_list, datom.fis_credit_limit, datom.fis_credit_total
                del datom.fis_credit_10_days, datom.fis_credit_20_days, datom.fis_credit_30_days
                del datom.fis_transmitter_id
                old_contact_records[xml_id] = datom
            else:
                old_company_records[xml_id] = datom
        #
        # now we can separate into new, changed, and deleted buckets
        #
        print('sorting changed, new, and deleted company/contact records')
        all_keys = set(all_fis_records.keys() + old_company_records.keys() + old_contact_records.keys())
        for key in all_keys:
            old_rec = all_oe_records.get(key)
            new_rec = all_fis_records.get(key)
            if old_rec is new_rec is None:
                continue
            if old_rec is None:
                if is_contact(new_rec):
                    added_contact_records[key] = new_rec
                else:
                    added_company_records[key] = new_rec
                continue
            if new_rec is None:
                deleted_records[key] = old_rec
                continue
            # copy missing fields for proper equality testing
            new_rec.id = old_rec.id
            new_rec.fis_updated_by_user = old_rec.fis_updated_by_user
            if new_rec == old_rec:
                continue
            #
            # we have changes, save the records for later comparison
            #
            if key.startswith('cntct_'):
                # we don't use the "use_parent_address" nor "specials_notification" for changes
                del new_rec.use_parent_address, new_rec.specials_notification
                old_changed_contact_records[key] = old_rec
                new_changed_contact_records[key] = new_rec
            else:
                old_changed_company_records[key] = old_rec
                new_changed_company_records[key] = new_rec
        assert set(old_changed_company_records.keys()) == set(new_changed_company_records.keys()),\
                "old and new company records mismatch"
        assert set(old_changed_contact_records.keys()) == set(new_changed_contact_records.keys()),\
                "old and new contact records mismatch"
    else:
        abort('unknown METHOD: %r' % (method, ))
    #
    # at this point, all records are in AttrDict format, divided by company/contact
    # and deleted, added, changed
    #
    # process changes
    #
    if old_changed_company_records:
        print('processing company changes', border='flag')
    assert set(old_changed_company_records.keys()) == set(new_changed_company_records.keys()),\
            "old/new company records mismatch"
    changed_company_xml_ids = sorted(old_changed_company_records.keys())
    relevant_changes = False
    for xml_id in changed_company_xml_ids:
        #
        # TODO: check actual values in OpenERP and remove "changes" that are already set
        #
        # figure out the changes
        #
        old_record = old_changed_company_records[xml_id]
        new_record = new_changed_company_records[xml_id]
        list_record_name = new_record.name
        assert set(old_record.keys()) == set(new_record.keys()),\
                ('old/new keys mismatch\nold:%s\n%s\nnew:%s\n%s' %
                    ('|'.join(sorted(old_record.keys())), box(str(old_record)),
                     '|'.join(sorted(new_record.keys())), box(str(new_record))))
        if method == 'full':
            assert 'id' in old_record, box('id field missing for %r' % (xml_id, ))
            # check for user-updated-address and specials
            user_updates = old_record.fis_updated_by_user or ''
            if 'A' in user_updates:
                # drop all the address fields
                del old_record.use_parent_address
                del old_record.street, old_record.street2
                del old_record.city, old_record.state_id, old_record.zip, old_record.country_id
                del new_record.use_parent_address
                del new_record.street, new_record.street2
                del new_record.city, new_record.state_id, new_record.zip, new_record.country_id
            if 'S' in user_updates:
                del old_record.specials_notification
                del new_record.specials_notification
            if 'N' in user_updates:
                del old_record.name
                del new_record.name
        elif xml_id in ids:
            # maybe this xml_id has already been seen?
            new_record.id = old_record.id = ids[xml_id]
        else:
            # otherwise, we'll look it up when we check for changes against OpenERP
            pass
        changes = get_updated_values(old_record, new_record)
        #
        # if this is a "full" update, we already have ids, and the changes are accurate
        # otherwise, we need to get the ids, and see if the "changes" have already been
        # put in place on the OpenERP side, as well as checking for user-updates that
        # should not be overridden
        #
        if method == 'quick':
            fields_to_check = changes.keys() + ['fis_updated_by_user']
            matches = res_partner.read(
                    domain=[('xml_id','=',xml_id),('module','=','F33')],
                    fields=fields_to_check+['fis_updated_by_user'],
                    )
            if not matches:
                res_partner.error('changed company F33:%s not found in OpenERP' % xml_id)
            [match] = matches
            new_record.id = old_record.id = match.id
            ids[xml_id] = match.id
            for field in changes:
                if match[field] == changes[field]:
                    del changes[field]
            user_updates = match.fis_updated_by_user or ''
            if 'N' in user_updates:
                changes.pop('name', None)
            if 'S' in user_updates:
                changes.pop('specials_notification', None)
            if 'A' in user_updates:
                for f in ('street', 'street2', 'city', 'state_id', 'zip', 'country_id'):
                    changes.pop(f, None)
        # quick and full from here
        if changes:
            relevant_changes = True
            changed_count += 1
            if LIST_RECORDS:
                echo('  F33:%s  %s' % (xml_id, list_record_name), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in changes.items()), '||', end='')
                echo()
            if not DRYRUN:
                res_partner.write(xml_id, new_record.id, changes)
    if not relevant_changes:
        print('...no relevant changes...')
    if old_changed_contact_records:
        print('processing contact changes', border='flag')
    assert set(old_changed_contact_records.keys()) == set(new_changed_contact_records.keys()),\
            "old/new contact records mismatch"
    changed_contact_xml_ids = sorted(old_changed_contact_records.keys())
    relevant_changes = False
    for xml_id in changed_contact_xml_ids:
        #
        # TODO: check actual values in OpenERP and remove "changes" that are already set
        #
        # figure out the changes
        #
        old_record = old_changed_contact_records[xml_id]
        new_record = new_changed_contact_records[xml_id]
        list_record_name = new_record.name
        assert set(old_record.keys()) == set(new_record.keys()),\
                ('old/new keys mismatch\nold:%s\n%s\nnew:%s\n%s' %
                    ('|'.join(sorted(old_record.keys())), box(str(old_record)),
                     '|'.join(sorted(new_record.keys())), box(str(new_record))))
        if 'id' in old_record:
            # old record is OpenERP's so it has the ID field already
            new_record.id = old_record.id
        elif xml_id in ids:
            # maybe this xml_id has already been seen?
            new_record.id = old_record.id = ids[xml_id]
        else:
            # otherwise, we'll look it up when we check for changes against OpenERP
            pass
        changes = get_updated_values(old_record, new_record)
        #
        # if this is a "full" update, we already have ids, and the changes are accurate
        # otherwise, we need to get the ids, and see if the "changes" have already been
        #   put in place on the OpenERP side
        #
        if method == 'quick':
            fields_to_check = changes.keys()
            matches = res_partner.read(
                    domain=[('xml_id','=',xml_id),('module','=','F33')],
                    fields=fields_to_check+['fis_updated_by_user'],
                    )
            if not matches:
                res_partner.error('changed contact F33:%s not found in OpenERP' % xml_id)
            [match] = matches
            new_record.id = old_record.id = match.id
            for field in changes:
                if match[field] == changes[field]:
                    del changes[field]
            user_updates = match.fis_updated_by_user or ''
            if 'N' in user_updates:
                changes.pop('name', None)
            if 'S' in user_updates:
                changes.pop('specials_notification', None)
            if 'A' in user_updates:
                for f in ('street', 'street2', 'city', 'state_id', 'zip', 'country_id'):
                    changes.pop(f, None)
        # quick and full from here
        if changes:
            relevant_changes = True
            changed_count += 1
            logger.info(
                    'F33: changing -- %s  -->  %s',
                    xml_id,
                    ', '.join("%s=%r" % (k, v) for k, v in changes.items())
                    )
            if LIST_RECORDS:
                echo('  F33:%s  %s' % (xml_id, list_record_name), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in changes.items()), '||', end='')
                echo()
            if not DRYRUN:
                res_partner.write(xml_id, new_record.id, changes)
    if not relevant_changes:
        print('...no relevant changes...')
    #
    # add new customers
    #
    if added_company_records:
        print('adding company records', border='flag')
    for key, company in added_company_records.items():
        if not DRYRUN:
            # double-check that record doesn't already exist
            customer_id = res_partner.search(domain=[('xml_id','=',key),('module','=','F33')])
            if customer_id:
                [customer_id] = customer_id
                ids[key] = customer_id
                res_partner.error('FIS ID F33:%s (%s) already exists in OpenERP' % (key, company.name))
                continue
        added_count += 1
        logger.info(
                'F33:%s -- adding -- %s',
                key,
                (', '.join(['%s=%r' % (k, v) for k, v in company.items()]))
                )
        if LIST_RECORDS:
            echo('  F33:%s  %s' % (key, company.name), end='  ')
            print('||', '||'.join('%s -> %r' % (k, v) for k, v in company.items()), '||', end='')
            echo()
        if not DRYRUN:
            customer_id = res_partner.create(key, company)
            if customer_id:
                company.id = customer_id
                ids[key] = customer_id
    #
    # add new contacts
    #
    if added_contact_records:
        print('adding contact records', border='flag')
    for key, contact in added_contact_records.items():
        if not DRYRUN:
            # double-check that record doesn't already exist
            parent_key = key[6:]
            contact_id = res_partner.search(domain=[('xml_id','=',key),('module','=','F33')])
            if contact_id:
                [contact_id] = contact_id
                ids[key] = contact_id
                res_partner.error('FIS ID F33:%s (%s) already exists in OpenERP' % (key, contact.name))
                continue
            else:
                # look for parent and get id
                contact.parent_id = ids.get(parent_key)
                if contact.parent_id is None:
                    print('  looking up parent id in OpenERP')
                    parent_id = res_partner.search(domain=[('xml_id','=',parent_key),('module','=','F33')])
                    if parent_id:
                        contact.parent_id = parent_id[0]
                        ids[parent_key] = parent_id
                    else:
                        print('  unable to find parent for %r' % key)
                        res_partner.error('unable to find parent for %r (%r)' % (key, parent_key, ))
                        continue
        added_count += 1
        logger.info(
                'F33:%s -- adding -- %s',
                key,
                (', '.join(['%s=%r' % (k, v) for k, v in contact.items()]))
                )
        if LIST_RECORDS:
            echo('  F33:%s  %s' % (key, contact.name), end='  ')
            print('||', '||'.join('%s -> %r' % (k, v) for k, v in contact.items()), '||', end='')
            echo()
        if not DRYRUN:
            contact_id = res_partner.create(key, contact)
            if contact_id:
                ids[key] = contact_id
                contact.id = contact_id
    #
    # delete/deactivate customers
    #
    if deleted_records:
        verb = 'deleting' if DELETE else 'deactivating'
        print('%s records' % verb, border='flag')
        logger.info(
                'F33 -- %s -- %s',
                verb,
                ', '.join(sorted(deleted_records.keys()))
                )
        if LIST_RECORDS:
            for key, rec in sorted(deleted_records.items()):
                echo('  F33:%s  %s' % (key, rec.name))
        deleted_count = len(deleted_records)
        if not DRYRUN:
            oe_ids = res_partner.search(domain=[('xml_id','in',deleted_records.keys())])
            if DELETE:
                res_partner.delete(oe_ids, context=context)
            else:
                res_partner.write('...', oe_ids, {'active': False}, context=context)
    #
    # update ir.model.data mappings
    #
    oe_records = dict(
            (r.id, r.xml_id)
            for r in get_records(
                oe, 'res.partner',
                domain=[('module','=','F33')],
                fields=['xml_id'],
                context=context,
                ))
    update_ir_model_data('res.partner', 33, oe_records)
    #
    print('%d customers changed\n%d customers added\n%d customers %s'
            % (changed_count, added_count, deleted_count, ('deactivated','deleted')[DELETE]),
            border='box',
            )

def handle_csmss(method):
    "extra ship-tos"
    print('processing CSMSS', border=('flag', '#'))
    global ship_to_parents, transmitter_codes
    context = {'fis-updates': True, 'active_test': False}
    res_partner = Model(oe.get_model('res.partner'), 'csmss', 'F34', context, RAISE_ON_EXCEPTION)
    ship_to_parents = dict([
        (r.xml_id, Many2One(r.id, r.name))
        for r in get_records(
            oe, 'res.partner',
            # [('xml_id','!=',False),('is_company','=',True)],
            [('xml_id','!=',False),('is_company','=',True)],
            fields=['id','xml_id','name'],
            context=context,
            )])
    transmitter_codes = dict([
        ('%s-%s' % (r.partner_xml_id, r.ship_to_code or 'default'), r)
        for r in get_records(oe, 'fis.transmitter_code')
        ])
    # these are for tracking original old/new records
    new_ship_to_records = {}
    old_ship_to_records = {}
    # these are for tracking old/new versions of changed records
    old_changed_ship_to_records = {}
    new_changed_ship_to_records = {}
    # these are for added/deleted records
    added_ship_to_records = {}
    deleted_records = {}
    # and the counts
    changed_count = 0
    added_count = 0
    deleted_count = 0
    ids = {}
    #
    # get the "old" data from:
    # - quick -> old fis file
    # - full -> current OpenERP data
    #
    csmss = fisData(34, rematch=r"10......1....")
    print(csmss.filename, '%s total records' % len(csmss), verbose=2)
    print('gathering data', border='flag')
    # ignore function
    def _ignore_csmss_rec(r):
        return (
                not r[F34.name]
                or re.search(r'.*additional.*ship.*to.*', r[F34.name], re.I)
                or re.search(r'.*additional.*ship.*to.*', r[F34.addr1], re.I)
                or re.search(r'.*additional.*ship.*to.*', r[F34.addr2], re.I)
                or re.search(r'.*additional.*ship.*to.*', r[F34.addr3], re.I)
                )
    if method == 'quick':
        #
        # for a quick compare we can use the fis records as-is
        #
        csmss_old = fisData(34, rematch=r"10......1....", data_path=config.network.fis_data_local_old_path)
        print(csmss_old.filename, verbose=2)
        print('collecting changed records')
        changes, added, deleted = get_changed_fis_records(
                csmss_old.values(),
                csmss.values(),
                enum_schema=[
                    F34.name, F34.tele, F34.sales_contact,
                    ],
                address_fields=[
                    F34.addr1, F34.addr2, F34.addr3,
                    ],
                ignore=lambda r: _ignore_csmss_rec,
                )
        #
        # we now have the subset of records that have changed, just need to separate them
        # into old and new
        #
        print('sorting changed records')
        for old_ship_to, new_ship_to, diffs in changes:
            old_ship_to_records[old_ship_to.xml_id] = old_ship_to
            new_ship_to_records[new_ship_to.xml_id] = new_ship_to
            # changes at the FIS level don't always translate to changes at the OpenERP level
            if old_ship_to != new_ship_to:
                old_changed_ship_to_records[old_ship_to.xml_id] = old_ship_to
                new_changed_ship_to_records[new_ship_to.xml_id] = new_ship_to
            assert set(old_changed_ship_to_records.keys()) == set(new_changed_ship_to_records.keys()),\
                    "old and new ship_to records mismatch"
        #
        # and convert the new and deleted records
        #
        print('sorting new and deleted records')
        for fis_rec in added:
            ship_to = convert_csmss_rec(fis_rec)
            if ship_to is None:
                continue
            new_ship_to_records[ship_to.xml_id] = ship_to
            added_ship_to_records[ship_to.xml_id] = ship_to
        for fis_rec in deleted:
            ship_to = convert_csmss_rec(fis_rec)
            if ship_to is None:
                continue
            old_ship_to_records[ship_to.xml_id] = ship_to
            deleted_records[ship_to.xml_id] = ship_to
    elif method == 'full':
        #
        # when doing a full compare, we have to convert every single fis record before we can
        # check for changes
        #
        all_fis_records = AttrDict()
        for fis_rec in csmss.values():
            ship_to = convert_csmss_rec(fis_rec, ignore=_ignore_csmss_rec)
            if ship_to is None:
                continue
            all_fis_records[ship_to.xml_id] = ship_to
        #
        # retrieve the OpenERP records that match the CSMS module, and divvy them up into ship_to
        # and contact records
        #
        print('retrieving OpenERP records')
        all_oe_records = dict([
                (r.xml_id, r)
                for r in get_records(
                    oe, 'res.partner',
                    domain=[('module','=','F34')],
                    fields=[
                        'id', 'module', 'xml_id', 'phone',
                        'name', 'street', 'street2', 'city', 'state_id', 'zip', 'country_id',
                        'customer', 'fis_ship_to_parent_id', 'use_parent_address', 'is_company',
                        'fis_transmitter_id', 'fis_ship_to_code', 'active',
                        ],
                    context=context,
                    )
                ])
        print('sorting ship_to records')
        for xml_id, datom in all_oe_records.items():
            ids[xml_id] = datom.id
            old_ship_to_records[xml_id] = datom
        #
        # now we can separate into new, changed, and deleted buckets
        #
        print('sorting changed, new, and deleted ship_to records')
        all_keys = set(all_fis_records.keys() + old_ship_to_records.keys())
        for key in all_keys:
            old_rec = all_oe_records.get(key)
            new_rec = all_fis_records.get(key)
            if old_rec is new_rec is None:
                continue
            if old_rec is None:
                added_ship_to_records[key] = new_rec
                continue
            if new_rec is None:
                deleted_records[key] = old_rec
                continue
            # copy missing fields for proper equality testing
            new_rec.id = old_rec.id
            if new_rec == old_rec:
                continue
            #
            # we have changes, save the records for later comparison
            #
            old_changed_ship_to_records[key] = old_rec
            new_changed_ship_to_records[key] = new_rec
        assert set(old_changed_ship_to_records.keys()) == set(new_changed_ship_to_records.keys()),\
                "old and new ship_to records mismatch"
    else:
        abort('unknown METHOD: %r' % (method, ))
    #
    # at this point, all records are in AttrDict format, divided by ship_to/contact
    # and deleted, added, changed
    #
    # process changes
    #
    if old_changed_ship_to_records:
        print('processing ship_to changes', border='flag')
    assert set(old_changed_ship_to_records.keys()) == set(new_changed_ship_to_records.keys()),\
            "old/new ship_to records mismatch"
    changed_ship_to_xml_ids = sorted(old_changed_ship_to_records.keys())
    relevant_changes = False
    for xml_id in changed_ship_to_xml_ids:
        #
        # TODO: check actual values in OpenERP and remove "changes" that are already set
        #
        # figure out the changes
        #
        old_record = old_changed_ship_to_records[xml_id]
        new_record = new_changed_ship_to_records[xml_id]
        assert set(old_record.keys()) == set(new_record.keys()),\
                ('old/new keys mismatch\nold:%s\n%s\nnew:%s\n%s' %
                    ('|'.join(sorted(old_record.keys())), box(str(old_record)),
                     '|'.join(sorted(new_record.keys())), box(str(new_record))))
        if method == 'full':
            assert 'id' in old_record, box('id field missing for %r' % (xml_id, ))
        elif xml_id in ids:
            # maybe this xml_id has already been seen?
            new_record.id = old_record.id = ids[xml_id]
        else:
            # otherwise, we'll look it up when we check for changes against OpenERP
            pass
        changes = get_updated_values(old_record, new_record)
        #
        # if this is a "full" update, we already have ids, and the changes are accurate
        # otherwise, we need to get the ids, and see if the "changes" have already been
        # put in place on the OpenERP side
        #
        if method == 'quick':
            fields_to_check = changes.keys()
            matches = res_partner.read(
                    domain=[('xml_id','=',xml_id),('module','=','F34')],
                    fields=fields_to_check,
                    )
            if not matches:
                res_partner.error('changed ship_to F34:%s not found in OpenERP' % xml_id)
            [match] = matches
            new_record.id = old_record.id = match.id
            ids[xml_id] = match.id
            for field in changes:
                if match[field] == changes[field]:
                    del changes[field]
        # quick and full from here
        if changes:
            relevant_changes = True
            changed_count += 1
            logger.info(
                    'F34: changing -- %s  -->  %s',
                    xml_id,
                    ', '.join("%s=%r" % (k, v) for k, v in changes.items())
                    )
            if LIST_RECORDS:
                echo('  F34:%s  %s' % (xml_id, new_record.name), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in changes.items()), '||', end='')
                echo()
            if not DRYRUN:
                res_partner.write(xml_id, new_record.id, changes)
    if not relevant_changes:
        print('...no relevant changes...')
    #
    # add new ship-tos
    #
    if added_ship_to_records:
        print('adding ship_to records', border='flag')
    for key, ship_to in added_ship_to_records.items():
        if not DRYRUN:
            # double-check that record doesn't already exist
            ship_to_id = res_partner.search(domain=[('xml_id','=',key),('module','=','F34')])
            if ship_to_id:
                [ship_to_id] = ship_to_id
                ids[key] = ship_to_id
                res_partner.error('FIS ID F34:%s (%s) already exists in OpenERP' % (key, ship_to.name))
                continue
        added_count += 1
        logger.info(
                'F34:%s -- adding -- %s',
                key,
                (', '.join(['%s=%r' % (k, v) for k, v in ship_to.items()]))
                )
        if LIST_RECORDS:
            echo('  F34:%s  %s' % (key, ship_to.name), end='  ')
            print('||', '||'.join('%s -> %r' % (k, v) for k, v in ship_to.items()), '||', end='')
            echo()
        if not DRYRUN:
            ship_to_id = res_partner.create(key, ship_to)
            if ship_to_id:
                ship_to.id = ship_to_id
                ids[key] = ship_to_id
    #
    # delete/deactivate ship-tos
    #
    if deleted_records:
        verb = 'deleting' if DELETE else 'deactivating'
        print('%s records' % verb, border='flag')
        logger.info(
                'F34 -- %s -- %s',
                verb,
                ', '.join(sorted(deleted_records.keys()))
                )
        if LIST_RECORDS:
            for key, rec in sorted(deleted_records.items()):
                echo('  F34:%s  %s' % (key, rec.name))
        deleted_count = len(deleted_records)
        if not DRYRUN:
            oe_ids = res_partner.search(domain=[('xml_id','in',deleted_records.keys())])
            if DELETE:
                res_partner.delete(oe_ids, context=context)
            else:
                res_partner.write('...', oe_ids, {'active': False}, context=context)
    #
    # update ir.model.data mappings
    #
    oe_records = dict(
            (r.id, r.xml_id)
            for r in get_records(
                oe, 'res.partner',
                domain=[('module','=','F34')],
                fields=['xml_id'],
                context=context,
                ))
    update_ir_model_data('res.partner', 34, oe_records)
    #
    print('%d ship-tos changed\n%d ship-tos added\n%d ship-tos %s'
            % (changed_count, added_count, deleted_count, ('deactivated','deleted')[DELETE]),
            border='box',
            )

def handle_customer_terms():
    print('processing CNVZd0 (customer terms)', border=('flag', '#'))
    context = {'fis-updates': True, 'active_test': False}
    customer_terms = Model(oe.get_model('fis.account.customer_terms'), 'cnvzd0', 'F8', context, RAISE_ON_EXCEPTION)
    # these  are for tracking old/new versions of changed records
    old_changed_terms_records = {}
    new_changed_terms_records = {}
    # these are for added/deleted records
    added_terms_records = {}
    deleted_records = {}
    # and the counts
    changed_count = 0
    added_count = 0
    deleted_count = 0
    ids = {}
    #
    # get the "old" data from:
    # - current OpenERP data
    #
    cnvzd0 = fisData(8, rematch=r"D010.")
    print(cnvzd0.filename, verbose=2)
    print('gathering data', border='flag')
    #
    # when doing a full compare, we have to convert every single fis record before we can
    # check for changes
    #
    all_fis_records = AttrDict()
    for fis_rec in cnvzd0.values():
        terms = convert_customer_terms_rec(fis_rec)
        all_fis_records[terms.xml_id] = terms
    #
    # retrieve the OpenERP records that match the CNVZd0 module
    #
    print('retrieving OpenERP records')
    all_oe_records = dict([
            (r.xml_id, r)
            for r in get_records(
                oe, 'fis.account.customer_terms',
                domain=[('module','=','F8')],
                fields=[
                    'id', 'module', 'xml_id', 'description',
                    ],
                context=context,
                )
            ])
    #
    # now we can separate into new, changed, and deleted buckets
    #
    print('sorting changed, new, and deleted customer terms records')
    all_keys = set(all_fis_records.keys() + all_oe_records.keys())
    for key in all_keys:
        old_rec = all_oe_records.get(key)
        new_rec = all_fis_records.get(key)
        if old_rec is new_rec is None:
            continue
        if old_rec is None:
            added_terms_records[key] = new_rec
            continue
        if new_rec is None:
            deleted_records[key] = old_rec
            continue
        # copy missing fields for proper equality testing
        new_rec.id = old_rec.id
        if new_rec == old_rec:
            continue
        #
        # we have changes, save the records for later comparison
        #
        old_changed_terms_records[key] = old_rec
        new_changed_terms_records[key] = new_rec
    assert set(old_changed_terms_records.keys()) == set(new_changed_terms_records.keys()),\
            "old and new terms records mismatch"
    #
    # at this point, all records are in AttrDict format, divided by deleted, added, and changed
    #
    # process changes
    #
    if old_changed_terms_records:
        print('processing customer terms changes', border='flag')
    assert set(old_changed_terms_records.keys()) == set(new_changed_terms_records.keys()),\
            "old/new customer terms records mismatch"
    changed_terms_xml_ids = sorted(old_changed_terms_records.keys())
    for xml_id in changed_terms_xml_ids:
        #
        # figure out the changes
        #
        old_record = old_changed_terms_records[xml_id]
        new_record = new_changed_terms_records[xml_id]
        assert set(old_record.keys()) == set(new_record.keys()),\
                ('old/new keys mismatch\nold:%s\n%s\nnew:%s\n%s' %
                    ('|'.join(sorted(old_record.keys())), box(str(old_record)),
                     '|'.join(sorted(new_record.keys())), box(str(new_record))))
        changes = get_updated_values(old_record, new_record)
        if changes:
            changed_count += 1
            logger.info(
                    'F8: changing -- %s  -->  %s',
                    xml_id,
                    ', '.join("%s=%r" % (k, v) for k, v in changes.items())
                    )
            if LIST_RECORDS:
                echo('  F8:%s  %s' % (xml_id, new_record.description), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in changes.items()), '||', end='')
                echo()
            if not DRYRUN:
                customer_terms.write(xml_id, new_record.id, changes)
    #
    # now add new customer terms
    #
    if added_terms_records:
        print('adding customer terms', border='flag')
    for key, terms in added_terms_records.items():
        echo(terms, border='box', verbose=2)
        # double-check that record doesn't already exist
        terms_id = customer_terms.search(domain=[('xml_id','=',key),('module','=','F8')])
        if terms_id:
            [terms_id] = terms_id
            ids[key] = terms_id
            customer_terms.error('FIS ID F8:%s (%s) already exists in OpenERP' % (key, terms.description))
        else:
            added_count += 1
            logger.info(
                    'F8:%s -- adding -- %s',
                    key,
                    (', '.join(['%s=%r' % (k, v) for k, v in terms.items()]))
                    )
            if LIST_RECORDS:
                echo('  F8:%s  %s' % (key, terms.description), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in terms.items()), '||', end='')
                echo()
            if not DRYRUN:
                terms_id = customer_terms.create(key, terms)
                if terms_id:
                    terms.id = terms_id
                    ids[key] = terms_id
                    customer_terms_recs[terms.xml_id] = terms_id
    #
    # delete/deactivate customer terms
    #
    if deleted_records:
        verb = 'deleting' if DELETE else 'deactivating'
        print('%s records' % verb, border='flag')
        logger.info(
                'F8 -- %s -- %s',
                verb,
                ', '.join(sorted(deleted_records.keys()))
                )
        if LIST_RECORDS:
            for key, rec in sorted(deleted_records.items()):
                echo('  F8:%s  %s' % (key, rec.description))
        deleted_count = len(deleted_records)
        if not DRYRUN:
            oe_ids = customer_terms.search(domain=[('xml_id','in',deleted_records.keys())])
            if DELETE:
                customer_terms.delete(oe_ids, context=context)
            else:
                customer_terms.write('...', oe_ids, {'active': False}, context=context)
    #
    # update ir.model.data mappings
    #
    oe_records = dict(
            (r.id, r.xml_id)
            for r in get_records(
                oe, 'fis.account.customer_terms',
                domain=[('module','=','F8')],
                fields=['xml_id'],
                context=context,
                ))
    update_ir_model_data('fis.account.customer_terms', 8, oe_records)
    #
    print('%d customer terms changed\n%d customer terms added\n%d customer terms %s'
            % (changed_count, added_count, deleted_count, ('deactivated','deleted')[DELETE]),
            border='box',
            )

def handle_transmitter():
    print('processing CNVZO1 (transmitter numbers)', border=('flag', '#'))
    context = {'fis-updates': True, 'active_test': False}
    transmitter_numbers = Model(oe.get_model('fis.transmitter_code'), 'cnvzo1', 'F192', context, RAISE_ON_EXCEPTION)
    # these  are for tracking old/new versions of changed records
    old_changed_transmitter_records = {}
    new_changed_transmitter_records = {}
    # these are for added/deleted records
    added_transmitter_records = {}
    deleted_records = {}
    # and the counts
    changed_count = 0
    added_count = 0
    deleted_count = 0
    ids = {}
    #
    # get the "old" data from:
    # - current OpenERP data
    #
    cnvzo1 = fisData(192, rematch=r"O110......")
    print(cnvzo1.filename, verbose=2)
    print('gathering data', border='flag')
    #
    # when doing a full compare, we have to convert every single fis record before we can
    # check for changes
    #
    all_fis_records = AttrDict()
    for fis_rec in cnvzo1.values():
        transmitter_code = convert_transmitter_code_rec(fis_rec)
        if not transmitter_code.transmitter_no.isdigit():
            # something's wrong with the transmitter number, log and discard
            transmitter_numbers.error(
                    'invalid transmitter number: %r\n     name: %s\n     ship: %s\n     cust: %s' % (
                        transmitter_code.transmitter_no,
                        transmitter_code.transmitter_name,
                        transmitter_code.ship_to_code,
                        transmitter_code.partner_xml_id
                        ))
            continue
        if not transmitter_code.partner_xml_id:
            # missing partner info
            transmitter_numbers.error(
                    'missing customer number: %r\n     name: %s\n     ship: %s\n     cust:' % (
                        transmitter_code.transmitter_no,
                        transmitter_code.transmitter_name,
                        transmitter_code.ship_to_code,
                        ))
            continue
        all_fis_records[transmitter_code.transmitter_no] = transmitter_code
    #
    # retrieve the OpenERP records that match the CNVZO1 module
    #
    print('retrieving OpenERP records')
    all_oe_records = dict([
            (r.transmitter_no, r)
            for r in get_records(
                oe, 'fis.transmitter_code',
                fields=[
                    'id', 'transmitter_no', 'transmitter_name', 'partner_xml_id', 'ship_to_code',
                    ],
                context=context,
                )
            ])
    #
    # now we can separate into new, changed, and deleted buckets
    #
    print('sorting changed, new, and deleted transmitter records')
    all_keys = set(all_fis_records.keys() + all_oe_records.keys())
    for key in all_keys:
        old_rec = all_oe_records.get(key)
        new_rec = all_fis_records.get(key)
        if old_rec is new_rec is None:
            continue
        if old_rec is None:
            added_transmitter_records[key] = new_rec
            continue
        if new_rec is None:
            deleted_records[key] = old_rec
            continue
        # copy missing fields for proper equality testing
        new_rec.id = old_rec.id
        if new_rec == old_rec:
            continue
        #
        # we have changes, save the records for later comparison
        #
        old_changed_transmitter_records[key] = old_rec
        new_changed_transmitter_records[key] = new_rec
    assert set(old_changed_transmitter_records.keys()) == set(new_changed_transmitter_records.keys()),\
            "old and new transmitter records mismatch"
    #
    # at this point, all records are in AttrDict format, divided by deleted, added, and changed
    #
    # process changes
    #
    if old_changed_transmitter_records:
        print('processing transmitter changes', border='flag')
    assert set(old_changed_transmitter_records.keys()) == set(new_changed_transmitter_records.keys()),\
            "old/new transmitter records mismatch"
    changed_transmitter_nos = sorted(old_changed_transmitter_records.keys())
    for tran_no in changed_transmitter_nos:
        #
        # figure out the changes
        #
        old_record = old_changed_transmitter_records[tran_no]
        new_record = new_changed_transmitter_records[tran_no]
        assert set(old_record.keys()) == set(new_record.keys()),\
                ('old/new keys mismatch\nold:%s\n%s\nnew:%s\n%s' %
                    ('|'.join(sorted(old_record.keys())), box(str(old_record)),
                     '|'.join(sorted(new_record.keys())), box(str(new_record))))
        changes = get_updated_values(old_record, new_record)
        if changes:
            changed_count += 1
            logger.info(
                    'F192: changing -- %s  -->  %s',
                    tran_no,
                    ', '.join("%s=%r" % (k, v) for k, v in changes.items())
                    )
            if LIST_RECORDS:
                echo('  F192:%s  %s' % (tran_no, new_record.description), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in changes.items()), '||', end='')
                echo()
            if not DRYRUN:
                transmitter_numbers.write(tran_no, new_record.id, changes)
    #
    # now add new transmitter records
    #
    if added_transmitter_records:
        print('adding transmitter records', border='flag')
    for key, transmitter in added_transmitter_records.items():
        echo(transmitter, border='box', verbose=2)
        # double-check that record doesn't already exist
        transmitter_id = transmitter_numbers.search(domain=[('transmitter_no','=',key)])
        if transmitter_id:
            [transmitter_id] = transmitter_id
            ids[key] = transmitter_id
            transmitter_numbers.error('FIS ID F192:%s (%s) already exists in OpenERP' % (key, transmitter.description))
        else:
            added_count += 1
            logger.info(
                    'F192:%s -- adding -- %s',
                    key,
                    (', '.join(['%s=%r' % (k, v) for k, v in transmitter.items()]))
                    )
            if LIST_RECORDS:
                echo('  F192:%s  %s' % (key, transmitter.description), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in transmitter.items()), '||', end='')
                echo()
            if not DRYRUN:
                transmitter_id = transmitter_numbers.create(key, transmitter)
                if transmitter_id:
                    transmitter.id = transmitter_id
                    ids[key] = transmitter_id
    #
    # delete transmitter records
    #
    if deleted_records:
        print('deleting transmitter records', border='flag')
        logger.info(
                'F192 -- removing -- %s',
                ', '.join(sorted(deleted_records.keys()))
                )
        if LIST_RECORDS:
            for key, rec in sorted(deleted_records.items()):
                echo('  F192:%s  %s' % (key, rec.description))
        deleted_count = len(deleted_records)
        if not DRYRUN:
            oe_ids = transmitter_numbers.search(domain=[('transmitter_no','in',deleted_records.keys())])
            transmitter_numbers.delete(oe_ids, context=context)
    #
    # update ir.model.data mappings
    #
    oe_records = dict(
            (r.id, r.transmitter_no)
            for r in get_records(
                oe, 'fis.transmitter_code',
                domain=[('module','=','F192')],
                fields=['transmitter_no'],
                context=context,
                ))
    update_ir_model_data('fis.transmitter_code', 192, oe_records)
    #
    print('%d transmitter records changed\n%d transmitter records added\n%d transmitter records deleted'
            % (changed_count, added_count, deleted_count),
            border='box',
            )

def handle_production_lines():
    print('processing CNVZf (production lines)', border=('flag', '#'))
    context = {'fis-updates': True, 'active_test': False}
    production_line_model = Model(oe.get_model('fis_integration.production_line'), 'cnvzf', 'F341', context, RAISE_ON_EXCEPTION)
    # these  are for tracking old/new versions of changed records
    old_changed_line_records = {}
    new_changed_line_records = {}
    # these are for added/deleted records
    added_line_records = {}
    deleted_records = {}
    # and the counts
    changed_count = 0
    added_count = 0
    deleted_count = 0
    ids = {}
    #
    # get the "old" data from:
    # - current OpenERP data
    #
    cnvzf = fisData(341, rematch=r"f10..")
    print(cnvzf.filename, verbose=2)
    print('gathering data', border='flag')
    #
    # when doing a full compare, we have to convert every single fis record before we can
    # check for changes
    #
    all_fis_records = AttrDict()
    for fis_rec in cnvzf.values():
        production_line = convert_production_line_rec(fis_rec)
        all_fis_records[production_line.xml_id] = production_line
    #
    # retrieve the OpenERP records that match the CNVZf module
    #
    print('retrieving OpenERP records')
    all_oe_records = dict([
            (r.xml_id, r)
            for r in get_records(
                oe, 'fis_integration.production_line',
                fields=[
                    'id', 'xml_id', 'module', 'desc',
                    ],
                context=context,
                )
            ])
    #
    # now we can separate into new, changed, and deleted buckets
    #
    print('sorting changed, new, and deleted production line records')
    all_keys = set(all_fis_records.keys() + all_oe_records.keys())
    for key in all_keys:
        old_rec = all_oe_records.get(key)
        new_rec = all_fis_records.get(key)
        if old_rec is new_rec is None:
            continue
        if old_rec is None:
            added_line_records[key] = new_rec
            continue
        if new_rec is None:
            deleted_records[key] = old_rec
            continue
        # copy missing fields for proper equality testing
        new_rec.id = old_rec.id
        if new_rec == old_rec:
            continue
        #
        # we have changes, save the records for later comparison
        #
        old_changed_line_records[key] = old_rec
        new_changed_line_records[key] = new_rec
    assert set(old_changed_line_records.keys()) == set(new_changed_line_records.keys()),\
            "old and new production line records mismatch"
    #
    # at this point, all records are in AttrDict format, divided by deleted, added, and changed
    #
    # process changes
    #
    if old_changed_line_records:
        print('processing production line changes', border='flag')
    assert set(old_changed_line_records.keys()) == set(new_changed_line_records.keys()),\
            "old/new production line records mismatch"
    changed_line_id = sorted(old_changed_line_records.keys())
    for changed_line_id in changed_line_id:
        #
        # figure out the changes
        #
        old_record = old_changed_line_records[changed_line_id]
        new_record = new_changed_line_records[changed_line_id]
        assert set(old_record.keys()) == set(new_record.keys()),\
                ('old/new keys mismatch\nold:%s\n%s\nnew:%s\n%s' %
                    ('|'.join(sorted(old_record.keys())), box(str(old_record)),
                     '|'.join(sorted(new_record.keys())), box(str(new_record))))
        changes = get_updated_values(old_record, new_record)
        if changes:
            changed_count += 1
            logger.info(
                    'F341: changing -- %s  -->  %s',
                    changed_line_id,
                    ', '.join("%s=%r" % (k, v) for k, v in changes.items())
                    )
            if LIST_RECORDS:
                echo('  F341:%s  %s' % (changed_line_id, new_record.desc), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in changes.items()), '||', end='')
                echo()
            if not DRYRUN:
                production_line_model.write(changed_line_id, new_record.id, changes)
    #
    # now add new production line records
    #
    if added_line_records:
        print('adding production line records', border='flag')
    for key, line in added_line_records.items():
        echo(line, border='box', verbose=2)
        # double-check that record doesn't already exist
        line_id = production_line_model.search(domain=[('xml_id','=',key)])
        if line_id:
            [line_id] = line_id
            ids[key] = line_id
            production_line_model.error('FIS ID F341:%s (%s) already exists in OpenERP' % (key, line.desc))
        else:
            added_count += 1
            if LIST_RECORDS:
                echo('  F341:%s  %s' % (key, line.desc), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in line.items()), '||', end='')
                echo()
            if not DRYRUN:
                line_id = production_line_model.create(key, line)
                if line_id:
                    line.id = line_id
                    ids[key] = line_id
    #
    # delete production line records
    #
    if deleted_records:
        print('deleting production line records', border='flag')
        if LIST_RECORDS:
            for key, rec in sorted(deleted_records.items()):
                echo('  F341:%s  %s' % (key, rec.desc))
        deleted_count = len(deleted_records)
        if not DRYRUN:
            oe_ids = production_line_model.search(domain=[('xml_id','in',deleted_records.keys())])
            production_line_model.delete(oe_ids, context=context)
    #
    # update ir.model.data mappings
    #
    oe_records = dict(
            (r.id, r.xml_id)
            for r in get_records(
                oe, 'fis_integration.production_line',
                fields=['xml_id'],
                context=context,
                ))
    update_ir_model_data('fis_integration.production_line', 341, oe_records)
    #
    print('%d production line records changed\n%d production line records added\n%d production line records deleted'
            % (changed_count, added_count, deleted_count),
            border='box',
            )

def handle_sales_reps():
    print('processing CNVZz (customer sales reps)', border=('flag', '#'))
    context = {'fis-updates': True, 'active_test': False}
    customer_salesreps = Model(oe.get_model('fis.account.salesperson'), 'cnvzz', 'F47', context, RAISE_ON_EXCEPTION)
    # these  are for tracking old/new versions of changed records
    old_changed_sales_reps = {}
    new_changed_sales_reps = {}
    # these are for added/deleted records
    added_salesrep_records = {}
    deleted_records = {}
    # and the counts
    changed_count = 0
    added_count = 0
    deleted_count = 0
    ids = {}
    #
    # get the "old" data from:
    # - current OpenERP data
    #
    cnvzz = fisData(47, rematch=r"Z...")
    print(cnvzz.filename, verbose=2)
    print('gathering data', border='flag')
    #
    # when doing a full compare, we have to convert every single fis record before we can
    # check for changes
    #
    all_fis_records = AttrDict()
    for fis_rec in cnvzz.values():
        salesrep = convert_customer_salesrep_rec(fis_rec)
        all_fis_records[salesrep.xml_id] = salesrep
    #
    # retrieve the OpenERP records that match the CNVZz module
    #
    print('retrieving OpenERP records')
    all_oe_records = dict([
            (r.xml_id, r)
            for r in get_records(
                oe, 'fis.account.salesperson',
                domain=[('module','=','F47')],
                fields=[
                    'id', 'module', 'xml_id', 'fis_name',
                    ],
                context=context,
                )
            ])
    #
    # now we can separate into new, changed, and deleted buckets
    #
    print('sorting changed, new, and deleted customer salesrep records')
    all_keys = set(all_fis_records.keys() + all_oe_records.keys())
    for key in all_keys:
        old_rec = all_oe_records.get(key)
        new_rec = all_fis_records.get(key)
        if old_rec is new_rec is None:
            continue
        if old_rec is None:
            added_salesrep_records[key] = new_rec
            continue
        if new_rec is None:
            deleted_records[key] = old_rec
            continue
        # copy missing fields for proper equality testing
        new_rec.id = old_rec.id
        if new_rec == old_rec:
            continue
        #
        # we have changes, save the records for later comparison
        #
        old_changed_sales_reps[key] = old_rec
        new_changed_sales_reps[key] = new_rec
    assert set(old_changed_sales_reps.keys()) == set(new_changed_sales_reps.keys()),\
            "old and new salesrep records mismatch"
    #
    # at this point, all records are in AttrDict format, divided by deleted, added, and changed
    #
    # process changes
    #
    if old_changed_sales_reps:
        print('processing customer salesrep changes', border='flag')
    assert set(old_changed_sales_reps.keys()) == set(new_changed_sales_reps.keys()),\
            "old/new customer salesrep records mismatch"
    changed_salesreps_xml_ids = sorted(old_changed_sales_reps.keys())
    for xml_id in changed_salesreps_xml_ids:
        #
        # figure out the changes
        #
        old_record = old_changed_sales_reps[xml_id]
        new_record = new_changed_sales_reps[xml_id]
        assert set(old_record.keys()) == set(new_record.keys()),\
                ('old/new keys mismatch\nold:%s\n%s\nnew:%s\n%s' %
                    ('|'.join(sorted(old_record.keys())), box(str(old_record)),
                     '|'.join(sorted(new_record.keys())), box(str(new_record))))
        changes = get_updated_values(old_record, new_record)
        if changes:
            changed_count += 1
            logger.info(
                    'F47: changing -- %s  -->  %s',
                    xml_id,
                    ', '.join("%s=%r" % (k, v) for k, v in changes.items())
                    )
            if LIST_RECORDS:
                echo('  F47:%s  %s' % (xml_id, new_record.fis_name), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in changes.items()), '||', end='')
                echo()
            if not DRYRUN:
                customer_salesreps.write(xml_id, new_record.id, changes)
    #
    # now add new customer salesrep
    #
    if added_salesrep_records:
        print('adding customer salesrep', border='flag')
    for key, salesrep in added_salesrep_records.items():
        echo(salesrep, border='box', verbose=2)
        # double-check that record doesn't already exist
        salesrep_id = customer_salesreps.search(domain=[('xml_id','=',key),('module','=','F47')])
        if salesrep_id:
            [salesrep_id] = salesrep_id
            ids[key] = salesrep_id
            customer_salesreps.error('FIS ID F47:%s (%s) already exists in OpenERP' % (key, salesrep.fis_name))
        else:
            added_count += 1
            logger.info(
                    'F47:%s -- adding -- %s',
                    key,
                    (', '.join(['%s=%r' % (k, v) for k, v in salesrep.items()]))
                    )
            if LIST_RECORDS:
                echo('  F47:%s  %s' % (key, salesrep.fis_name), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in salesrep.items()), '||', end='')
                echo()
            if not DRYRUN:
                salesrep_id = customer_salesreps.create(key, salesrep)
                if salesrep_id:
                    salesrep.id = salesrep_id
                    ids[key] = salesrep_id
                    customer_terms_recs[salesrep.xml_id] = salesrep_id
    #
    # delete/deactivate customer salesrep
    #
    if deleted_records:
        verb = 'deleting' if DELETE else 'deactivating'
        print('%s records' % verb, border='flag')
        logger.info(
                'F47 -- %s -- %s',
                verb,
                ', '.join(sorted(deleted_records.keys()))
                )
        if LIST_RECORDS:
            for key, rec in sorted(deleted_records.items()):
                echo('  F47:%s  %s' % (key, rec.fis_name))
        deleted_count = len(deleted_records)
        if not DRYRUN:
            oe_ids = customer_salesreps.search(domain=[('xml_id','in',deleted_records.keys())])
            if DELETE:
                customer_salesreps.delete(oe_ids, context=context)
            else:
                customer_salesreps.write('...', oe_ids, {'active': False}, context=context)
    #
    # update ir.model.data mappings
    #
    oe_records = dict(
            (r.id, r.xml_id)
            for r in get_records(
                oe, 'fis.account.salesperson',
                domain=[('module','=','F47')],
                fields=['xml_id'],
                context=context,
                ))
    update_ir_model_data('fis.account.salesperson', 47, oe_records)
    #
    print('%d customer salesrep changed\n%d customer salesrep added\n%d customer salesrep %s'
            % (changed_count, added_count, deleted_count, ('deactivated','deleted')[DELETE]),
            border='box',
            )

def handle_carrier(method):
    print('processing CNVZsv (shipping carriers)', border=('flag', '#'))
    context = {'fis-updates': True, 'active_test': False}
    res_partner = Model(oe.get_model('res.partner'), 'cnvzsv', 'F27', context, RAISE_ON_EXCEPTION)
    # these are for tracking original old/new records
    new_company_records = {}
    old_company_records = {}
    # these  are for tracking old/new versions of changed records
    old_changed_company_records = {}
    new_changed_company_records = {}
    # these are for added/deleted records
    added_company_records = {}
    deleted_records = {}
    # and the counts
    changed_count = 0
    added_count = 0
    deleted_count = 0
    ids = {}
    #
    # get the "old" data from:
    # - quick -> old fis file
    # - full -> current OpenERP data
    #
    cnvzsv = fisData(27, rematch=r"SV10..")
    print(cnvzsv.filename, verbose=2)
    print('gathering data', border='flag')
    if method == 'quick':
        #
        # for a quick compare we can use the fis records as-is
        #
        cnvzsv_old = fisData(27, rematch=r"SV10..", data_path=config.network.fis_data_local_old_path)
        print(cnvzsv_old.filename, verbose=2)
        print('collecting changed records')
        changes, added, deleted = get_changed_fis_records(
                cnvzsv_old.values(),
                cnvzsv.values(),
                enum_schema=[
                    F27.name, F27.tele, F27.fuel_surcharge,
                    ],
                address_fields=[
                    F27.addr1, F27.addr2, F27.addr3,
                    ],
                )
        #
        # we now have the subset of records that have changed, just need to separate them
        # into old and new
        #
        print('sorting changed records')
        for old, new, diffs in changes:
            old_company = convert_carrier_rec(old)
            old_company_records[old_company.xml_id] = old_company
            new_company = convert_carrier_rec(new)
            new_company_records[new_company.xml_id] = new_company
            # changes at the FIS level don't always translate to changes at the OpenERP level
            if old_company != new_company:
                old_changed_company_records[old_company.xml_id] = old_company
                new_changed_company_records[new_company.xml_id] = new_company
            assert set(old_changed_company_records.keys()) == set(new_changed_company_records.keys()),\
                    "old and new company records mismatch"
        #
        # and convert the new and deleted records
        #
        print('sorting new and deleted records')
        for fis_rec in added:
            company = convert_carrier_rec(fis_rec)
            new_company_records[company.xml_id] = company
            added_company_records[company.xml_id] = company
        for fis_rec in deleted:
            company = convert_carrier_rec(fis_rec)
            old_company_records[company.xml_id] = company
            deleted_records[company.xml_id] = company
    elif method == 'full':
        #
        # when doing a full compare, we have to convert every single fis record before we can
        # check for changes
        #
        all_fis_records = AttrDict()
        for fis_rec in cnvzsv.values():
            company = convert_carrier_rec(fis_rec)
            all_fis_records[company.xml_id] = company
        #
        # retrieve the OpenERP records that match the CNVZsv module
        #
        print('retrieving OpenERP records')
        all_oe_records = dict([
                (r.xml_id, r)
                for r in get_records(
                    oe, 'res.partner',
                    domain=[('module','=','F27')],
                    fields=[
                        'id', 'module', 'xml_id', 'is_carrier', 'is_company', 'use_parent_address',
                        'name', 'street', 'street2', 'city', 'state_id', 'zip', 'country_id',
                        'phone', 'fuel_surcharge', 'fis_updated_by_user',
                        ],
                    context=context,
                    )
                ])
        #
        # now we can separate into new, changed, and deleted buckets
        #
        print('sorting changed, new, and deleted carrier records')
        all_keys = set(all_fis_records.keys() + all_oe_records.keys())
        for key in all_keys:
            old_rec = all_oe_records.get(key)
            new_rec = all_fis_records.get(key)
            if old_rec is new_rec is None:
                continue
            if old_rec is None:
                added_company_records[key] = new_rec
                continue
            if new_rec is None:
                deleted_records[key] = old_rec
                continue
            # copy missing fields for proper equality testing
            new_rec.id = old_rec.id
            new_rec.fis_updated_by_user = old_rec.fis_updated_by_user
            if new_rec == old_rec:
                continue
            #
            # we have changes, save the records for later comparison
            #
            old_changed_company_records[key] = old_rec
            new_changed_company_records[key] = new_rec
        assert set(old_changed_company_records.keys()) == set(new_changed_company_records.keys()),\
                "old and new company records mismatch"
    else:
        abort('unknown METHOD: %r' % (method, ))
    #
    # at this point, all records are in AttrDict format, divided by deleted, added, and changed
    #
    # process changes
    #
    if old_changed_company_records:
        print('processing carrier changes', border='flag')
    assert set(old_changed_company_records.keys()) == set(new_changed_company_records.keys()),\
            "old/new carrier records mismatch"
    changed_company_xml_ids = sorted(old_changed_company_records.keys())
    relevant_changes = False
    for xml_id in changed_company_xml_ids:
        #
        # figure out the changes
        #
        old_record = old_changed_company_records[xml_id]
        new_record = new_changed_company_records[xml_id]
        assert set(old_record.keys()) == set(new_record.keys()),\
                ('old/new keys mismatch\nold:%s\n%s\nnew:%s\n%s' %
                    ('|'.join(sorted(old_record.keys())), box(str(old_record)),
                     '|'.join(sorted(new_record.keys())), box(str(new_record))))
        if method == 'full':
            assert 'id' in old_record, box('id field missing for %r' % (xml_id, ))
            # check for user-updated-address and specials
            user_updates = old_record.fis_updated_by_user or ''
            if 'A' in user_updates:
                # drop all the address fields
                del old_record.use_parent_address
                del old_record.street, old_record.street2
                del old_record.city, old_record.state_id, old_record.zip, old_record.country_id
                del new_record.use_parent_address
                del new_record.street, new_record.street2
                del new_record.city, new_record.state_id, new_record.zip, new_record.country_id
            if 'N' in user_updates:
                del old_record.name
                del new_record.name
            if 'S' in user_updates:
                del old_record.specials_notification
                del new_record.specials_notification
        elif xml_id in ids:
            # maybe this xml_id has already been seen?
            new_record.id = old_record.id = ids[xml_id]
        else:
            # otherwise, we'll look it up when we check for changes against OpenERP
            pass
        changes = get_updated_values(old_record, new_record)
        #
        # if this is a "full" update, we already have ids, and the changes are accurate
        # otherwise, we need to get the ids, and see if the "changes" have already been
        #   put in place on the OpenERP side
        #
        if method == 'quick':
            fields_to_check = changes.keys()
            matches = res_partner.read(
                    domain=[('xml_id','=',xml_id),('module','=','F27')],
                    fields=fields_to_check,
                    )
            if not matches:
                res_partner.error('changed company F27:%s not found in OpenERP' % xml_id)
            [match] = matches
            new_record.id = old_record.id = match.id
            ids[xml_id] = match.id
            for field in changes:
                if match[field] == changes[field]:
                    del changes[field]
            user_updates = match.fis_updated_by_user or ''
            if 'N' in user_updates:
                changes.pop('name', None)
            if 'S' in user_updates:
                changes.pop('specials_notification', None)
            if 'A' in user_updates:
                for f in ('street', 'street2', 'city', 'state_id', 'zip', 'country_id'):
                    changes.pop(f, None)
        # quick and full from here
        if changes:
            relevant_changes = True
            changed_count += 1
            logger.info(
                    'F27: changing -- %s  -->  %s',
                    xml_id,
                    ', '.join("%s=%r" % (k, v) for k, v in changes.items())
                    )
            if LIST_RECORDS:
                echo('  F27:%s  %s' % (xml_id, new_record.name), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in changes.items()), '||', end='')
                echo()
            if not DRYRUN:
                res_partner.write(xml_id, new_record.id, changes)
    if not relevant_changes:
        print('...no relevant changes...')
    #
    # now add new carriers
    #
    if added_company_records:
        print('adding carriers', border='flag')
    for key, company in added_company_records.items():
        if not DRYRUN:
            # double-check that record doesn't already exist
            customer_id = res_partner.search(domain=[('xml_id','=',key),('module','=','F27')])
            if customer_id:
                [customer_id] = customer_id
                ids[key] = customer_id
                res_partner.error('FIS ID F27:%s (%s) already exists in OpenERP' % (key, company.name))
                continue
        added_count += 1
        logger.info(
                'F27:%s -- adding -- %s',
                key,
                (', '.join(['%s=%r' % (k, v) for k, v in company.items()]))
                )
        if LIST_RECORDS:
            echo('  F27:%s  %s' % (key, company.name), end='  ')
            print('||', '||'.join('%s -> %r' % (k, v) for k, v in company.items()), '||', end='')
            echo()
        if not DRYRUN:
            customer_id = res_partner.create(key, company)
            if customer_id:
                company.id = customer_id
                ids[key] = customer_id
    #
    # delete/deactivate carriers
    #
    if deleted_records:
        verb = 'deleting' if DELETE else 'deactivating'
        print('%s records' % verb, border='flag')
        logger.info(
                'F27 -- %s -- %s',
                verb,
                ', '.join(sorted(deleted_records.keys()))
                )
        if LIST_RECORDS:
            for key, rec in sorted(deleted_records.items()):
                echo('  F27:%s  %s' % (key, rec.name))
        deleted_count = len(deleted_records)
        if not DRYRUN:
            oe_ids = res_partner.search(domain=[('xml_id','in',deleted_records.keys())])
            if DELETE:
                res_partner.delete(oe_ids, context=context)
            else:
                res_partner.write('...', oe_ids, {'active': False}, context=context)
    #
    # update ir.model.data mappings
    #
    oe_records = dict(
            (r.id, r.xml_id)
            for r in get_records(
                oe, 'res.partner',
                domain=[('module','=','F27')],
                fields=['xml_id'],
                context=context,
                ))
    update_ir_model_data('res.partner', 27, oe_records)
    #
    print('%d carriers changed\n%d carriers added\n%d carriers %s'
            % (changed_count, added_count, deleted_count, ('deactivated','deleted')[DELETE]),
            border='box',
            )

def handle_emp1(method):
    print('processing EMP1', border='#')
    context = {'hr_welcome': False, 'fis-updates': True, 'active_test': False}
    # today = Date.today()
    hr_employee = Model(oe.get_model('hr.employee'), 'emp1', 'F74-emp', context, RAISE_ON_EXCEPTION)
    res_partner = Model(oe.get_model('res.partner'), 'emp1', 'F74', context, RAISE_ON_EXCEPTION)
    # these are for tracking original old/new records
    new_employee_records = {}
    old_employee_records = {}
    # these  are for tracking old/new versions of changed records
    old_changed_employee_records = {}
    new_changed_employee_records = {}
    # these are for added/deleted records
    added_employee_records = {}
    deleted_records = {}
    # and counts and tests
    changed_count = 0
    added_count = 0
    deleted_count = 0
    ids = {}
    active_test_needed = set()
    # birthday_test_needed = set()
    #
    # get the "old" data from:
    # - quick -> old fis file
    # - full -> current OpenERP data
    #
    emp1 = fisData(74, rematch=r"10.....")
    print(emp1.filename, verbose=2)
    print('gathering data', border='lined')
    if method == 'quick':
        #
        # for a quick compare we can use the fis records as-is
        #
        emp1_old = fisData(74, rematch=r"10.....", data_path=config.network.fis_data_local_old_path)
        print(emp1_old.filename, verbose=2)
        print('collecting changed records')
        changes, added, deleted = get_changed_fis_records(
                emp1_old.values(),
                emp1.values(),
                enum_schema=[
                    F74.name, F74.ssn, F74.tele, F74.date_hired, F74.date_terminated,
                    F74.birth_date, F74.last_raise, F74.status_flag, F74.pay_type,
                    F74.marital_status, F74.pension_status, F74.gender, F74.emergency_contact,
                    F74.emergency_phone, F74.exempt_fed, F74.exempt_state, F74.hourly_rate,
                    ],
                address_fields=[
                    F74.addr1, F74.addr2, F74.addr3,
                    ],
                ignore=lambda r: int(r[F74.emp_num]) >= 9000,
                )
        #
        # we now have the subset of records that have changed, just need to separate them
        # into old and new
        #
        print('sorting changed records')
        for old, new, diffs in changes:
            old_employee = convert_emp1_rec(old)
            old_employee_records[old_employee.xml_id] = old_employee
            new_employee = convert_emp1_rec(new)
            new_employee_records[new_employee.xml_id] = new_employee
            # changes at the FIS level don't always translate to changes at the OpenERP level
            if old_employee != new_employee:
                old_changed_employee_records[old_employee.xml_id] = old_employee
                new_changed_employee_records[new_employee.xml_id] = new_employee
            assert set(old_changed_employee_records.keys()) == set(new_changed_employee_records.keys()),\
                    "old and new employee records mismatch"
        #
        # and convert the new and deleted records
        #
        print('sorting new and deleted records')
        for fis_rec in added:
            employee = convert_emp1_rec(fis_rec)
            new_employee_records[employee.xml_id] = employee
            added_employee_records[employee.xml_id] = employee
        for fis_rec in deleted:
            employee = convert_emp1_rec(fis_rec)
            old_employee_records[employee.xml_id] = employee
            deleted_records[employee.xml_id] = employee
    elif method == 'full':
        #
        # when doing a full compare, we have to convert every single fis record before we can
        # check for changes
        #
        all_fis_records = AttrDict()
        print('retrieving FIS records')
        for fis_rec in emp1.values():
            employee = convert_emp1_rec(fis_rec)
            if employee is None:
                # print('skipping %r' % (fis_rec[F74.emp_num], ))
                continue
            all_fis_records[employee.xml_id] = employee
        #
        # retrieve the OpenERP records that match the CNVZsv module
        #
        print('retrieving OpenERP records')
        all_oe_records = dict([
                (r.xml_id, r)
                for r in get_records(
                    oe, 'hr.employee',
                    domain=[('module','=','F74-emp')],
                    fields=[
                        'id', 'module', 'xml_id', 'name', 'employment_type', 'ssnid', 'birthday', 'home_phone',
                        'home_street', 'home_street2', 'home_city', 'home_state_id', 'home_zip', 'home_country_id',
                        'hire_date', 'fire_date', 'active', 'status_flag', 'pension_plan',
                        'pay_type', 'hourly_rate', 'last_raise', 'marital', 'gender', 'identification_id',
                        'emergency_contact', 'emergency_number', 'state_exemptions', 'federal_exemptions',
                        ],
                    context=context,
                    )
                ])
        #
        # now we can separate into new, changed, and deleted buckets
        #
        print('sorting changed, new, and deleted emp1 records')
        all_keys = set(all_fis_records.keys() + all_oe_records.keys())
        for key in all_keys:
            old_rec = all_oe_records.get(key)
            new_rec = all_fis_records.get(key)
            if old_rec is new_rec is None:
                continue
            if old_rec is None:
                added_employee_records[key] = new_rec
                continue
            if new_rec is None:
                deleted_records[key] = old_rec
                continue
            # copy missing fields for proper equality testing
            new_rec.id = old_rec.id
            if new_rec == old_rec:
                continue
            #
            # we have changes, save the records for later comparison
            #
            old_changed_employee_records[key] = old_rec
            new_changed_employee_records[key] = new_rec
        assert set(old_changed_employee_records.keys()) == set(new_changed_employee_records.keys()),\
                "old and new employee records mismatch"
    else:
        abort('unknown METHOD: %r' % (method, ))
    #
    # at this point, all records are in AttrDict format, divided by deleted, added, and changed
    #
    # process changes
    #
    if old_changed_employee_records:
        print('processing emp1 changes', border='lined')
    assert set(old_changed_employee_records.keys()) == set(new_changed_employee_records.keys()),\
            "old/new emp1 records mismatch"
    changed_employee_xml_ids = sorted(old_changed_employee_records.keys())
    relevant_changes = False
    for xml_id in changed_employee_xml_ids:
        #
        # figure out the changes
        #
        old_record = old_changed_employee_records[xml_id]
        new_record = new_changed_employee_records[xml_id]
        assert set(old_record.keys()) == set(new_record.keys()),\
                ('old/new keys mismatch\nold:%s\n%s\nnew:%s\n%s' %
                    ('|'.join(sorted(old_record.keys())), box(str(old_record)),
                     '|'.join(sorted(new_record.keys())), box(str(new_record))))
        if method == 'full':
            assert 'id' in old_record, box('id field missing for %r' % (xml_id, ))
        elif xml_id in ids:
            # maybe this xml_id has already been seen?
            new_record.id = old_record.id = ids[xml_id]
        else:
            # otherwise, we'll look it up when we check for changes against OpenERP
            pass
        changes = get_updated_values(old_record, new_record)
        #
        # if this is a "full" update, we already have ids, and the changes are accurate
        # otherwise, we need to get the ids, and see if the "changes" have already been
        #   put in place on the OpenERP side
        #
        if method == 'quick':
            fields_to_check = changes.keys()
            matches = hr_employee.read(
                    domain=[('xml_id','=',xml_id),('module','=','F74-emp')],
                    fields=fields_to_check,
                    )
            if not matches:
                hr_employee.error('changed employee F74-emp:%s not found in OpenERP' % xml_id)
                continue
            print(matches, border='box')
            [match] = matches
            new_record.id = old_record.id = match.id
            ids[xml_id] = match.id
            for field in changes:
                if match[field] == changes[field]:
                    del changes[field]
        # quick and full from here
        if changes:
            relevant_changes = True
            changed_count += 1
            logger.info(
                    'F74: changing -- %s  -->  %s',
                    xml_id,
                    ', '.join("%s=%r" % (k, v) for k, v in changes.items())
                    )
            if LIST_RECORDS:
                echo('  F74-emp:%s  %s' % (xml_id, new_record.name), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in changes.items()), '||', end='')
                echo()
            if not DRYRUN:
                hr_employee.write(xml_id, new_record.id, changes)
    if not relevant_changes:
        print('...no relevant changes...')
    #
    # now add new employees
    #
    if added_employee_records:
        print('adding records', border='lined')
    for key, employee in added_employee_records.items():
        if not DRYRUN:
            # double-check that record doesn't already exist
            employee_id = hr_employee.search(domain=[('xml_id','=',key),('module','=','F74-emp')])
            if employee_id:
                [employee_id] = employee_id
                ids[key] = employee_id
                hr_employee.error('FIS ID F74-emp:%s (%s) already exists in OpenERP' % (key, employee.name))
                continue
        added_count += 1
        logger.info(
                'F74:%s -- adding -- %s',
                key,
                (', '.join(['%s=%r' % (k, v) for k, v in employee.items()]))
                )
        if LIST_RECORDS:
            echo('  F74-emp:%s  %s' % (key, employee.name), end='  ')
            print('||', '||'.join('%s -> %r' % (k, v) for k, v in employee.items()), '||', end='')
            echo()
        if not DRYRUN:
            employee_id = hr_employee.create(key, employee)
            if not employee_id:
                continue
            employee.id = employee_id
            ids[key] = employee_id
            # check for existing res.partner record, and use it if it exists
            emp_num = employee.xml_id
            emp_name = employee.name
            rp_id = hr_employee.search(domain=[('module','=','F74'),('xml_id','=',emp_num)])
            if rp_id:
                # update res.partner record with employee link
                rp_id = rp_id[0]
                res_partner.write(emp_num, rp_id, {'employee_id': employee_id})
            else:
                # otherwise, try to create it, leaving it at False (0) on failure
                rp_id = res_partner.create(
                        emp_num,
                        {'name': emp_name, 'xml_id': emp_num, 'module': 'F74', 'employee_id': employee_id},
                        )
    #
    # deactivate employees  --  DO NOT DELETE
    #
    if deleted_records:
        print('deactivating employees', border='flag')
        for emp_num, rec in sorted(deleted_records.items()):
            logger.info(
                    'F74 -- deactivating --  %6s  %-11s  %-11s  %s',
                    emp_num,
                    rec.hire_date or '',
                    rec.fire_date or '',
                    NameCaseReversed(rec.name),
                    )
        if LIST_RECORDS:
            header_needed = True
            for emp_num, rec in sorted(deleted_records.items()):
                if not rec.active:
                    deleted_records.pop(emp_num)
                else:
                    if header_needed:
                        echo('%6s  %-11s  %-11s  %s' % ('Emp. #', 'Start Date', 'End Date', 'Employee Name'))
                        header_needed = False
                    name = NameCaseReversed(rec.name)
                    date_hired = rec.hire_date or ''
                    date_terminated = rec.fire_date or ''
                    echo("%6s  %-11s  %-11s  %s" % (emp_num, date_hired, date_terminated, name))
        deleted_count = len(deleted_records)
        if not DRYRUN:
            oe_ids = hr_employee.search(domain=[('xml_id','in',deleted_records.keys())])
            hr_employee.write('...', oe_ids, {'active': False}, context=context)
    #
    #
    # check for suspect birthdates
    #
    # if birthday_test_needed:
    #     underage = today.replace(delta_year=-18).strftime(DEFAULT_SERVER_DATE_FORMAT)
    #     overage = today.replace(delta_year=+65).strftime(DEFAULT_SERVER_DATE_FORMAT)
    #     bad_birthdays = hr.employee.read(
    #             domain=[('id','in',list(birthday_test_needed)),'|',('birthday','<',underage),('birthday','>',overage)],
    #             fields=['id', 'birthday', 'name', 'xml_id'],
    #             )
    #     if bad_birthdays:
    #         employee_list = []
    #         for rec in bad_birthdays:
    #             rec.name = NameCaseReversed(rec.name)
    #             rec.birthday = Date.strptime(rec.birthday, DEFAULT_SERVER_DATE_FORMAT)#.strftime('%d-%b-%Y')
    #         for rec in sorted(bad_birthdays, key=lambda r: r.name):
    #             employee_list.append("%5s:  %s - %s" % (rec.xml_id, rec.birthday, rec.name))
    #         mail(message=
    #                 "From: FIS Integration Continuous Update <noreply@sunridgefarms.com>\n"
    #                 # "To: Ron Giannini <rgiannini@sunridgefarms.com>\n"
    #                 # "Cc: Emile van Sebille <emile@sunridgefarms.com>\n"
    #                 # "Cc: Alyssa Corinne <alyssa@sunridgefarms.com>\n"
    #                 "Cc: Ethan Furman <ethan@stoneleaf.us>\n"
    #                 "Subject: employees with suspect birthdates in FIS [emp1, 74]\n"
    #                 "\n"
    #                 + '\n'.join(employee_list),
    #                 )
    #
    # check for (in)active records
    #
    if active_test_needed:
        active_test = hr_employee.read(
                domain=[('id','in',list(active_test_needed))],
                fields=['id', 'hire_date', 'fire_date','xml_id'],
                )
        active = []
        active_keys = []
        inactive = []
        inactive_keys = []
        for rec in active_test:
            if not rec.fire_date:
                active.append(rec.id)
                active_keys.append(rec.xml_id)
            elif rec.fire_date < rec.hire_date:
                active.append(rec.id)
                active_keys.append(rec.xml_id)
            else:
                inactive.append(rec.id)
                inactive_keys.append(rec.xml_id)
        if active:
            print('setting %d records active' % len(active_keys))
            if not DRYRUN:
                hr_employee.write(active_keys, active, {'active': True})
        if inactive:
            print('setting %d records inactive' % len(inactive_keys))
            if not DRYRUN:
                hr_employee.write(inactive_keys, inactive, {'active': False})
    #
    # update ir.model.data mappings
    #
    oe_records = dict(
            (r.id, r.xml_id)
            for r in get_records(
                oe, 'res.partner',
                domain=[('module','=','F74')],
                fields=['xml_id'],
                context=context,
                ))
    update_ir_model_data('res.partner', 74, oe_records)
    oe_records = dict(
            (r.id, r.xml_id)
            for r in get_records(
                oe, 'hr.employee',
                domain=[('module','=','F74')],
                fields=['xml_id'],
                context=context,
                ))
    update_ir_model_data('hr.employee', 74, oe_records)
    #
    print(
            '%d records changed\n%d records added\n%d records (maybe) deleted'
                % (changed_count, added_count, deleted_count),
            border='box',
            )

def handle_product_category():
    #
    # always use "full" method
    #
    print('processing CNVZas (product sales category)', border=('box','#'))
    global SALEABLE_CATEGORY_ID, ETC_CATEGORY_ID, category_ids
    cnvzas = fisData(11, rematch=r"as10..")
    print(cnvzas.filename, verbose=2)
    context = {'fis-updates': True, 'active_test': False}
    # these  are for tracking old/new versions of changed records
    old_changed_category_records = {}
    new_changed_category_records = {}
    # these are for added/deleted records
    added_category_records = {}
    deleted_records = {}
    # and the counts
    changed_count = 0
    added_count = 0
    deleted_count = 0
    product_category = Model(oe.get_model('product.category'), 'cnvzas', 'F11', context, RAISE_ON_EXCEPTION)
    ir_model_data = Model(oe.get_model('ir.model.data'), 'imd', '', context, RAISE_ON_EXCEPTION)
    _, SALEABLE_CATEGORY_ID = ir_model_data.get_object_reference('product', SALEABLE_CATEGORY_XMLID)
    #
    # get the "old" data from:
    # - full -> current OpenERP data
    #
    print('gathering data', border='flag')
    #
    # retrieve the OpenERP records that match the CNVZsv module
    #
    print('retrieving OpenERP records')
    all_oe_records = dict([
            (r.xml_id, r)
            for r in get_records(
                oe, 'product.category',
                domain=[('module','=','F11')],
                fields=[
                    'id', 'module', 'xml_id', 'name', 'parent_id', 'fis_shelf_life',
                    ],
                context=context,
                )
            ])
    # and update category_ids
    category_ids = ids = dict([
        (r.xml_id, r.id)
        for r in all_oe_records.values()
        ])
    ETC_CATEGORY_ID = ids.get('9')
    #
    # when doing a full compare, we have to convert every single fis record before we can
    # check for changes
    #
    print('retrieving and converting FIS records')
    all_fis_records = AttrDict()
    for fis_rec in cnvzas.values():
        category = convert_product_category_rec(fis_rec)
        all_fis_records[category.xml_id] = category
    #
    # now we can separate into new, changed, and deleted buckets
    #
    print('sorting changed, new, and deleted product category records')
    all_keys = set(all_fis_records.keys() + all_oe_records.keys())
    for key in all_keys:
        old_rec = all_oe_records.get(key)
        new_rec = all_fis_records.get(key)
        if old_rec is new_rec is None:
            continue
        if old_rec is None:
            added_category_records[key] = new_rec
            continue
        if new_rec is None:
            deleted_records[key] = old_rec
            continue
        # copy missing fields for proper equality testing
        new_rec.id = old_rec.id
        if new_rec == old_rec:
            continue
        #
        # we have changes, save the records for later comparison
        #
        old_changed_category_records[key] = old_rec
        new_changed_category_records[key] = new_rec
    #
    # at this point, all records are in AttrDict format, divided by deleted, added, and changed
    #
    # add new categories
    #
    if added_category_records:
        print('adding category records', border='flag')
    for key, category in sorted(added_category_records.items()):
        # replace parent_id?
        if not isinstance(category.parent_id, (int, long)):
            # must be a parent xml_id
            category.parent_id = ids[category.parent_id]
        # double-check that record doesn't already exist
        if not DRYRUN:
            category_id = product_category.search(domain=[('xml_id','=',key),('module','=','F11')])
            if category_id:
                [category_id] = category_id
                ids[key] = category_id
                product_category.error('FIS ID F11:%s (%s) already exists in OpenERP' % (key, category.name))
                continue
        added_count += 1
        logger.info(
                'F11:%s -- adding -- %s',
                key,
                (', '.join(['%s=%r' % (k, v) for k, v in category.items()]))
                )
        if LIST_RECORDS:
            echo('  F11:%s  %s' % (key, category.name), end='  ')
            print('||', '||'.join('%s -> %r' % (k, v) for k, v in category.items()), '||', end='')
            echo()
        if not DRYRUN:
            category_id = product_category.create(key, category)
            if category_id:
                category.id = category_id
                ids[key] = category_id
        else:
            # fake an id for the dryrun if parent category
            if len(key) == 1:
                ids[key] = 9999999
        if ETC_CATEGORY_ID is None and key == '9':
            ETC_CATEGORY_ID = ids[key]
    #
    # process changes
    #
    if old_changed_category_records:
        print('processing category changes', border='flag')
    assert set(old_changed_category_records.keys()) == set(new_changed_category_records.keys()),\
            "old and new category records mismatch"
    changed_category_xml_ids = sorted(old_changed_category_records.keys())
    relevant_changes = False
    for xml_id in changed_category_xml_ids:
        #
        # figure out the changes
        #
        old_record = old_changed_category_records[xml_id]
        new_record = new_changed_category_records[xml_id]
        assert set(old_record.keys()) == set(new_record.keys()),\
                ('old/new keys mismatch\nold:%s\n%s\nnew:%s\n%s' %
                    ('|'.join(sorted(old_record.keys())), box(str(old_record)),
                     '|'.join(sorted(new_record.keys())), box(str(new_record))))
        assert 'id' in old_record, box('id field missing for %r' % (xml_id, ))
        if not isinstance(new_record.parent_id, (int, long)):
            # must be a parent xml_id
            assert isinstance(new_record.parent_id, basestring), (
                    'new_record.parent_id should be a string, but is %r (%r)'
                    % (new_record.parent_id, type(new_record.parent_id))
                    )
            new_record.parent_id = ids.get(new_record.parent_id) or ids.get('9')
        assert isinstance(new_record.parent_id, (int, long)) and new_record.parent_id > 0, 'new_record.parent_id should be a positive integer, not %r\n' % (new_record.parent_id, ) + box(str(new_record))
        # check for user-updated-address and specials
        changes = get_updated_values(old_record, new_record)
        if changes:
            relevant_changes = True
            changed_count += 1
            logger.info(
                    'F11: changing -- %s  -->  %s',
                    xml_id,
                    ', '.join("%s=%r" % (k, v) for k, v in changes.items())
                    )
            if LIST_RECORDS:
                echo('  F11:%s  %s' % (xml_id, new_record.name), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in changes.items()), '||', end='')
                echo()
            if not DRYRUN:
                product_category.write(xml_id, new_record.id, changes)
    if not relevant_changes:
        print('...no relevant changes...')
    #
    # deleted/deactivate categories
    #
    if deleted_records:
        # toss any records that don't already exist in OpenERP
        for key, rec in sorted(deleted_records.items()):
            if key not in ids:
                deleted_records.pop(key)
            elif not all_oe_records[key].active:
                deleted_records.pop(key)
            elif LIST_RECORDS:
                echo('  F11:%s  %s' % (key, rec.name))
        deleted_count = len(deleted_records)
        if deleted_count:
            verb = 'deleting' if DELETE else 'deactivating'
            print('%s records' % verb, border='flag')
            logger.info(
                    'F11 -- %s -- %s',
                    verb,
                    ', '.join(sorted(deleted_records.keys()))
                    )
            if not DRYRUN:
                oe_ids = product_category.search(domain=[('xml_id','in',deleted_records.keys())])
                if DELETE:
                    product_category.delete(oe_ids, context=context)
                else:
                    product_category.write('...', oe_ids, {'active': False}, context=context)
    #
    # update ir.model.data mappings
    #
    oe_records = dict(
            (r.id, r.xml_id)
            for r in get_records(
                oe, 'product.category',
                domain=[('module','=','F11')],
                fields=['xml_id'],
                context=context,
                ))
    update_ir_model_data('product.category', 11, oe_records)
    #
    print('%d categories changed\n%d categories added\n%d categories %s'
            % (changed_count, added_count, deleted_count, ('deactivated','deleted')[DELETE]),
            border='box',
            )

def handle_product_location():
    #
    # always use "full" method
    #
    print('processing CNVZaa (product location)', border=('box','#'))
    cnvzaa = fisData(97, rematch=r"aa10.")
    print(cnvzaa.filename, verbose=2)
    context = {'fis-updates': True, 'active_test': False}
    # these  are for tracking old/new versions of changed records
    old_changed_location_records = {}
    new_changed_location_records = {}
    # these are for added/deleted records
    added_location_records = {}
    deleted_records = {}
    # and the counts
    changed_count = 0
    added_count = 0
    deleted_count = 0
    product_location = Model(oe.get_model('product.available_at'), 'cnvzaa', 'F11', context, RAISE_ON_EXCEPTION)
    #
    # get the "old" data from:
    # - full -> current OpenERP data
    #
    print('gathering data', border='flag')
    #
    # retrieve the OpenERP records that match the CNVZsv module
    #
    print('retrieving OpenERP records')
    all_oe_records = dict([
            (r.xml_id, r)
            for r in get_records(
                oe, 'product.available_at',
                domain=[('module','=','F97')],
                fields=[
                    'id', 'module', 'xml_id', 'name', 'available',
                    ],
                context=context,
                )
            ])
    # and update ids
    ids = dict([
        (r.xml_id, r.id)
        for r in all_oe_records.values()
        ])
    #
    # when doing a full compare, we have to convert every single fis record before we can
    # check for changes
    #
    print('retrieving and converting FIS records')
    all_fis_records = AttrDict()
    for fis_rec in cnvzaa.values():
        location = convert_product_location_rec(fis_rec)
        all_fis_records[location.xml_id] = location
    #
    # now we can separate into new, changed, and deleted buckets
    #
    print('sorting changed, new, and deleted customer category records')
    all_keys = set(all_fis_records.keys() + all_oe_records.keys())
    for key in all_keys:
        old_rec = all_oe_records.get(key)
        new_rec = all_fis_records.get(key)
        if old_rec is new_rec is None:
            continue
        if old_rec is None:
            added_location_records[key] = new_rec
            continue
        if new_rec is None:
            deleted_records[key] = old_rec
            continue
        # copy missing fields for proper equality testing
        new_rec.id = old_rec.id
        if new_rec == old_rec:
            continue
        #
        # we have changes, save the records for later comparison
        #
        old_changed_location_records[key] = old_rec
        new_changed_location_records[key] = new_rec
    #
    # at this point, all records are in AttrDict format, divided by deleted, added, and changed
    #
    # add new locations
    #
    if added_location_records:
        print('adding location records', border='flag')
    for key, location in sorted(added_location_records.items()):
        if not DRYRUN:
            # double-check that record doesn't already exist
            location_id = product_location.search(domain=[('xml_id','=',key),('module','=','F97')])
            if location_id:
                [location_id] = location_id
                ids[key] = location_id
                product_location.error('FIS ID F97:%s (%s) already exists in OpenERP' % (key, location.name))
                continue
        added_count += 1
        logger.info(
                'F97:%s -- adding -- %s',
                key,
                (', '.join(['%s=%r' % (k, v) for k, v in location.items()]))
                )
        if LIST_RECORDS:
            echo('  F97:%s  %s' % (key, location.name), end='  ')
            print('||', '||'.join('%s -> %r' % (k, v) for k, v in location.items()), '||', end='')
            echo()
        if not DRYRUN:
            location_id = product_location.create(key, location)
            if location_id:
                location.id = location_id
                ids[key] = location_id
    #
    # process changes
    #
    if old_changed_location_records:
        print('processing location changes', border='flag')
    assert set(old_changed_location_records.keys()) == set(new_changed_location_records.keys()),\
            "old and new location records mismatch"
    changed_location_xml_ids = sorted(old_changed_location_records.keys())
    relevant_changes = False
    for xml_id in changed_location_xml_ids:
        #
        # figure out the changes
        #
        old_record = old_changed_location_records[xml_id]
        new_record = new_changed_location_records[xml_id]
        assert set(old_record.keys()) == set(new_record.keys()),\
                ('old/new keys mismatch\nold:%s\n%s\nnew:%s\n%s' %
                    ('|'.join(sorted(old_record.keys())), box(str(old_record)),
                     '|'.join(sorted(new_record.keys())), box(str(new_record))))
        assert 'id' in old_record, box('id field missing for %r' % (xml_id, ))
        # check for user-updated-address and specials
        changes = get_updated_values(old_record, new_record)
        if changes:
            relevant_changes = True
            changed_count += 1
            logger.info(
                    'F97: changing -- %s  -->  %s',
                    xml_id,
                    ', '.join("%s=%r" % (k, v) for k, v in changes.items())
                    )
            if LIST_RECORDS:
                echo('  F97:%s  %s' % (xml_id, new_record.name), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in changes.items()), '||', end='')
                echo()
            if not DRYRUN:
                product_location.write(xml_id, new_record.id, changes)
    if not relevant_changes:
        print('...no relevant changes...')
    #
    # deleted/deactivate locations
    #
    if deleted_records:
        # toss any records that don't already exist in OpenERP
        for key, rec in sorted(deleted_records.items()):
            if key not in ids:
                deleted_records.pop(key)
            elif LIST_RECORDS:
                echo('  F97:%s  %s' % (key, rec.name))
        deleted_count = len(deleted_records)
        if deleted_count:
            verb = 'deleting' if DELETE else 'deactivating'
            print('%s records' % verb, border='flag')
            logger.info(
                    'F97 -- %s -- %s',
                    verb,
                    ', '.join(sorted(deleted_records.keys()))
                    )
            if not DRYRUN:
                oe_ids = product_location.search(domain=[('xml_id','in',deleted_records.keys())])
                if DELETE:
                    product_location.delete(oe_ids, context=context)
    #
    # update ir.model.data mappings
    #
    oe_records = dict(
            (r.id, r.xml_id)
            for r in get_records(
                oe, 'product.available_at',
                domain=[('module','=','F97')],
                fields=['xml_id'],
                context=context,
                ))
    update_ir_model_data('product.available_at', 97, oe_records)
    #
    print('%d locations changed\n%d locations added\n%d locations %s'
            % (changed_count, added_count, deleted_count, ('deactivated','deleted')[DELETE]),
            border='box',
            )

def handle_supplier(method):
    #
    # combine the posm and vnms tables to create supplier records;
    # majority of data comes from the posm table, with contact name,
    # phone, and fax numbers coming from vnms
    #
    # always use "full" method
    #
    global posm, vnms
    print('processing POSM/VNMS', border=('box','#'))
    vnms = fisData(65, rematch=r"10(......)")
    posm = fisData(163, rematch=r"10(......)")
    print(posm.filename, verbose=2)
    print(vnms.filename, verbose=2)
    context = {'fis-updates': True, 'active_test': False}
    # on the OpenERP side, supplier records use F163 as the FIS module
    res_partner = Model(oe.get_model('res.partner'), 'posm/vnms', 'F163', context, RAISE_ON_EXCEPTION)
    # these are for tracking original old/new records
    new_company_records = {}
    old_company_records = {}
    new_contact_records = {}
    old_contact_records = {}
    # these  are for tracking old/new versions of changed records
    old_changed_company_records = {}
    new_changed_company_records = {}
    old_changed_contact_records = {}
    new_changed_contact_records = {}
    # these are for added/deleted records
    added_company_records = {}
    added_contact_records = {}
    deleted_records = {}
    # and the counts
    changed_count = 0
    added_count = 0
    deleted_count = 0
    ids = {}
    #
    # get the "old" data from:
    # - full -> current OpenERP data
    #
    print('gathering data', border='flag')
    #
    # when doing a full compare, we have to convert every single fis record before we can
    # check for changes
    #
    print('retrieving and converting FIS records')
    all_keys = set(posm.keys() + vnms.keys())
    all_fis_records = AttrDict()
    for code in sorted(posm.keys()):
        key = code[2:]
        company, contact = convert_supplier_rec(key)
        if company is None:
            continue
        # if company/contact are invalid, just put them in the deleted category
        all_fis_records[company.xml_id] = company
        if '**NO LONGER HERE**' in company.name or '**OLDER/N.L.H. EMPLOYEE**' in company.name:
            deleted_records[company.xml_id] = company
        else:
            new_company_records[company.xml_id] = company
        if contact is not None:
            all_fis_records[contact.xml_id] = contact
            if '**NO LONGER HERE**' in contact.name or '**OLDER/N.L.H. EMPLOYEE**' in contact.name:
                deleted_records[contact.xml_id] = contact
            else:
                new_contact_records[contact.xml_id] = contact
    for code in sorted(vnms.keys()):
        key = code[2:]
        if key in vendor_codes:
            continue
        company, contact = convert_supplier_rec(key)
        if company is None:
            continue
        # if company/contact are invalid, just put them in the deleted category
        all_fis_records[company.xml_id] = company
        if '**NO LONGER HERE**' in company.name or '**OLDER/N.L.H. EMPLOYEE**' in company.name:
            deleted_records[company.xml_id] = company
        else:
            new_company_records[company.xml_id] = company
        if contact is not None:
            all_fis_records[contact.xml_id] = contact
            if '**NO LONGER HERE**' in contact.name or '**OLDER/N.L.H. EMPLOYEE**' in contact.name:
                deleted_records[contact.xml_id] = contact
            else:
                new_contact_records[contact.xml_id] = contact
    #
    # retrieve the OpenERP records that match the POSM/VNMS module, and divvy them up into company
    # and contact records
    #
    print('retrieving OpenERP records')
    all_oe_records = dict([
            (r.xml_id, r)
            for r in get_records(
                oe, 'res.partner',
                domain=[('module','=','F163')],
                fields=[
                    'id', 'module', 'xml_id', 'active', 'phone', 'fax',
                    'name', 'street', 'street2', 'city', 'state_id', 'zip', 'country_id',
                    'fis_valid', 'is_company', 'customer', 'supplier',
                    'fis_updated_by_user', 'use_parent_address',
                    'fis_org_cert_file', 'fis_non_gmo', 'fis_kosher', 'fis_org_exp',
                    'fis_gmo_exp', 'fis_kosher_exp',
                    ],
                context=context,
                )
            ])
    print('sorting company and contact records')
    for xml_id, datom in all_oe_records.items():
        ids[xml_id] = datom.id
        if xml_id.startswith('cntct_'):
            # do not update address from here -- it's either the default of "use parent's"
            # or it's been changed by the user (same with specials_notification)
            del datom.use_parent_address
            del datom.street, datom.street2
            del datom.city, datom.state_id, datom.zip, datom.country_id
            del datom.fis_org_cert_file, datom.fis_non_gmo, datom.fis_kosher
            del datom.fis_org_exp, datom.fis_gmo_exp, datom.fis_kosher_exp
            old_contact_records[xml_id] = datom
        else:
            old_company_records[xml_id] = datom
    #
    # now we can separate into new, changed, and deleted buckets
    #
    print('sorting company records into changed, new, and deleted')
    all_keys = set(new_company_records.keys() + old_company_records.keys())
    for key in all_keys:
        old_rec = all_oe_records.get(key)
        new_rec = all_fis_records.get(key)
        if old_rec is new_rec is None:
            assert False, "a key is missing from both old and new records???"
        if old_rec is None:
            if new_rec.active:
                added_company_records[key] = new_rec
            continue
        if new_rec is None:
            deleted_records[key] = old_rec
            continue
        if not new_rec.active:
            deleted_records[key] = old_rec
            continue
        # copy missing fields for proper equality testing / remove unused-for-comparison fields
        new_rec.id = old_rec.id
        new_rec.fis_updated_by_user = old_rec.fis_updated_by_user
        # for now, we don't want the FIS active status overwriting the OpenERP active status
        del new_rec.active, old_rec.active
        if set(new_rec.keys()) != set(old_rec.keys()):
            error('old_rec: %r  -- new_rec: %r' % (type(old_rec), type(new_rec)))
            error('old_rec._values.keys() --> %r\nnew_rec._values.keys() --> %r' % (
                old_rec._values.keys(), new_rec._values.keys()))
            raise AssertionError('old_rec/new_rec keys mismatch')
        if new_rec == old_rec:
            continue
        #
        # we have changes, save the records for later comparison
        #
        old_changed_company_records[key] = old_rec
        new_changed_company_records[key] = new_rec
    if set(old_changed_company_records.keys()) != set(new_changed_company_records.keys()):
        error('old_rec: %r  -- new_rec: %r' % (type(old_changed_company_records), type(new_changed_company_records)))
        raise AssertionError('old_changed_company_records/new_changed_company_records keys mismatch')
    #
    print('sorting contact records into changed, new, and deleted')
    all_keys = set(new_contact_records.keys() + old_contact_records.keys())
    for key in all_keys:
        parent_key = key[6:]
        old_rec = all_oe_records.get(key)
        new_rec = all_fis_records.get(key)
        if old_rec is new_rec is None:
            assert False, "a key is missing from both old and new records???"
        if old_rec is None:
            if new_rec.active:
                added_contact_records[key] = new_rec
            continue
        if new_rec is None:
            deleted_records[key] = old_rec
            continue
        if not new_rec.active:
            deleted_records[key] = old_rec
            continue
        if parent_key in deleted_records:
            deleted_records[key] = old_rec
            continue
        # copy missing fields for proper equality testing / remove unused-for-comparison fields
        new_rec.id = old_rec.id
        new_rec.fis_updated_by_user = old_rec.fis_updated_by_user
        del new_rec.use_parent_address
        # for now, we don't want the FIS active status overwriting the OpenERP active status
        del new_rec.active, old_rec.active
        assert set(new_rec.keys()) == set(old_rec.keys()), '\n'+box(
                "keys mismatch\n---\nold record:\n%s\n---\nnew record:\n%s"
                % ('\n'.join(old_rec.keys()), '\n'.join(new_rec.keys()))
                )
        if new_rec == old_rec:
            continue
        #
        # we have changes, save the records for later comparison
        #
        old_changed_contact_records[key] = old_rec
        new_changed_contact_records[key] = new_rec
    assert set(old_changed_contact_records.keys()) == set(new_changed_contact_records.keys()),\
            "old and new contact records mismatch"
    #
    # at this point, all records are in AttrDict format, divided by deleted, added, changed
    #
    # process company changes
    #
    if old_changed_company_records:
        print('processing company changes', border='flag')
    assert set(old_changed_company_records.keys()) == set(new_changed_company_records.keys()),\
            "old/new company records mismatch"
    changed_company_xml_ids = sorted(old_changed_company_records.keys())
    relevant_changes = False
    for xml_id in changed_company_xml_ids:
        #
        # TODO: check actual values in OpenERP and remove "changes" that are already set
        #
        # figure out the changes
        #
        old_record = old_changed_company_records[xml_id]
        new_record = new_changed_company_records[xml_id]
        assert set(old_record.keys()) == set(new_record.keys()),\
                ('old/new keys mismatch\nold:%s\n%s\nnew:%s\n%s' %
                    ('|'.join(sorted(old_record.keys())), box(str(old_record)),
                     '|'.join(sorted(new_record.keys())), box(str(new_record))))
        # check for user-updated-address and specials
        user_updates = old_record.fis_updated_by_user or ''
        if 'A' in user_updates:
            # drop all the address fields
            del old_record.use_parent_address
            del old_record.street, old_record.street2
            del old_record.city, old_record.state_id, old_record.zip, old_record.country_id
            del new_record.use_parent_address
            del new_record.street, new_record.street2
            del new_record.city, new_record.state_id, new_record.zip, new_record.country_id
        if 'N' in user_updates:
            del old_record.name
            del new_record.name
        changes = get_updated_values(old_record, new_record)
        if changes:
            relevant_changes = True
            changed_count += 1
            logger.info(
                    'F163: changing -- %s  -->  %s',
                    xml_id,
                    ', '.join("%s=%r" % (k, v) for k, v in changes.items())
                    )
            if LIST_RECORDS:
                echo('  F163:%s  %s' % (xml_id, new_record.name), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in changes.items()), '||', end='')
                echo()
            if not DRYRUN:
                res_partner.write(xml_id, new_record.id, changes)
    if not relevant_changes:
        print('...no relevant changes...')
    #
    # add new companies
    #
    if added_company_records:
        print('adding company records', border='flag')
    for key, company in added_company_records.items():
        if not DRYRUN:
            # double-check that record doesn't already exist
            company_id = res_partner.search(domain=[('xml_id','=',key),('module','=','F163')])
            if company_id:
                [company_id] = company_id
                ids[key] = company_id
                res_partner.error('FIS ID F163:%s (%s) already exists in OpenERP' % (key, company.name))
                continue
        added_count += 1
        logger.info(
                'F163:%s -- adding -- %s',
                key,
                (', '.join(['%s=%r' % (k, v) for k, v in company.items()]))
                )
        if LIST_RECORDS:
            echo('  F163:%s  %s' % (key, company.name), end='  ')
            print('||', '||'.join('%s -> %r' % (k, v) for k, v in company.items()), '||', end='')
            echo()
        if not DRYRUN:
            company_id = res_partner.create(key, company)
            if company_id:
                company.id = company_id
                ids[key] = company_id
    #
    # process contact changes
    #
    if old_changed_contact_records:
        print('processing contact changes', border='flag')
    assert set(old_changed_contact_records.keys()) == set(new_changed_contact_records.keys()),\
            "old/new contact records mismatch"
    changed_contact_xml_ids = sorted(old_changed_contact_records.keys())
    relevant_changes = False
    for xml_id in changed_contact_xml_ids:
        #
        # TODO: check actual values in OpenERP and remove "changes" that are already set
        #
        # figure out the changes
        #
        old_record = old_changed_contact_records[xml_id]
        new_record = new_changed_contact_records[xml_id]
        assert set(old_record.keys()) == set(new_record.keys()),\
                ('old/new keys mismatch\nold:%s\n%s\nnew:%s\n%s' %
                    ('|'.join(sorted(old_record.keys())), box(str(old_record)),
                     '|'.join(sorted(new_record.keys())), box(str(new_record))))
        # check for user-updated-address and specials
        user_updates = old_record.fis_updated_by_user or ''
        if 'A' in user_updates:
            # drop all the address fields
            del old_record.use_parent_address
            del old_record.street, old_record.street2
            del old_record.city, old_record.state_id, old_record.zip, old_record.country_id
            del new_record.use_parent_address
            del new_record.street, new_record.street2
            del new_record.city, new_record.state_id, new_record.zip, new_record.country_id
        if 'N' in user_updates:
            del old_record.name
            del new_record.name
        changes = get_updated_values(old_record, new_record)
        if changes:
            relevant_changes = True
            changed_count += 1
            if LIST_RECORDS:
                echo('  F163:%s  %s' % (xml_id, new_record.name), end='  ')
                print('||', '||'.join('%s -> %r' % (k, v) for k, v in changes.items()), '||', end='')
                echo()
            if not DRYRUN:
                res_partner.write(xml_id, new_record.id, changes)
    if not relevant_changes:
        print('...no relevant changes...')
    #
    # add new contacts
    #
    if added_contact_records:
        print('adding contact records', border='flag')
    for key, contact in added_contact_records.items():
        if not DRYRUN:
            # double-check that record doesn't already exist
            contact_id = res_partner.search(domain=[('xml_id','=',key),('module','=','F163')])
            if contact_id:
                [contact_id] = contact_id
                ids[key] = contact_id
                res_partner.error('FIS ID F163:%s (%s) already exists in OpenERP' % (key, contact.name))
                continue
        added_count += 1
        logger.info(
                'F163:%s -- adding -- %s',
                contact.name,
                (', '.join(['%s=%r' % (k, v) for k, v in contact.items()]))
                )
        if LIST_RECORDS:
            echo('  F163:%s  %s' % (key, contact.name), end='  ')
            print('||', '||'.join('%s -> %r' % (k, v) for k, v in contact.items()), '||', end='')
            echo()
        if not DRYRUN:
            contact_id = res_partner.create(key, contact)
            if contact_id:
                contact.id = contact_id
                ids[key] = contact_id
    #
    # deleted/deactivate suppliers
    #
    if deleted_records:
        # toss any records that don't already exist in OpenERP
        for key, rec in sorted(deleted_records.items()):
            if key not in ids:
                deleted_records.pop(key)
            elif not all_oe_records[key].active:
                deleted_records.pop(key)
            elif LIST_RECORDS:
                echo('  F163:%s  %s' % (key, rec.name))
        deleted_count = len(deleted_records)
        if deleted_count:
            verb = 'deleting' if DELETE else 'deactivating'
            print('%s records' % verb, border='flag')
            logger.info(
                    'F163 -- %s -- %s',
                    verb,
                    ', '.join(sorted(deleted_records.keys()))
                    )
            if not DRYRUN:
                oe_ids = res_partner.search(domain=[('xml_id','in',deleted_records.keys())])
                if DELETE:
                    res_partner.delete(oe_ids, context=context)
                else:
                    res_partner.write('...', oe_ids, {'active': False}, context=context)
    #
    # update ir.model.data mappings
    #
    oe_records = dict(
            (r.id, r.xml_id)
            for r in get_records(
                oe, 'res.partner',
                domain=[('module','=','F163')],
                fields=['xml_id'],
                context=context,
                ))
    update_ir_model_data('res.partner', 163, oe_records)
    #
    print('%d suppliers changed\n%d suppliers added\n%d suppliers %s'
            % (changed_count, added_count, deleted_count, ('deactivated','deleted')[DELETE]),
            border='box',
            )

def convert_arci_rec(fis_rec):
    item = AttrDict()
    cust_no = fis_rec[F262.cust_no]
    our_item_id = fis_rec[F262.our_item_id]
    cust_item_id = fis_rec[F262.cust_item_id]
    #
    # fis record
    #
    item.key = '%s-%s' % (cust_no, our_item_id)
    item.list_code = cust_no
    item.fis_code = our_item_id
    item.partner_id = Partner(cust_no)
    item.fis_product_id = Product(our_item_id)
    item.customer_product_code = cust_item_id or False
    item.source = 'fis'
    #
    return item

def convert_nvty_rec(fis_rec):
    # some fields come from non-FIS locations or are only update once per day -- those fields will not
    # be evaluated here:
    # - name -> get_product_descriptions()
    # - fis_qty: _produced, _consumed, _purchased, _sold, _available
    # - fis_10_day: _produced, _consumed, _purchased, _sold, _available
    # - fis_21_day: _produced, _cosnumed, _purchased, _sold, _available
    item = AttrDict()
    item.xml_id =  fis_rec[F135.item_id]
    item.module = 'F135'
    item.default_code = item.xml_id
    name = NameCase(fis_rec[F135.desc].strip())
    name = re.sub('sunridge', 'SunRidge', name, flags=re.I)
    item.fis_name = name
    item.active = True
    item.fis_availability_code = fis_rec[F135.available_key]
    # sale_ok actually tracks whether item is in the catalog
    item.sale_ok = len(fis_rec[F135.catalog_location]) == 10
    item.list_price = fis_rec[F135.new_whlsl]
    item.trademarks = fis_rec[F135.trademarkd]
    item.ean13 = sanitize_ean13(fis_rec[F135.upc_no])
    item.fis_location = fis_rec[F135.primary_location]
    item.fis_qty_on_hand = fis_rec[F135.qty_on_hand]
    item.weight = numeric(fis_rec[F135.grs_un_wt])
    item.weight_net = numeric(fis_rec[F135.net_un_wt])
    item.list_price = numeric(fis_rec[F135.new_retail])
    #
    shipping_size = fis_rec[F135.size].strip()
    if shipping_size.lower() in ('each','1 each','1/each'):
        shipping_size = '1 each'
    elif shipping_size:
        first, last = [], []
        letters = False
        for char in shipping_size:
            if char < ' ':
                char = ' '
            if letters or char.isalpha():
                last.append(char)
                letters = True
            else:
                first.append(char)
        if last == 'z':
            last = 'oz'
        shipping_size = ('%s %s' % (''.join(first).strip(), ''.join(last).strip())).strip()
    item.fis_shipping_size = shipping_size
    #
    category_code = fis_rec[F135.sales_cat].strip()
    if len(category_code) == 2 and category_code[0] in 'OIG':
        category_code = {'O':'0', 'I':'1', 'G':'6'}[category_code[0]] + category_code[1]
    category = product_sales_category.get(category_code)
    if category is not None:
        item.categ_id = category.id
        cat_shelf_life = float(category.fis_shelf_life or 0.0)
    else:
        product.error("%s: invalid sales category code -- %r" % (item.xml_id, category_code))
        cat_shelf_life = 0.0
    #
    item.warranty = float(fis_rec[F135.shelf_life_mos] or cat_shelf_life)
    #
    return item

def convert_product_category_rec(fis_rec):
    assert SALEABLE_CATEGORY_ID is not None, "SALEABLE_CATEGORY_ID has not been set"
    category = AttrDict()
    category.xml_id = key = fis_rec[F11.sales_category_id].strip()
    category.module = 'F11'
    category.fis_shelf_life = fis_rec[F11.shelf_life]
    name = re.sub('sunridge', 'SunRidge', fis_rec[F11.desc].title(), flags=re.I)
    if len(key) == 1:
        name = key + ' - ' + name.strip('- ')
        category.parent_id = SALEABLE_CATEGORY_ID
    else:
        parent_key = key[0]
        category.parent_id = category_ids.get(parent_key, parent_key)
    category.name = name
    return category

def convert_product_location_rec(fis_rec):
    location = AttrDict()
    location.xml_id = fis_rec[F97.availability_id].strip()
    location.module = 'F97'
    location.name = re.sub('sunridge', 'SunRidge', fis_rec[F97.desc].title(), flags=re.I)
    avail = fis_rec[F97.availability].upper()
    if avail not in 'YN':
        avail = False
    location.available = avail
    return location


def convert_emp1_rec(fis_rec):
    employee = AttrDict()
    employee.name = re.sub('sunridge', 'SunRidge', NameCase(fis_rec[F74.name]), flags=re.I)
    employee.xml_id = employee.identification_id = emp_num = fis_rec[F74.emp_num].strip()
    employee.module = 'F74-emp'
    try:
        if int(emp_num) >= 9000:
            return None
    except (ValueError, TypeError):
        return None
    employee.employment_type = 'standard'
    employee.update(process_address(F74, fis_rec, key=fis_rec[F74.emp_num], module='emp1', home=True))
    employee.home_phone = fix_phone(fis_rec[F74.tele])
    ssn = fis_rec[F74.ssn]
    if len(ssn) == 9:
        ssn = '%s-%s-%s' % (ssn[:3], ssn[3:5], ssn[5:])
    employee.ssnid = ssn
    employee.hire_date = hired = fix_date(fis_rec[F74.date_hired]) or False
    employee.fire_date = fired = fix_date(fis_rec[F74.date_terminated]) or False
    employee.active = (not fired or hired > fired)
    # employee birth dates are stored extra weirdly: if the year is 99 or less
    #   then the it's 19xx, but if any hex digits are present then the year is
    #   1740 + xx
    text = fis_rec[F74.birth_date]
    emp_birthday = None
    if text:
        month, day, year = int(text[:2]), int(text[2:4]), text[4:]
        if year.isdigit():
            year = 1900 + int(year)
        else:
            year = 1740 + int(year, 16)
        emp_birthday = '%d-%d-%d' % (year, month, day)
    employee.birthday = emp_birthday or False
    employee.status_flag = fis_rec[F74.status_flag]
    employee.pension_plan = fis_rec[F74.pension_status].upper() == 'Y'
    employee.pay_type = ('salary', 'hourly')[fis_rec[F74.pay_type].upper() == 'H']
    employee.hourly_rate = fis_rec[F74.hourly_rate]
    employee.last_raise = fix_date(fis_rec[F74.last_raise]) or False
    employee.marital = ('single', 'married')[fis_rec[F74.marital_status].upper() == 'M']
    employee.gender = ('male', 'female')[fis_rec[F74.gender].upper() == 'F']
    employee.emergency_contact = NameCase(fis_rec[F74.emergency_contact])
    employee.emergency_number = fix_phone(fis_rec[F74.emergency_phone])
    employee.federal_exemptions = int(fis_rec[F74.exempt_fed] or 0)
    employee.state_exemptions = int(fis_rec[F74.exempt_state] or 0)
    return employee

def convert_carrier_rec(fis_rec):
    company = AttrDict()
    company.name = re.sub('sunridge', 'SunRidge', BsnsCase(fis_rec[F27.name]), flags=re.I)
    company.xml_id = key = fis_rec[F27.code].strip()
    company.module = 'F27'
    company.is_company = True
    company.is_carrier = True
    company.use_parent_address = False
    if key == '99':
        company.name = '____________'
    company.update(process_address(F27, fis_rec, key=key, module='cnvzsv'))
    company.phone = fis_rec[F27.tele]
    company.fuel_surcharge = fis_rec[F27.fuel_surcharge].upper() == 'Y'
    return company

def convert_customer_salesrep_rec(fis_rec):
    salesrep = AttrDict()
    salesrep.xml_id = fis_rec[F47.salesperson_id]
    salesrep.module = 'F47'
    salesrep.fis_name = fis_rec[F47.salesperson_name].split('-')[0]
    return salesrep

def convert_customer_terms_rec(fis_rec):
    terms = AttrDict()
    terms.xml_id = fis_rec[F8.code]
    terms.module = 'F8'
    terms.description = ' / '.join([t.strip() for t in fis_rec[F8.description].split('/')])
    return terms

def convert_transmitter_code_rec(fis_rec):
    tran_code = AttrDict()
    tran_code.transmitter_no = fis_rec[F192.transmitter_no].strip()
    tran_code.transmitter_name = fis_rec[F192.transmitter_name].strip() or False
    tran_code.ship_to_code = fis_rec[F192.ship_to_id].strip() or False
    tran_code.partner_xml_id = fis_rec[F192.cust_no].strip() or False
    return tran_code

def convert_production_line_rec(fis_rec):
    line = AttrDict()
    line.xml_id = fis_rec[F341.prod_line_code]
    line.module = 'F341'
    line.desc = desc = fis_rec[F341.desc] or False
    if desc:
        new_desc = []
        for word in desc.split():
            if word.upper() in ('KFK','USA','LLC'):
                new_desc.append(word.upper())
            else:
                new_desc.append(word.title())
        line.desc = ' '.join(new_desc)
    return line

def convert_csms_rec(model, fis_rec, aging=None, _missing_reps=set()):
    #
    # creates an AttrDict with the following fields
    # - 'module', 'xml_id',
    # - 'name', 'street', 'street2', 'city', 'state_id', 'zip', 'country_id',
    # - 'fis_valid', 'specials_notification', 'phone', 'is_company', 'customer',
    # - 'use_parent_address', 'active', 'fis_transmitter_id',
    #
    # fields coming from OpenERP that are missing/invalid on the FIS side
    # - 'id', 'fis_updated_by_user'
    # - address fields (for contact)
    #
    # fis records use the following fields to detect changes
    #
    # enum_schema=[
    #     F33.name, F33.salesrep, F33.catalog_category, F33.this_year_sales,
    #     F33.last_year_sales, F33.tele, F33.contact,
    #     ],
    # address_fields=[
    #     F33.addr1, F33.addr2, F33.addr3,
    #     ],
    #
    company = AttrDict()
    # TODO: get salesrep working
    # rep = cus_rec[F33.salesrep]
    # rep = sales_people.get(rep, False)
    company.module = 'F33'
    company.xml_id = key = fis_rec[F33.code]
    company.name = re.sub('sunridge', 'SunRidge', BsnsCase(fis_rec[F33.name]), flags=re.I)
    company.is_company = True
    company.customer = True
    company.use_parent_address = False
    # valid customer code? active account?
    company.fis_valid = len(key) == 5
    company.active = False
    added = fis_rec[F33.date_added] or Date()
    if added:
        year, month, day = added[:2], int(added[2:4]), int(added[4:])
        if year.isdigit():
            year = 1900 + int(year)
        else:
            year = 1840 + int(year, 16)
        added = Date(year, month, day)
    if (
            fis_rec[F33.this_year_sales]
         or fis_rec[F33.last_year_sales]
         or added >= ONE_YEAR_AGO
        ):
        company.active = True
    else:
        # TODO check for open orders
        pass
    salesrep = fis_rec[F33.salesrep]
    sr = sales_person_recs.get(salesrep, False)
    if not sr or not sr.user_id:
        company.user_id = False
        if salesrep not in _missing_reps:
            _missing_reps.add(salesrep)
            error('no salesrep match found for %r' % (salesrep, ))
    else:
        company.user_id = sr.user_id.id
    notify_by = Specials.get_member(fis_rec[F33.catalog_category].upper(), Specials.neither)
    company.specials_notification = notify_by.value
    company.update(process_address(F33, fis_rec, key=fis_rec[F33.code], module='csms'))
    company.phone = fix_phone(fis_rec[F33.tele])
    company.fis_csms_terms = customer_terms_recs.get(fis_rec[F33.payment_terms_id], False)
    company.fis_price_list = fis_rec[F33.price_list_id] or False
    if not company.fis_csms_terms:
        model.error('Terms code %r does not exist' % (fis_rec[F33.payment_terms_id], ))
    if aging is not None and key in aging:
        account = aging[key]
        company.fis_credit_limit = account.limit
        company.fis_credit_current = account.current
        company.fis_credit_10_days = account.d10
        company.fis_credit_20_days = account.d20
        company.fis_credit_30_days = account.d30
        company.fis_credit_total = account.total
    else:
        company.fis_credit_limit = 0
        company.fis_credit_current = 0
        company.fis_credit_10_days = 0
        company.fis_credit_20_days = 0
        company.fis_credit_30_days = 0
        company.fis_credit_total = 0
    transmitter_code = transmitter_codes.get(key+'-default', False)
    company.fis_transmitter_id = transmitter_code and transmitter_code.id
    contact = None
    if fis_rec[F33.contact] and fis_rec[F33.contact] != fis_rec[F33.name]:
        contact = AttrDict()
        contact.name = NameCase(fis_rec[F33.contact])
        contact.xml_id = 'cntct_' + key
        contact.module = 'F33'
        contact.is_company = False
        contact.customer = True
        contact.use_parent_address = True
        contact.specials_notification = Specials.company
        contact.fis_valid = company.fis_valid
        contact.active = company.active
        contact.user_id = company.user_id
    return company, contact

def convert_csmss_rec(fis_rec, ignore=None):
    "additional ship-to addresses"
    #
    # creates an AttrDict with the following fields
    # - 'module', 'xml_id',
    # - 'name', 'street', 'street2', 'city', 'state_id', 'zip', 'country_id',
    # - 'fis_valid', 'phone', 'is_company', 'customer','use_parent_address',
    # - 'fis_ship_to_code', 'fis_ship_to_parent_id', 'fis_transmitter_code',
    #
    # fields coming from OpenERP that are missing/invalid on the FIS side
    # - 'id',
    #
    # fis records use the following fields to detect changes
    #
    # enum_schema=[
    #     F34.name, F34.addr1, F34.addr2, F34.addr3, F34.postal, F34.tele, F34.sales_contact,
    #     ],
    # address_fields=[
    #     F34.addr1, F34.addr2, F34.addr3,
    #     ],
    #
    ship_to = AttrDict()
    ship_to.active = True
    ship_to.name = re.sub('sunridge', 'SunRidge', BsnsCase(fis_rec[F34.name]), flags=re.I)
    parent_xml_id = fis_rec[F34.code]
    if not ship_to.name or parent_xml_id not in ship_to_parents or (ignore and ignore(fis_rec)):
        return None
    ship_to.fis_ship_to_code = code = fis_rec[F34.ship_to_no].strip() or 'default'
    ship_to.module = 'F34'
    ship_to.xml_id = '%s-%s' % (fis_rec[F34.code], code)
    ship_to.update(process_address(F34, fis_rec, key=fis_rec[F34.code], module='csmss'))
    ship_to.is_company = False
    ship_to.customer = False
    ship_to.use_parent_address = False
    ship_to.phone = fix_phone(fis_rec[F34.tele]) or False
    ship_to.fis_ship_to_parent_id = ship_to_parents[parent_xml_id]
    transmitter_code = transmitter_codes.get(ship_to.xml_id, False)
    if transmitter_code:
        ship_to.name = transmitter_code.transmitter_name or ship_to.name
        transmitter_code = transmitter_code.id
    ship_to.fis_transmitter_id = transmitter_code
    return ship_to

def convert_supplier_rec(key):
    #
    # creates a company AttrDict with the following fields
    # - 'module', 'xml_id', 'active',
    # - 'name', 'street', 'street2', 'city', 'state_id', 'zip', 'country_id',
    # - 'fis_valid', 'phone', 'fax', 'is_company', 'customer', 'fis_org_cert_file',
    # - 'fis_non_gmo', 'fis_kosher', 'fis_org_exp', 'fis_gmo_exp', 'fis_kosher_exp',
    #
    # creates a contact AttrDict with the following fields
    # - 'module', 'xml_id', 'active', 'name', 'phone', 'fax',
    # - 'is_company', 'customer', 'supplier', 'fis_valid',
    #
    # fields coming from OpenERP that are missing/invalid on the FIS side
    # - 'id', 'fis_updated_by_user'
    # - address fields (for contact)
    #
    posm_rec = posm.get(key)
    vendor_codes.add(key)
    if posm_rec is not None:
        contact_key = posm_rec[F163.vendor]
        if contact_key:
            vendor_codes.add(contact_key)
            vnms_rec = vnms.get(contact_key)
        else:
            vnms_rec = None
    else:
        vnms_rec = vnms.get(key)
    company = AttrDict()
    company.module = 'F163'
    company.xml_id = key
    company.is_company = True
    company.customer = False
    company.supplier = True
    company.use_parent_address = False
    company.fis_valid = len(key) == 6 and key.isdigit()
    company.active = company.fis_valid
    if posm_rec is not None:
        company.name = re.sub('sunridge', 'SunRidge', BsnsCase(posm_rec[F163.name]), flags=re.I)
        company.update(process_address(F163, posm_rec, key=posm_rec[F163.code], module='posm'))
        company.phone = fix_phone(posm_rec[F163.tele]) or False
        company.fax = fix_phone(posm_rec[F163.fax]) or False
        company.fis_org_cert_file = posm_rec[F163.org_cert_file].upper() in 'YO'
        company.fis_org_exp = fix_date(posm_rec[F163.cert_exp]) or False
        company.fis_non_gmo = posm_rec[F163.non_gmo].upper() in 'Y'
        company.fis_kosher = posm_rec[F163.kosher].upper() in 'Y'
        company.fis_gmo_exp = fix_date(posm_rec[F163.gmo_exp]) or False
        company.fis_kosher_exp = fix_date(posm_rec[F163.kosher_exp]) or False
    elif vnms_rec is not None:
        company.name = re.sub('sunridge', 'SunRidge', BsnsCase(vnms_rec[F65.name]), flags=re.I)
        company.update(process_address(F65, vnms_rec, key=vnms_rec[F65.code], module='posm'))
        company.phone = fix_phone(vnms_rec[F65.tele]) or False
        company.fax = fix_phone(vnms_rec[F65.fax]) or False
        company.fis_org_cert_file = vnms_rec[F65.org_cert_file].upper() in 'YO'
        company.fis_org_exp = fix_date(vnms_rec[F65.cert_exp]) or False
        company.fis_non_gmo = False
        company.fis_kosher = False
        company.fis_gmo_exp = False
        company.fis_kosher_exp = False
    else:
        error("invalid POSM/VNMS xml_id: %r" % (key, ))
        return None, None
    #
    contact = None
    if vnms_rec is not None and vnms_rec[F65.contact]:
        name = NameCase(vnms_rec[F65.contact])
        contact = AttrDict()
        contact.module = 'F163'
        contact.xml_id = 'cntct_' + key
        contact.active = company.active
        contact.name = name
        contact.fis_valid = company.fis_valid
        contact.is_company = False
        contact.customer = False
        contact.supplier = True
        contact.use_parent_address = True
        contact.phone = fix_phone(vnms_rec[F65.tele]) or False
        contact.fax = fix_phone(vnms_rec[F65.fax]) or False
    if contact is not None:
        if not re.match('\w{2,}', name):
            contact.active = False
    if not company.name:
        company.active = False
    return company, contact

def get_customer_aging(aging_file):
    aging_data = {}
    with open(config.network.fis_data_local_path/'customer_aging.txt') as af:
        lines = [line for line in af.read().split('\n') if line.strip()]
    try:
        for line in lines:
            # isolate FIS code
            key, rest = line.split(None, 1)
            # lines with filenames are invalid
            if key.endswith(':'):
                continue
            # isolate other info, ignoring company name
            limit, salesrep, total, d0, d10, d20, d30 = line.rsplit(None, 8)[-7:]
            aging_data[key] = CustomerAging(key, limit, d0, d10, d20, d30, total)
        return aging_data
    except Exception as exc:
        echo(exc, border='box')
        return {}

def get_product_descriptions():
    descriptions = {}
    with open(config.network.fis_data_local_path/'product_descriptions.txt') as f:
        lines = f.read().split('\n')
    for line in lines:
        match = re.match('(.{40})  \((\d{6})\)  (.*)$', line)
        if match:
            fis_desc, item_code, full_desc = match.groups()
            descriptions[item_code] = full_desc
    return descriptions

def get_product_forecast():
    # parse the daily-updated file with the product forecasts
    forecast = {}
    with open(config.network.fis_data_local_path/'product_forecast.txt') as f:
        lines = f.read().split('\n')
    for i, line in enumerate(lines):
        if not line.strip() or '-' not in line:
            continue
        try:
            text = line.split(' - ')[1]
        except IndexError:
            product.error('problem with forecast line #%d: %r' % (i, line))
            continue
        if 'ERROR' in text:
            continue
        try:
            item_code, _10_day, _21_day = text.split(':')
        except ValueError:
            product.error('problem with forecast line #%d: %r' % (i, line))
            continue
        prod_in, purch, prod_out, sold = _10_day.split()[2:6]
        prod_in = float(prod_in)
        purch = float(purch)
        prod_out = -(float(prod_out))
        sold = -(float(sold))
        _10_day = ForecastDetail(prod_in, purch, prod_out, sold)
        prod_in, purch, prod_out, sold = _21_day.split()[2:6]
        prod_in = float(prod_in)
        purch = float(purch)
        prod_out = -(float(prod_out))
        sold = -(float(sold))
        _21_day = ForecastDetail(prod_in, purch, prod_out, sold)
        forecast[item_code] = Forecast(item_code, _10_day, _21_day)
    return forecast

_raise_lookup = object()
class Specials(str, Enum):
    _order_ = 'neither catalog specials both default'
    neither   = 'N'
    catalog   = 'C'
    specials  = 'S'
    both      = 'B'
    default   = 'D'
    company   = default
    @classmethod
    def get_member(cls, text, default=_raise_lookup):
        for member in cls:
            if member.value == text:
                return member
        else:
            if default is not _raise_lookup:
                return default
        raise LookupError('%r not found in %s' % (text, cls.__name__))

def process_address(schema, fis_rec, key=None, module=None, home=False):
    if module is not None and key is None:
        raise ValueError('module specified but key was not')
    result = {}
    addr1, addr2, addr3 = Sift(fis_rec[schema.addr1], fis_rec[schema.addr2], fis_rec[schema.addr3])
    addr2, city, state, postal, country = cszk(addr2, addr3)
    addr3 = False
    addr1 = normalize_address(addr1)
    addr2 = normalize_address(addr2)
    addr1, addr2 = AddrCase(Rise(addr1, addr2))
    city = NameCase(city)
    state, country = NameCase(state), NameCase(country)
    valid_address = True
    if (
            not (addr1 or addr2)
            or not (city or state or country)
        ):
        # just use the FIS data without processing
        addr1, addr2, city = Rise(fis_rec[schema.addr1], fis_rec[schema.addr2], fis_rec[schema.addr3])
        state = country = ''
        postal = PostalCode('', '')
        valid_address = False
    if home:
        sf = 'home_street'
        s2f = 'home_street2'
        cf = 'home_city'
        sidf = 'home_state_id'
        zf = 'home_zip'
        kidf = 'home_country_id'
    else:
        sf = 'street'
        s2f = 'street2'
        cf = 'city'
        sidf = 'state_id'
        zf = 'zip'
        kidf = 'country_id'
    result[sf] = addr1 or False
    result[s2f] = addr2 or False
    result[cf] = city or False
    result[zf] = postal or False
    result[sidf] = False
    result[kidf] = False
    if valid_address:
        if state:
            result[sidf] = state_recs[state][0]
            result[kidf] = country = state_recs[state][2]
        elif country:
            country_id = country_recs.get(country, False)
            if country_id is False:
                if module is not None:
                    Model.errors[module].append("%s record %s has invalid country <%r>" % (module, key, country))
            else:
                result[kidf] = country_id
    return result

def is_invalid_posm_record(rec):
    if rec is None:
        return True
    xml_id = rec[F163.code]
    name = rec[F163.name]
    vendor_xml_id = rec[F163.vendor]
    vendor_rec = vnms.get(vendor_xml_id)
    if (
            len(xml_id) == 6
            and xml_id.isdigit()
            and name
            and len(vendor_xml_id) == 6
            and vendor_xml_id.isdigit()
            and vendor_rec is not None
        ):
        # valid record, record vendor mapping
        ven2sup[vendor_xml_id] = xml_id
        return False
    # invalid record
    return True

def is_contact(obj):
    "obj must be either a string or have an xml_id key"
    if not isinstance(obj, basestring):
        obj = obj.get('xml_id')
    return obj.startswith('cntct_')

def sanitize_ean13(ean13):
    """
    Creates and returns a valid ean13 from an invalid one
    """
    if not ean13:
        return "0000000000000"
    ean13 = re.sub("[A-Za-z]", "0", ean13);
    ean13 = re.sub("[^0-9]", "", ean13);
    ean13 = ean13[:13]
    if len(ean13) < 13:
        ean13 = ean13 + '0' * (13-len(ean13))
    return ean13[:-1] + str(ean_checksum(ean13))

def ean_checksum(eancode):
    """
    returns the checksum of an ean string of length 13, returns -1 if the string has the wrong length
    """
    if len(eancode) <> 13:
        return -1
    oddsum=0
    evensum=0
    total=0
    eanvalue=eancode
    reversevalue = eanvalue[::-1]
    finalean=reversevalue[1:]
    for i in range(len(finalean)):
        if i % 2 == 0:
            oddsum += int(finalean[i])
        else:
            evensum += int(finalean[i])
    total=(oddsum * 3) + evensum
    check = int(10 - math.ceil(total % 10.0)) % 10
    return check

def numeric(number):
    try:
        return int(number)
    except ValueError:
        try:
            return float(number)
        except ValueError:
            pass
    return False

def get_updated_values(old_record, new_record):
    changes = AttrDict()
    for key in old_record:
        old_value = old_record[key]
        new_value = new_record[key]
        if (old_value or new_value) and old_value != new_value:
            changes[key] = new_value
    return changes

class CustomerAging(NamedTuple):
    _order_ = "xml_id limit current d10 d20 d30 total"
    xml_id = 'customer key'
    limit = 'credit limit'
    current = 'charges within 10 days'
    d10 = 'charges between 11 and 20 days old'
    d20 = 'charges between 21 and 30 days old'
    d30 = 'charges over 30 days old'
    total = 'total outstanding balance'

    def __new__(cls, *values):
        new_values = [values[0]]
        for value in values[1:]:
            value = value.replace(',','')
            if value[-1:] == '-':
                value = '-' + value[:-1]
            new_values.append(float(value))
        return NamedTuple.__new__(CustomerAging, *new_values)


class ForecastDetail(NamedTuple):
    produced = 0, None, 0.0
    purchased = 1, None, 0.0
    consumed = 2, None, 0.0
    sold = 3, None, 0.0


class Forecast(NamedTuple):
    item = 0, None, ''
    day_10 = 1, None, ForecastDetail()
    day_21 = 2, None, ForecastDetail()


@PropertyNames
class Partner(IDEquality):
    """
    create singleton object for a partner, allow fields to be set only once
    """

    xml_id = SetOnce()
    id = SetOnce()
    _cache = {}

    def __new__(cls, xml_id):
        if xml_id not in cls._cache:
            obj = super(Partner, cls).__new__(cls)
            obj.xml_id = xml_id
            cls._cache[xml_id] = obj
        return cls._cache[xml_id]

    def __repr__(self):
        return "%s(id=%r, xml_id=%r)" % (self.__class__.__name__, self.id, self.xml_id)


@PropertyNames
class Product(IDEquality):
    """
    create singleton object for a product, allow fields to be set only once
    """

    xml_id = SetOnce()
    id = SetOnce()
    _cache = {}

    def __new__(cls, xml_id):
        if xml_id not in cls._cache:
            obj = super(Product, cls).__new__(cls)
            obj.xml_id = xml_id
            cls._cache[xml_id] = obj
        return cls._cache[xml_id]

    def __repr__(self):
        return "%s(id=%r, xml_id=%r)" % (self.__class__.__name__, self.id, self.xml_id)

def update_ir_model_data(model, table_number, oe_records):
    # oe_records = {id: key, ...}
    ir_model_data = oe.get_model('ir.model.data')
    imd_by_id = dict()
    imd_by_name = dict()
    for rec in ir_model_data.read(
            [('module','=','fis'), ('model','=',model)],
            fields=['name','res_id'],
        ):
        imd_by_id[rec.res_id] = rec
        imd_by_name[rec.name] = rec
    # remove missing ids first
    dead_ids = set([imd_rec.id for imd_rec in imd_by_id.values if imd_rec.res_id not in oe_records])
    if dead_ids:
        ir_model_data.unlink(dead_ids)
    for id, key in oe_records.items():
        imd_name = "F%03d_%s_%s" % (table_number, key, model.replace('.','_'))
        by_id = imd_by_id.get(id)
        by_name = imd_by_name.get(imd_name)
        if by_id and by_id == by_name:
            # we have records and they match
            continue
        elif not (by_id and by_name):
            # no records, so create one
            new_rec = AttrDict({
                    'module':'fis',
                    'model':model.replace('.','_'),
                    'res_id':id,
                    'name':imd_name,
                    })
            new_rec.id = ir_model_data.create(AttrDict)
            imd_by_id[new_rec.res_id] = new_rec
            imd_by_name[imd_name] = new_rec
        else:
            error('error with name %r:\n  oe record id: %d\n  ir.model.data res_id: %r\n  ir.model.data name: %r'
                    % (imd_name, id, by_id, by_name))

# old code
# def handle_sales_reps():
#     context = {'fis-updates': True}
#     res = AttrDict()
#     res.partner = oe.get_model('res.partner')
#     cnvzz = fisData(47)
#     if method == 'quick':
#         cnvz_old = fisData(47, data_path=config.network.fis_data_local_old_path)
#     failed_match = set()
#     def is_invalid_cnvz(sales_rec):
#         sales_id = rec[F47.salesperson_id].upper()
#         sales_name = rec[F47.salesperson_name]
#         company_id = rec[F47.company_id]
#         if company_id != '10':
#             return True
#         if '-' in sales_name:
#             sales_name, extra = sales_name.split('-')
#             if not extra.strip().isdigit() and sales_id != 'BAD':
#                 return True
#         return False
#     #
#     # saving below for later
#     #
#         sales_full_name = sales_name.lower()
#         names = sales_full_name.split()
#         if len(names) > 1:
#             sales_name = ' '.join([names[0], names[-1]])
#         else:
#             sales_name = sales_name.lower()
#         if sales_name in failed_match:
#             # this name already failed to match
#             continue
#         if var(potential_sales_people.get(sales_name)) is not None and len(var()) == 1:
#             # full-name match
#             sales_people[sales_id] = var()[0]
#         # elif len(names) == 1:
#         #     # if it didn't match before, it's not going to match now
#         #     pass
#         #     # potential_sales_people[sales_id] = None
#         #     # failed_match.add(sales_name)
#         elif var(potential_sales_people.get(names[-1])) and len(var()) == 1:
#             # last name match
#             sales_people[sales_id] = var()[0]
#         elif var(potential_sales_people.get(names[0])) and len(var()) == 1:
#             # first name match
#             sales_people[sales_id] = var()[0]
#         else:
#             # no match at all
#             # look for user matches and previously created dummy user accounts
#             all_users = res_users.browse(cr, uid, context=inactive_too)
#             all_users.sort(key=lambda r: not r.active)
#             if len(names) > 1:
#                 # try to match sales name with beginning of user name
#                 # e.g. "billy bob" with "billy bob joe"
#                 user = [u for u in all_users if u.name.lower().startswith(sales_name)]
#                 if user:
#                     if len(user) == 1:
#                         sales_people[sales_id] = user[0].id
#                         continue
#                     else:
#                         _logger.warning('unable to match %s (%s): too many possibles', sales_name, sales_id)
#                         failed_match.add(sales_name)
#                         continue
#
#                 login = names[0][0] + names[1]
#             else:
#                 login = names[0]
#             # try to match against login
#             # e.g. "billy bob" with "bbob"
#             for user in all_users:
#                 if login == user.login:
#                     sales_people[sales_id] = user.id
#                     break
#             else:
#                 # if we make it this far, no matches -- so let's create a new (inactive)
#                 # user so we can properly categorize customers
#                 _logger.warning('unable to match %s: creating dummy user', sales_name)
#                 id = res_users.create(
#                         cr, uid,
#                         {
#                             'name': NameCase(sales_name),
#                             'login': login,
#                             'active': False,
#                             'tz': 'America/Los_Angeles',
#                             },
#                         context=context)
#                 sales_people[sales_id] = id
#                 all_users.append(res_users.browse(cr, uid, id, context=inactive_too))
#             # continue
#             # failed_match.add(sales_name)

# main
Main()
